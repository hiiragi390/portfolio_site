/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar pkg = __webpack_require__(/*! ./../../package.json */ \"./node_modules/axios/package.json\");\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/helpers/validator.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_FacePoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/FacePoint */ \"./src/lib/FacePoint.ts\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\n/* harmony import */ var _util_MathUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/MathUtil */ \"./src/util/MathUtil.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\n\nvar canvas = document.getElementById('canvas');\nvar MODEL_FILES = {\n    moc3: './model/Hiyori/hiyori.moc3',\n    model3: './model/Hiyori/hiyori.model3.json',\n    physics3: './model/Hiyori/hiyori.physics3.json',\n    textures: [\n        './model/Hiyori/hiyori.2048/texture_00.png',\n        './model/Hiyori/hiyori.2048/texture_01.png'\n    ]\n};\nfunction load() {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, model, moc3, physics, textures, updatePoint_1, point_1, _handleOnMouseMove, e_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 3, , 4]);\n                    return [4 /*yield*/, Promise.all(__spreadArray([\n                            axios__WEBPACK_IMPORTED_MODULE_1___default().get(MODEL_FILES.model3, { responseType: 'arraybuffer' }).then(function (res) { return res.data; }),\n                            axios__WEBPACK_IMPORTED_MODULE_1___default().get(MODEL_FILES.moc3, { responseType: 'arraybuffer' }).then(function (res) { return res.data; }),\n                            axios__WEBPACK_IMPORTED_MODULE_1___default().get(MODEL_FILES.physics3, { responseType: 'arraybuffer' }).then(function (res) { return res.data; })\n                        ], MODEL_FILES.textures.map(function (texture) {\n                            return axios__WEBPACK_IMPORTED_MODULE_1___default().get(texture, { responseType: 'blob' }).then(function (res) { return res.data; });\n                        }), true))];\n                case 1:\n                    _a = _b.sent(), model = _a[0], moc3 = _a[1], physics = _a[2], textures = _a.slice(3);\n                    return [4 /*yield*/, (0,_renderer__WEBPACK_IMPORTED_MODULE_2__.live2dRender)(canvas, model, {\n                            moc3: moc3,\n                            physics: physics,\n                            textures: textures,\n                        }, {\n                            autoBlink: true,\n                            x: 0,\n                            y: 1,\n                            scale: 1\n                        })];\n                case 2:\n                    updatePoint_1 = (_b.sent()).updatePoint;\n                    point_1 = new _lib_FacePoint__WEBPACK_IMPORTED_MODULE_0__.FacePoint();\n                    _handleOnMouseMove = function (e) {\n                        var x = e.clientX;\n                        var y = e.clientY;\n                        var rect = canvas.getBoundingClientRect();\n                        var cx = rect.left + rect.width / 2;\n                        var cy = rect.top + rect.height / 2;\n                        var distance = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_3__.getDistance)(x, y, cx, cy);\n                        var dx = cx - x;\n                        var dy = cy - y;\n                        var angle = (0,_util_MathUtil__WEBPACK_IMPORTED_MODULE_3__.getAngle)(x, y, cx, cy);\n                        var r = Math.cos(angle) * Math.sin(angle) * 180 / Math.PI;\n                        Object.assign(point_1, {\n                            angleX: -dx / 10,\n                            angleY: dy / 10,\n                            angleZ: r * (distance / cx),\n                            angleEyeX: -dx / cx,\n                            angleEyeY: dy / cy,\n                        });\n                        updatePoint_1(point_1);\n                    };\n                    document.body.addEventListener('mousemove', _handleOnMouseMove, false);\n                    return [3 /*break*/, 4];\n                case 3:\n                    e_1 = _b.sent();\n                    alert(e_1.message);\n                    console.error(e_1);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nwindow.addEventListener('load', function () {\n    load();\n});\n\n\n//# sourceURL=webpack://my-webpack-project/./src/index.ts?");

/***/ }),

/***/ "./src/lib/CubismModel.ts":
/*!********************************!*\
  !*** ./src/lib/CubismModel.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./live2d/Live2dSDK */ \"./src/lib/live2d/Live2dSDK.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar AppCubismUserModel = /** @class */ (function (_super) {\n    __extends(AppCubismUserModel, _super);\n    function AppCubismUserModel() {\n        var _this = _super.call(this) || this;\n        _this.lipSyncParamIds = new _live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        _this.eyeBlinkParamIds = new _live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        _this.motionResources = {};\n        _this.lipSyncParamIds = new _live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        _this.eyeBlinkParamIds = new _live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        return _this;\n    }\n    /**\n     * 自動目ぱちを設定\n     * @param eyeBlink\n     */\n    AppCubismUserModel.prototype.setEyeBlink = function (eyeBlink) {\n        this._eyeBlink = eyeBlink;\n    };\n    /**\n     * モーション更新時に置き換える目ぱち用IDを追加\n     * @param id 目ぱち用ID\n     */\n    AppCubismUserModel.prototype.addEyeBlinkParameterId = function (id) {\n        this.eyeBlinkParamIds.pushBack(id);\n    };\n    /**\n     * モーション更新時に置き換える口パク用IDを追加\n     * @param id 口パク用ID\n     */\n    AppCubismUserModel.prototype.addLipSyncParameterId = function (id) {\n        this.lipSyncParamIds.pushBack(id);\n    };\n    /**\n     * モーションを追加して、ID（インデックス）を返す\n     * @param buffer モーションデータ\n     * @param name モーション名\n     */\n    AppCubismUserModel.prototype.addMotion = function (buffer, name, fadeIn, fadeOut) {\n        if (fadeIn === void 0) { fadeIn = 1; }\n        if (fadeOut === void 0) { fadeOut = 1; }\n        var motion = this.loadMotion(buffer, buffer.byteLength, name);\n        if (fadeIn > 0)\n            motion.setFadeInTime(fadeIn);\n        if (fadeOut > 0)\n            motion.setFadeOutTime(fadeOut);\n        motion.setEffectIds(this.eyeBlinkParamIds, this.lipSyncParamIds);\n        this.motionResources[name] = motion;\n        return name;\n    };\n    Object.defineProperty(AppCubismUserModel.prototype, \"motionNames\", {\n        /**\n         * 登録されているモーションのIDと名前のリストを返す\n         */\n        get: function () {\n            return Object.keys(this.motionResources);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AppCubismUserModel.prototype, \"isMotionFinished\", {\n        /**\n         * モーションの再生が終わっているかどうか\n         */\n        get: function () {\n            return this._motionManager.isFinished();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * モーションの名前を指定して再生する\n     * @param name モーション名\n     */\n    AppCubismUserModel.prototype.startMotionByName = function (name) {\n        var motion = this.motionResources[name];\n        if (!motion)\n            return;\n        this._motionManager.startMotionPriority(motion, false, 0);\n    };\n    /**\n     * モデルのパラメータを更新する\n     */\n    AppCubismUserModel.prototype.update = function (deltaTimeSecond) {\n        this.getModel().loadParameters();\n        // モデルのパラメータを更新\n        var motionUpdated = this._motionManager.updateMotion(this.getModel(), deltaTimeSecond);\n        this.getModel().saveParameters();\n        // まばたき\n        if (!motionUpdated && this._eyeBlink != null) {\n            this._eyeBlink.updateParameters(this._model, deltaTimeSecond);\n        }\n        // ポーズ\n        if (this._pose !== null) {\n            this._pose.updateParameters(this._model, 0);\n        }\n        // 物理演算\n        if (this._physics != null) {\n            this._physics.evaluate(this._model, deltaTimeSecond);\n        }\n        this._model.update();\n    };\n    return AppCubismUserModel;\n}(_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismUserModel));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppCubismUserModel);\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/CubismModel.ts?");

/***/ }),

/***/ "./src/lib/FacePoint.ts":
/*!******************************!*\
  !*** ./src/lib/FacePoint.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FacePoint\": () => (/* binding */ FacePoint)\n/* harmony export */ });\nvar FacePoint = /** @class */ (function () {\n    function FacePoint() {\n        this.angleX = 0;\n        this.angleY = 0;\n        this.angleZ = 0;\n        this.angleEyeX = 0;\n        this.angleEyeY = 0;\n        this.mouseDistance = 0;\n        this.autoBlink = false;\n    }\n    return FacePoint;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/FacePoint.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/cubismframeworkconfig.ts":
/*!***********************************************************!*\
  !*** ./src/lib/live2d/Framework/cubismframeworkconfig.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CSM_LOG_LEVEL\": () => (/* binding */ CSM_LOG_LEVEL),\n/* harmony export */   \"CSM_LOG_LEVEL_DEBUG\": () => (/* binding */ CSM_LOG_LEVEL_DEBUG),\n/* harmony export */   \"CSM_LOG_LEVEL_ERROR\": () => (/* binding */ CSM_LOG_LEVEL_ERROR),\n/* harmony export */   \"CSM_LOG_LEVEL_INFO\": () => (/* binding */ CSM_LOG_LEVEL_INFO),\n/* harmony export */   \"CSM_LOG_LEVEL_OFF\": () => (/* binding */ CSM_LOG_LEVEL_OFF),\n/* harmony export */   \"CSM_LOG_LEVEL_VERBOSE\": () => (/* binding */ CSM_LOG_LEVEL_VERBOSE),\n/* harmony export */   \"CSM_LOG_LEVEL_WARNING\": () => (/* binding */ CSM_LOG_LEVEL_WARNING)\n/* harmony export */ });\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n//========================================================\n//  ログ出力関数の設定\n//========================================================\n//---------- ログ出力レベル 選択項目 定義 ----------\n// 詳細ログ出力設定\nvar CSM_LOG_LEVEL_VERBOSE = 0;\n// デバッグログ出力設定\nvar CSM_LOG_LEVEL_DEBUG = 1;\n// Infoログ出力設定\nvar CSM_LOG_LEVEL_INFO = 2;\n// 警告ログ出力設定\nvar CSM_LOG_LEVEL_WARNING = 3;\n// エラーログ出力設定\nvar CSM_LOG_LEVEL_ERROR = 4;\n// ログ出力オフ設定\nvar CSM_LOG_LEVEL_OFF = 5;\n/**\n * ログ出力レベル設定。\n *\n * 強制的にログ出力レベルを変える時に定義を有効にする。\n * CSM_LOG_LEVEL_VERBOSE ～ CSM_LOG_LEVEL_OFF を選択する。\n */\nvar CSM_LOG_LEVEL = CSM_LOG_LEVEL_VERBOSE;\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/cubismframeworkconfig.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/cubismmodelsettingjson.ts":
/*!************************************************************!*\
  !*** ./src/lib/live2d/Framework/cubismmodelsettingjson.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismModelSettingJson\": () => (/* binding */ CubismModelSettingJson),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _icubismmodelsetting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icubismmodelsetting */ \"./src/lib/live2d/Framework/icubismmodelsetting.ts\");\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismmodelsettingjson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cubismmodelsettingjson */ \"./src/lib/live2d/Framework/cubismmodelsettingjson.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * Model3Jsonのキー文字列\n */\n// JSON Keys\nvar Version = 'Version';\nvar FileReferences = 'FileReferences';\nvar Groups = 'Groups';\nvar Layout = 'Layout';\nvar HitAreas = 'HitAreas';\nvar Moc = 'Moc';\nvar Textures = 'Textures';\nvar Physics = 'Physics';\nvar Pose = 'Pose';\nvar Expressions = 'Expressions';\nvar Motions = 'Motions';\nvar UserData = 'UserData';\nvar Name = 'Name';\nvar FilePath = 'File';\nvar Id = 'Id';\nvar Ids = 'Ids';\nvar Target = 'Target';\n// Motions\nvar Idle = 'Idle';\nvar TapBody = 'TapBody';\nvar PinchIn = 'PinchIn';\nvar PinchOut = 'PinchOut';\nvar Shake = 'Shake';\nvar FlickHead = 'FlickHead';\nvar Parameter = 'Parameter';\nvar SoundPath = 'Sound';\nvar FadeInTime = 'FadeInTime';\nvar FadeOutTime = 'FadeOutTime';\n// Layout\nvar CenterX = 'CenterX';\nvar CenterY = 'CenterY';\nvar X = 'X';\nvar Y = 'Y';\nvar Width = 'Width';\nvar Height = 'Height';\nvar LipSync = 'LipSync';\nvar EyeBlink = 'EyeBlink';\nvar InitParameter = 'init_param';\nvar InitPartsVisible = 'init_parts_visible';\nvar Val = 'val';\nvar FrequestNode;\n(function (FrequestNode) {\n    FrequestNode[FrequestNode[\"FrequestNode_Groups\"] = 0] = \"FrequestNode_Groups\";\n    FrequestNode[FrequestNode[\"FrequestNode_Moc\"] = 1] = \"FrequestNode_Moc\";\n    FrequestNode[FrequestNode[\"FrequestNode_Motions\"] = 2] = \"FrequestNode_Motions\";\n    FrequestNode[FrequestNode[\"FrequestNode_Expressions\"] = 3] = \"FrequestNode_Expressions\";\n    FrequestNode[FrequestNode[\"FrequestNode_Textures\"] = 4] = \"FrequestNode_Textures\";\n    FrequestNode[FrequestNode[\"FrequestNode_Physics\"] = 5] = \"FrequestNode_Physics\";\n    FrequestNode[FrequestNode[\"FrequestNode_Pose\"] = 6] = \"FrequestNode_Pose\";\n    FrequestNode[FrequestNode[\"FrequestNode_HitAreas\"] = 7] = \"FrequestNode_HitAreas\";\n})(FrequestNode || (FrequestNode = {}));\n/**\n * Model3Jsonパーサー\n *\n * model3.jsonファイルをパースして値を取得する\n */\nvar CubismModelSettingJson = /** @class */ (function (_super) {\n    __extends(CubismModelSettingJson, _super);\n    /**\n     * 引数付きコンストラクタ\n     *\n     * @param buffer    Model3Jsonをバイト配列として読み込んだデータバッファ\n     * @param size      Model3Jsonのデータサイズ\n     */\n    function CubismModelSettingJson(buffer, size) {\n        var _this = _super.call(this) || this;\n        _this._json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__.CubismJson.create(buffer, size);\n        if (_this._json) {\n            _this._jsonValue = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector();\n            // 順番はenum FrequestNodeと一致させる\n            _this._jsonValue.pushBack(_this._json.getRoot().getValueByString(Groups));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Moc));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Motions));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Expressions));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Textures));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Physics));\n            _this._jsonValue.pushBack(_this._json\n                .getRoot()\n                .getValueByString(FileReferences)\n                .getValueByString(Pose));\n            _this._jsonValue.pushBack(_this._json.getRoot().getValueByString(HitAreas));\n        }\n        return _this;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismModelSettingJson.prototype.release = function () {\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__.CubismJson[\"delete\"](this._json);\n        this._jsonValue = null;\n    };\n    /**\n     * CubismJsonオブジェクトを取得する\n     *\n     * @return CubismJson\n     */\n    CubismModelSettingJson.prototype.GetJson = function () {\n        return this._json;\n    };\n    /**\n     * Mocファイルの名前を取得する\n     * @return Mocファイルの名前\n     */\n    CubismModelSettingJson.prototype.getModelFileName = function () {\n        if (!this.isExistModelFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Moc).getRawString();\n    };\n    /**\n     * モデルが使用するテクスチャの数を取得する\n     * テクスチャの数\n     */\n    CubismModelSettingJson.prototype.getTextureCount = function () {\n        if (!this.isExistTextureFiles()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getSize();\n    };\n    /**\n     * テクスチャが配置されたディレクトリの名前を取得する\n     * @return テクスチャが配置されたディレクトリの名前\n     */\n    CubismModelSettingJson.prototype.getTextureDirectory = function () {\n        var texturePath = this._jsonValue\n            .at(FrequestNode.FrequestNode_Textures)\n            .getValueByIndex(0)\n            .getRawString();\n        var pathArray = texturePath.split('/');\n        // 最後の要素はテクスチャ名なので不要\n        var arrayLength = pathArray.length - 1;\n        var textureDirectoryStr = '';\n        // 分割したパスを結合\n        for (var i = 0; i < arrayLength; i++) {\n            textureDirectoryStr += pathArray[i];\n            if (i < arrayLength - 1) {\n                textureDirectoryStr += '/';\n            }\n        }\n        return textureDirectoryStr;\n    };\n    /**\n     * モデルが使用するテクスチャの名前を取得する\n     * @param index 配列のインデックス値\n     * @return テクスチャの名前\n     */\n    CubismModelSettingJson.prototype.getTextureFileName = function (index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Textures)\n            .getValueByIndex(index)\n            .getRawString();\n    };\n    /**\n     * モデルに設定された当たり判定の数を取得する\n     * @return モデルに設定された当たり判定の数\n     */\n    CubismModelSettingJson.prototype.getHitAreasCount = function () {\n        if (!this.isExistHitAreas()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getSize();\n    };\n    /**\n     * 当たり判定に設定されたIDを取得する\n     *\n     * @param index 配列のindex\n     * @return 当たり判定に設定されたID\n     */\n    CubismModelSettingJson.prototype.getHitAreaId = function (index) {\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.CubismFramework.getIdManager().getId(this._jsonValue\n            .at(FrequestNode.FrequestNode_HitAreas)\n            .getValueByIndex(index)\n            .getValueByString(Id)\n            .getRawString());\n    };\n    /**\n     * 当たり判定に設定された名前を取得する\n     * @param index 配列のインデックス値\n     * @return 当たり判定に設定された名前\n     */\n    CubismModelSettingJson.prototype.getHitAreaName = function (index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_HitAreas)\n            .getValueByIndex(index)\n            .getValueByString(Name)\n            .getRawString();\n    };\n    /**\n     * 物理演算設定ファイルの名前を取得する\n     * @return 物理演算設定ファイルの名前\n     */\n    CubismModelSettingJson.prototype.getPhysicsFileName = function () {\n        if (!this.isExistPhysicsFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Physics).getRawString();\n    };\n    /**\n     * パーツ切り替え設定ファイルの名前を取得する\n     * @return パーツ切り替え設定ファイルの名前\n     */\n    CubismModelSettingJson.prototype.getPoseFileName = function () {\n        if (!this.isExistPoseFile()) {\n            return '';\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Pose).getRawString();\n    };\n    /**\n     * 表情設定ファイルの数を取得する\n     * @return 表情設定ファイルの数\n     */\n    CubismModelSettingJson.prototype.getExpressionCount = function () {\n        if (!this.isExistExpressionFile()) {\n            return 0;\n        }\n        return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getSize();\n    };\n    /**\n     * 表情設定ファイルを識別する名前（別名）を取得する\n     * @param index 配列のインデックス値\n     * @return 表情の名前\n     */\n    CubismModelSettingJson.prototype.getExpressionName = function (index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Expressions)\n            .getValueByIndex(index)\n            .getValueByString(Name)\n            .getRawString();\n    };\n    /**\n     * 表情設定ファイルの名前を取得する\n     * @param index 配列のインデックス値\n     * @return 表情設定ファイルの名前\n     */\n    CubismModelSettingJson.prototype.getExpressionFileName = function (index) {\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Expressions)\n            .getValueByIndex(index)\n            .getValueByString(FilePath)\n            .getRawString();\n    };\n    /**\n     * モーショングループの数を取得する\n     * @return モーショングループの数\n     */\n    CubismModelSettingJson.prototype.getMotionGroupCount = function () {\n        if (!this.isExistMotionGroups()) {\n            return 0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getKeys()\n            .getSize();\n    };\n    /**\n     * モーショングループの名前を取得する\n     * @param index 配列のインデックス値\n     * @return モーショングループの名前\n     */\n    CubismModelSettingJson.prototype.getMotionGroupName = function (index) {\n        if (!this.isExistMotionGroups()) {\n            return null;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getKeys()\n            .at(index);\n    };\n    /**\n     * モーショングループに含まれるモーションの数を取得する\n     * @param groupName モーショングループの名前\n     * @return モーショングループの数\n     */\n    CubismModelSettingJson.prototype.getMotionCount = function (groupName) {\n        if (!this.isExistMotionGroupName(groupName)) {\n            return 0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getSize();\n    };\n    /**\n     * グループ名とインデックス値からモーションファイル名を取得する\n     * @param groupName モーショングループの名前\n     * @param index     配列のインデックス値\n     * @return モーションファイルの名前\n     */\n    CubismModelSettingJson.prototype.getMotionFileName = function (groupName, index) {\n        if (!this.isExistMotionGroupName(groupName)) {\n            return '';\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FilePath)\n            .getRawString();\n    };\n    /**\n     * モーションに対応するサウンドファイルの名前を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return サウンドファイルの名前\n     */\n    CubismModelSettingJson.prototype.getMotionSoundFileName = function (groupName, index) {\n        if (!this.isExistMotionSoundFile(groupName, index)) {\n            return '';\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(SoundPath)\n            .getRawString();\n    };\n    /**\n     * モーション開始時のフェードイン処理時間を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return フェードイン処理時間[秒]\n     */\n    CubismModelSettingJson.prototype.getMotionFadeInTimeValue = function (groupName, index) {\n        if (!this.isExistMotionFadeIn(groupName, index)) {\n            return -1.0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    };\n    /**\n     * モーション終了時のフェードアウト処理時間を取得する\n     * @param groupName モーショングループの名前\n     * @param index 配列のインデックス値\n     * @return フェードアウト処理時間[秒]\n     */\n    CubismModelSettingJson.prototype.getMotionFadeOutTimeValue = function (groupName, index) {\n        if (!this.isExistMotionFadeOut(groupName, index)) {\n            return -1.0;\n        }\n        return this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    };\n    /**\n     * ユーザーデータのファイル名を取得する\n     * @return ユーザーデータのファイル名\n     */\n    CubismModelSettingJson.prototype.getUserDataFile = function () {\n        if (!this.isExistUserDataFile()) {\n            return '';\n        }\n        return this._json\n            .getRoot()\n            .getValueByString(FileReferences)\n            .getValueByString(UserData)\n            .getRawString();\n    };\n    /**\n     * レイアウト情報を取得する\n     * @param outLayoutMap csmMapクラスのインスタンス\n     * @return true レイアウト情報が存在する\n     * @return false レイアウト情報が存在しない\n     */\n    CubismModelSettingJson.prototype.getLayoutMap = function (outLayoutMap) {\n        // 存在しない要素にアクセスするとエラーになるためValueがnullの場合はnullを代入する\n        var map = this._json\n            .getRoot()\n            .getValueByString(Layout)\n            .getMap();\n        if (map == null) {\n            return false;\n        }\n        var ret = false;\n        for (var ite = map.begin(); ite.notEqual(map.end()); ite.preIncrement()) {\n            outLayoutMap.setValue(ite.ptr().first, ite.ptr().second.toFloat());\n            ret = true;\n        }\n        return ret;\n    };\n    /**\n     * 目パチに関連付けられたパラメータの数を取得する\n     * @return 目パチに関連付けられたパラメータの数\n     */\n    CubismModelSettingJson.prototype.getEyeBlinkParameterCount = function () {\n        if (!this.isExistEyeBlinkParameters()) {\n            return 0;\n        }\n        var num = 0;\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            var refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == EyeBlink) {\n                num = refI.getValueByString(Ids).getVector().getSize();\n                break;\n            }\n        }\n        return num;\n    };\n    /**\n     * 目パチに関連付けられたパラメータのIDを取得する\n     * @param index 配列のインデックス値\n     * @return パラメータID\n     */\n    CubismModelSettingJson.prototype.getEyeBlinkParameterId = function (index) {\n        if (!this.isExistEyeBlinkParameters()) {\n            return null;\n        }\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            var refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == EyeBlink) {\n                return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());\n            }\n        }\n        return null;\n    };\n    /**\n     * リップシンクに関連付けられたパラメータの数を取得する\n     * @return リップシンクに関連付けられたパラメータの数\n     */\n    CubismModelSettingJson.prototype.getLipSyncParameterCount = function () {\n        if (!this.isExistLipSyncParameters()) {\n            return 0;\n        }\n        var num = 0;\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            var refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == LipSync) {\n                num = refI.getValueByString(Ids).getVector().getSize();\n                break;\n            }\n        }\n        return num;\n    };\n    /**\n     * リップシンクに関連付けられたパラメータの数を取得する\n     * @param index 配列のインデックス値\n     * @return パラメータID\n     */\n    CubismModelSettingJson.prototype.getLipSyncParameterId = function (index) {\n        if (!this.isExistLipSyncParameters()) {\n            return null;\n        }\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {\n            var refI = this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i);\n            if (refI.isNull() || refI.isError()) {\n                continue;\n            }\n            if (refI.getValueByString(Name).getRawString() == LipSync) {\n                return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());\n            }\n        }\n        return null;\n    };\n    /**\n     * モデルファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistModelFile = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Moc);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * テクスチャファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistTextureFiles = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Textures);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 当たり判定のキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistHitAreas = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_HitAreas);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 物理演算ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistPhysicsFile = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Physics);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * ポーズ設定ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistPoseFile = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Pose);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 表情設定ファイルのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistExpressionFile = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Expressions);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * モーショングループのキーが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistMotionGroups = function () {\n        var node = this._jsonValue.at(FrequestNode.FrequestNode_Motions);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 引数で指定したモーショングループのキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistMotionGroupName = function (groupName) {\n        var node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 引数で指定したモーションに対応するサウンドファイルのキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistMotionSoundFile = function (groupName, index) {\n        var node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(SoundPath);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 引数で指定したモーションに対応するフェードイン時間のキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistMotionFadeIn = function (groupName, index) {\n        var node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeInTime);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 引数で指定したモーションに対応するフェードアウト時間のキーが存在するかどうかを確認する\n     * @param groupName  グループ名\n     * @param index 配列のインデックス値\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistMotionFadeOut = function (groupName, index) {\n        var node = this._jsonValue\n            .at(FrequestNode.FrequestNode_Motions)\n            .getValueByString(groupName)\n            .getValueByIndex(index)\n            .getValueByString(FadeOutTime);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * UserDataのファイル名が存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistUserDataFile = function () {\n        var node = this._json\n            .getRoot()\n            .getValueByString(FileReferences)\n            .getValueByString(UserData);\n        return !node.isNull() && !node.isError();\n    };\n    /**\n     * 目ぱちに対応付けられたパラメータが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistEyeBlinkParameters = function () {\n        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() ||\n            this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {\n            return false;\n        }\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {\n            if (this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i)\n                .getValueByString(Name)\n                .getRawString() == EyeBlink) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * リップシンクに対応付けられたパラメータが存在するかどうかを確認する\n     * @return true キーが存在する\n     * @return false キーが存在しない\n     */\n    CubismModelSettingJson.prototype.isExistLipSyncParameters = function () {\n        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() ||\n            this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {\n            return false;\n        }\n        for (var i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {\n            if (this._jsonValue\n                .at(FrequestNode.FrequestNode_Groups)\n                .getValueByIndex(i)\n                .getValueByString(Name)\n                .getRawString() == LipSync) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return CubismModelSettingJson;\n}(_icubismmodelsetting__WEBPACK_IMPORTED_MODULE_0__.ICubismModelSetting));\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelSettingJson = _cubismmodelsettingjson__WEBPACK_IMPORTED_MODULE_4__.CubismModelSettingJson;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/cubismmodelsettingjson.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/effect/cubismbreath.ts":
/*!*********************************************************!*\
  !*** ./src/lib/live2d/Framework/effect/cubismbreath.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BreathParameterData\": () => (/* binding */ BreathParameterData),\n/* harmony export */   \"CubismBreath\": () => (/* binding */ CubismBreath),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismbreath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismbreath */ \"./src/lib/live2d/Framework/effect/cubismbreath.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 呼吸機能\n *\n * 呼吸機能を提供する。\n */\nvar CubismBreath = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismBreath() {\n        this._currentTime = 0.0;\n    }\n    /**\n     * インスタンスの作成\n     */\n    CubismBreath.create = function () {\n        return new CubismBreath();\n    };\n    /**\n     * インスタンスの破棄\n     * @param instance 対象のCubismBreath\n     */\n    CubismBreath.delete = function (instance) {\n        if (instance != null) {\n            instance = null;\n        }\n    };\n    /**\n     * 呼吸のパラメータの紐づけ\n     * @param breathParameters 呼吸を紐づけたいパラメータのリスト\n     */\n    CubismBreath.prototype.setParameters = function (breathParameters) {\n        this._breathParameters = breathParameters;\n    };\n    /**\n     * 呼吸に紐づいているパラメータの取得\n     * @return 呼吸に紐づいているパラメータのリスト\n     */\n    CubismBreath.prototype.getParameters = function () {\n        return this._breathParameters;\n    };\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    CubismBreath.prototype.updateParameters = function (model, deltaTimeSeconds) {\n        this._currentTime += deltaTimeSeconds;\n        var t = this._currentTime * 2.0 * 3.14159;\n        for (var i = 0; i < this._breathParameters.getSize(); ++i) {\n            var data = this._breathParameters.at(i);\n            model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t / data.cycle), data.weight);\n        }\n    };\n    return CubismBreath;\n}());\n\n/**\n * 呼吸のパラメータ情報\n */\nvar BreathParameterData = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param parameterId   呼吸をひもづけるパラメータID\n     * @param offset        呼吸を正弦波としたときの、波のオフセット\n     * @param peak          呼吸を正弦波としたときの、波の高さ\n     * @param cycle         呼吸を正弦波としたときの、波の周期\n     * @param weight        パラメータへの重み\n     */\n    function BreathParameterData(parameterId, offset, peak, cycle, weight) {\n        this.parameterId = parameterId == undefined ? null : parameterId;\n        this.offset = offset == undefined ? 0.0 : offset;\n        this.peak = peak == undefined ? 0.0 : peak;\n        this.cycle = cycle == undefined ? 0.0 : cycle;\n        this.weight = weight == undefined ? 0.0 : weight;\n    }\n    return BreathParameterData;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.BreathParameterData = _cubismbreath__WEBPACK_IMPORTED_MODULE_0__.BreathParameterData;\n    Live2DCubismFramework.CubismBreath = _cubismbreath__WEBPACK_IMPORTED_MODULE_0__.CubismBreath;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/effect/cubismbreath.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/effect/cubismeyeblink.ts":
/*!***********************************************************!*\
  !*** ./src/lib/live2d/Framework/effect/cubismeyeblink.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismEyeBlink\": () => (/* binding */ CubismEyeBlink),\n/* harmony export */   \"EyeState\": () => (/* binding */ EyeState),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismeyeblink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismeyeblink */ \"./src/lib/live2d/Framework/effect/cubismeyeblink.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * 自動まばたき機能\n *\n * 自動まばたき機能を提供する。\n */\nvar CubismEyeBlink = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param modelSetting モデルの設定情報\n     */\n    function CubismEyeBlink(modelSetting) {\n        this._blinkingState = EyeState.EyeState_First;\n        this._nextBlinkingTime = 0.0;\n        this._stateStartTimeSeconds = 0.0;\n        this._blinkingIntervalSeconds = 4.0;\n        this._closingSeconds = 0.1;\n        this._closedSeconds = 0.05;\n        this._openingSeconds = 0.15;\n        this._userTimeSeconds = 0.0;\n        this._parameterIds = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        if (modelSetting == null) {\n            return;\n        }\n        for (var i = 0; i < modelSetting.getEyeBlinkParameterCount(); ++i) {\n            this._parameterIds.pushBack(modelSetting.getEyeBlinkParameterId(i));\n        }\n    }\n    /**\n     * インスタンスを作成する\n     * @param modelSetting モデルの設定情報\n     * @return 作成されたインスタンス\n     * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。\n     */\n    CubismEyeBlink.create = function (modelSetting) {\n        if (modelSetting === void 0) { modelSetting = null; }\n        return new CubismEyeBlink(modelSetting);\n    };\n    /**\n     * インスタンスの破棄\n     * @param eyeBlink 対象のCubismEyeBlink\n     */\n    CubismEyeBlink.delete = function (eyeBlink) {\n        if (eyeBlink != null) {\n            eyeBlink = null;\n        }\n    };\n    /**\n     * まばたきの間隔の設定\n     * @param blinkingInterval まばたきの間隔の時間[秒]\n     */\n    CubismEyeBlink.prototype.setBlinkingInterval = function (blinkingInterval) {\n        this._blinkingIntervalSeconds = blinkingInterval;\n    };\n    /**\n     * まばたきのモーションの詳細設定\n     * @param closing   まぶたを閉じる動作の所要時間[秒]\n     * @param closed    まぶたを閉じている動作の所要時間[秒]\n     * @param opening   まぶたを開く動作の所要時間[秒]\n     */\n    CubismEyeBlink.prototype.setBlinkingSetting = function (closing, closed, opening) {\n        this._closingSeconds = closing;\n        this._closedSeconds = closed;\n        this._openingSeconds = opening;\n    };\n    /**\n     * まばたきさせるパラメータIDのリストの設定\n     * @param parameterIds パラメータのIDのリスト\n     */\n    CubismEyeBlink.prototype.setParameterIds = function (parameterIds) {\n        this._parameterIds = parameterIds;\n    };\n    /**\n     * まばたきさせるパラメータIDのリストの取得\n     * @return パラメータIDのリスト\n     */\n    CubismEyeBlink.prototype.getParameterIds = function () {\n        return this._parameterIds;\n    };\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    CubismEyeBlink.prototype.updateParameters = function (model, deltaTimeSeconds) {\n        this._userTimeSeconds += deltaTimeSeconds;\n        var parameterValue;\n        var t = 0.0;\n        switch (this._blinkingState) {\n            case EyeState.EyeState_Closing:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._closingSeconds;\n                if (t >= 1.0) {\n                    t = 1.0;\n                    this._blinkingState = EyeState.EyeState_Closed;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 1.0 - t;\n                break;\n            case EyeState.EyeState_Closed:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._closedSeconds;\n                if (t >= 1.0) {\n                    this._blinkingState = EyeState.EyeState_Opening;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 0.0;\n                break;\n            case EyeState.EyeState_Opening:\n                t =\n                    (this._userTimeSeconds - this._stateStartTimeSeconds) /\n                        this._openingSeconds;\n                if (t >= 1.0) {\n                    t = 1.0;\n                    this._blinkingState = EyeState.EyeState_Interval;\n                    this._nextBlinkingTime = this.determinNextBlinkingTiming();\n                }\n                parameterValue = t;\n                break;\n            case EyeState.EyeState_Interval:\n                if (this._nextBlinkingTime < this._userTimeSeconds) {\n                    this._blinkingState = EyeState.EyeState_Closing;\n                    this._stateStartTimeSeconds = this._userTimeSeconds;\n                }\n                parameterValue = 1.0;\n                break;\n            case EyeState.EyeState_First:\n            default:\n                this._blinkingState = EyeState.EyeState_Interval;\n                this._nextBlinkingTime = this.determinNextBlinkingTiming();\n                parameterValue = 1.0;\n                break;\n        }\n        if (!CubismEyeBlink.CloseIfZero) {\n            parameterValue = -parameterValue;\n        }\n        for (var i = 0; i < this._parameterIds.getSize(); ++i) {\n            model.setParameterValueById(this._parameterIds.at(i), parameterValue);\n        }\n    };\n    /**\n     * 次の瞬きのタイミングの決定\n     *\n     * @return 次のまばたきを行う時刻[秒]\n     */\n    CubismEyeBlink.prototype.determinNextBlinkingTiming = function () {\n        var r = Math.random();\n        return (this._userTimeSeconds + r * (2.0 * this._blinkingIntervalSeconds - 1.0));\n    };\n    /**\n     * IDで指定された目のパラメータが、0のときに閉じるなら true 、1の時に閉じるなら false 。\n     */\n    CubismEyeBlink.CloseIfZero = true;\n    return CubismEyeBlink;\n}());\n\n/**\n * まばたきの状態\n *\n * まばたきの状態を表す列挙型\n */\nvar EyeState;\n(function (EyeState) {\n    EyeState[EyeState[\"EyeState_First\"] = 0] = \"EyeState_First\";\n    EyeState[EyeState[\"EyeState_Interval\"] = 1] = \"EyeState_Interval\";\n    EyeState[EyeState[\"EyeState_Closing\"] = 2] = \"EyeState_Closing\";\n    EyeState[EyeState[\"EyeState_Closed\"] = 3] = \"EyeState_Closed\";\n    EyeState[EyeState[\"EyeState_Opening\"] = 4] = \"EyeState_Opening\";\n})(EyeState || (EyeState = {}));\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismEyeBlink = _cubismeyeblink__WEBPACK_IMPORTED_MODULE_1__.CubismEyeBlink;\n    Live2DCubismFramework.EyeState = _cubismeyeblink__WEBPACK_IMPORTED_MODULE_1__.EyeState;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/effect/cubismeyeblink.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/effect/cubismpose.ts":
/*!*******************************************************!*\
  !*** ./src/lib/live2d/Framework/effect/cubismpose.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismPose\": () => (/* binding */ CubismPose),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"PartData\": () => (/* binding */ PartData)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismpose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubismpose */ \"./src/lib/live2d/Framework/effect/cubismpose.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\nvar Epsilon = 0.001;\nvar DefaultFadeInSeconds = 0.5;\n// Pose.jsonのタグ\nvar FadeIn = 'FadeInTime';\nvar Link = 'Link';\nvar Groups = 'Groups';\nvar Id = 'Id';\n/**\n * パーツの不透明度の設定\n *\n * パーツの不透明度の管理と設定を行う。\n */\nvar CubismPose = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismPose() {\n        this._fadeTimeSeconds = DefaultFadeInSeconds;\n        this._lastModel = null;\n        this._partGroups = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        this._partGroupCounts = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n    }\n    /**\n     * インスタンスの作成\n     * @param pose3json pose3.jsonのデータ\n     * @param size pose3.jsonのデータのサイズ[byte]\n     * @return 作成されたインスタンス\n     */\n    CubismPose.create = function (pose3json, size) {\n        var ret = new CubismPose();\n        var json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson.create(pose3json, size);\n        var root = json.getRoot();\n        // フェード時間の指定\n        if (!root.getValueByString(FadeIn).isNull()) {\n            ret._fadeTimeSeconds = root\n                .getValueByString(FadeIn)\n                .toFloat(DefaultFadeInSeconds);\n            if (ret._fadeTimeSeconds <= 0.0) {\n                ret._fadeTimeSeconds = DefaultFadeInSeconds;\n            }\n        }\n        // パーツグループ\n        var poseListInfo = root.getValueByString(Groups);\n        var poseCount = poseListInfo.getSize();\n        for (var poseIndex = 0; poseIndex < poseCount; ++poseIndex) {\n            var idListInfo = poseListInfo.getValueByIndex(poseIndex);\n            var idCount = idListInfo.getSize();\n            var groupCount = 0;\n            for (var groupIndex = 0; groupIndex < idCount; ++groupIndex) {\n                var partInfo = idListInfo.getValueByIndex(groupIndex);\n                var partData = new PartData();\n                var parameterId = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(partInfo.getValueByString(Id).getRawString());\n                partData.partId = parameterId;\n                // リンクするパーツの設定\n                if (!partInfo.getValueByString(Link).isNull()) {\n                    var linkListInfo = partInfo.getValueByString(Link);\n                    var linkCount = linkListInfo.getSize();\n                    for (var linkIndex = 0; linkIndex < linkCount; ++linkIndex) {\n                        var linkPart = new PartData();\n                        var linkId = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(linkListInfo.getValueByIndex(linkIndex).getString());\n                        linkPart.partId = linkId;\n                        partData.link.pushBack(linkPart);\n                    }\n                }\n                ret._partGroups.pushBack(partData.clone());\n                ++groupCount;\n            }\n            ret._partGroupCounts.pushBack(groupCount);\n        }\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson[\"delete\"](json);\n        return ret;\n    };\n    /**\n     * インスタンスを破棄する\n     * @param pose 対象のCubismPose\n     */\n    CubismPose.delete = function (pose) {\n        if (pose != null) {\n            pose = null;\n        }\n    };\n    /**\n     * モデルのパラメータの更新\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    CubismPose.prototype.updateParameters = function (model, deltaTimeSeconds) {\n        // 前回のモデルと同じでない場合は初期化が必要\n        if (model != this._lastModel) {\n            // パラメータインデックスの初期化\n            this.reset(model);\n        }\n        this._lastModel = model;\n        // 設定から時間を変更すると、経過時間がマイナスになる事があるので、経過時間0として対応\n        if (deltaTimeSeconds < 0.0) {\n            deltaTimeSeconds = 0.0;\n        }\n        var beginIndex = 0;\n        for (var i = 0; i < this._partGroupCounts.getSize(); i++) {\n            var partGroupCount = this._partGroupCounts.at(i);\n            this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);\n            beginIndex += partGroupCount;\n        }\n        this.copyPartOpacities(model);\n    };\n    /**\n     * 表示を初期化\n     * @param model 対象のモデル\n     * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する\n     */\n    CubismPose.prototype.reset = function (model) {\n        var beginIndex = 0;\n        for (var i = 0; i < this._partGroupCounts.getSize(); ++i) {\n            var groupCount = this._partGroupCounts.at(i);\n            for (var j = beginIndex; j < beginIndex + groupCount; ++j) {\n                this._partGroups.at(j).initialize(model);\n                var partsIndex = this._partGroups.at(j).partIndex;\n                var paramIndex = this._partGroups.at(j).parameterIndex;\n                if (partsIndex < 0) {\n                    continue;\n                }\n                model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1.0 : 0.0);\n                model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1.0 : 0.0);\n                for (var k = 0; k < this._partGroups.at(j).link.getSize(); ++k) {\n                    this._partGroups.at(j).link.at(k).initialize(model);\n                }\n            }\n            beginIndex += groupCount;\n        }\n    };\n    /**\n     * パーツの不透明度をコピー\n     *\n     * @param model 対象のモデル\n     */\n    CubismPose.prototype.copyPartOpacities = function (model) {\n        for (var groupIndex = 0; groupIndex < this._partGroups.getSize(); ++groupIndex) {\n            var partData = this._partGroups.at(groupIndex);\n            if (partData.link.getSize() == 0) {\n                continue; // 連動するパラメータはない\n            }\n            var partIndex = this._partGroups.at(groupIndex).partIndex;\n            var opacity = model.getPartOpacityByIndex(partIndex);\n            for (var linkIndex = 0; linkIndex < partData.link.getSize(); ++linkIndex) {\n                var linkPart = partData.link.at(linkIndex);\n                var linkPartIndex = linkPart.partIndex;\n                if (linkPartIndex < 0) {\n                    continue;\n                }\n                model.setPartOpacityByIndex(linkPartIndex, opacity);\n            }\n        }\n    };\n    /**\n     * パーツのフェード操作を行う。\n     * @param model 対象のモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     * @param beginIndex フェード操作を行うパーツグループの先頭インデックス\n     * @param partGroupCount フェード操作を行うパーツグループの個数\n     */\n    CubismPose.prototype.doFade = function (model, deltaTimeSeconds, beginIndex, partGroupCount) {\n        var visiblePartIndex = -1;\n        var newOpacity = 1.0;\n        var phi = 0.5;\n        var backOpacityThreshold = 0.15;\n        // 現在、表示状態になっているパーツを取得\n        for (var i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n            var partIndex = this._partGroups.at(i).partIndex;\n            var paramIndex = this._partGroups.at(i).parameterIndex;\n            if (model.getParameterValueByIndex(paramIndex) > Epsilon) {\n                if (visiblePartIndex >= 0) {\n                    break;\n                }\n                visiblePartIndex = i;\n                newOpacity = model.getPartOpacityByIndex(partIndex);\n                // 新しい不透明度を計算\n                newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;\n                if (newOpacity > 1.0) {\n                    newOpacity = 1.0;\n                }\n            }\n        }\n        if (visiblePartIndex < 0) {\n            visiblePartIndex = 0;\n            newOpacity = 1.0;\n        }\n        // 表示パーツ、非表示パーツの不透明度を設定する\n        for (var i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n            var partsIndex = this._partGroups.at(i).partIndex;\n            // 表示パーツの設定\n            if (visiblePartIndex == i) {\n                model.setPartOpacityByIndex(partsIndex, newOpacity); // 先に設定\n            }\n            // 非表示パーツの設定\n            else {\n                var opacity = model.getPartOpacityByIndex(partsIndex);\n                var a1 = // 計算によって求められる不透明度\n                 void 0; // 計算によって求められる不透明度\n                if (newOpacity < phi) {\n                    a1 = (newOpacity * (phi - 1)) / phi + 1.0; // (0,1),(phi,phi)を通る直線式\n                }\n                else {\n                    a1 = ((1 - newOpacity) * phi) / (1.0 - phi); // (1,0),(phi,phi)を通る直線式\n                }\n                // 背景の見える割合を制限する場合\n                var backOpacity = (1.0 - a1) * (1.0 - newOpacity);\n                if (backOpacity > backOpacityThreshold) {\n                    a1 = 1.0 - backOpacityThreshold / (1.0 - newOpacity);\n                }\n                if (opacity > a1) {\n                    opacity = a1; // 計算の不透明度よりも大きければ（濃ければ）不透明度を上げる\n                }\n                model.setPartOpacityByIndex(partsIndex, opacity);\n            }\n        }\n    };\n    return CubismPose;\n}());\n\n/**\n * パーツにまつわるデータを管理\n */\nvar PartData = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function PartData(v) {\n        this.parameterIndex = 0;\n        this.partIndex = 0;\n        this.link = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        if (v != undefined) {\n            this.partId = v.partId;\n            for (var ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {\n                this.link.pushBack(ite.ptr().clone());\n            }\n        }\n    }\n    /**\n     * =演算子のオーバーロード\n     */\n    PartData.prototype.assignment = function (v) {\n        this.partId = v.partId;\n        for (var ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {\n            this.link.pushBack(ite.ptr().clone());\n        }\n        return this;\n    };\n    /**\n     * 初期化\n     * @param model 初期化に使用するモデル\n     */\n    PartData.prototype.initialize = function (model) {\n        this.parameterIndex = model.getParameterIndex(this.partId);\n        this.partIndex = model.getPartIndex(this.partId);\n        model.setParameterValueByIndex(this.parameterIndex, 1);\n    };\n    /**\n     * オブジェクトのコピーを生成する\n     */\n    PartData.prototype.clone = function () {\n        var clonePartData = new PartData();\n        clonePartData.partId = this.partId;\n        clonePartData.parameterIndex = this.parameterIndex;\n        clonePartData.partIndex = this.partIndex;\n        clonePartData.link = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        for (var ite = this.link.begin(); ite.notEqual(this.link.end()); ite.increment()) {\n            clonePartData.link.pushBack(ite.ptr().clone());\n        }\n        return clonePartData;\n    };\n    return PartData;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPose = _cubismpose__WEBPACK_IMPORTED_MODULE_3__.CubismPose;\n    Live2DCubismFramework.PartData = _cubismpose__WEBPACK_IMPORTED_MODULE_3__.PartData;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/effect/cubismpose.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/icubismmodelsetting.ts":
/*!*********************************************************!*\
  !*** ./src/lib/live2d/Framework/icubismmodelsetting.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ICubismModelSetting\": () => (/* binding */ ICubismModelSetting),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _icubismmodelsetting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icubismmodelsetting */ \"./src/lib/live2d/Framework/icubismmodelsetting.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * モデル設定情報を取り扱う関数を宣言した純粋仮想クラス。\n *\n * このクラスを継承することで、モデル設定情報を取り扱うクラスになる。\n */\nvar ICubismModelSetting = /** @class */ (function () {\n    function ICubismModelSetting() {\n    }\n    return ICubismModelSetting;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.ICubismModelSetting = _icubismmodelsetting__WEBPACK_IMPORTED_MODULE_0__.ICubismModelSetting;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/icubismmodelsetting.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/id/cubismid.ts":
/*!*************************************************!*\
  !*** ./src/lib/live2d/Framework/id/cubismid.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismId\": () => (/* binding */ CubismId),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _type_csmstring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../type/csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/* harmony import */ var _cubismid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismid */ \"./src/lib/live2d/Framework/id/cubismid.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * パラメータ名・パーツ名・Drawable名を保持\n *\n * パラメータ名・パーツ名・Drawable名を保持するクラス。\n */\nvar CubismId = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismId(id) {\n        if (typeof id === 'string') {\n            this._id = new _type_csmstring__WEBPACK_IMPORTED_MODULE_0__.csmString(id);\n            return;\n        }\n        this._id = id;\n    }\n    /**\n     * ID名を取得する\n     */\n    CubismId.prototype.getString = function () {\n        return this._id;\n    };\n    /**\n     * idを比較\n     * @param c 比較するid\n     * @return 同じならばtrue,異なっていればfalseを返す\n     */\n    CubismId.prototype.isEqual = function (c) {\n        if (typeof c === 'string') {\n            return this._id.isEqual(c);\n        }\n        else if (c instanceof _type_csmstring__WEBPACK_IMPORTED_MODULE_0__.csmString) {\n            return this._id.isEqual(c.s);\n        }\n        else if (c instanceof CubismId) {\n            return this._id.isEqual(c._id.s);\n        }\n        return false;\n    };\n    /**\n     * idを比較\n     * @param c 比較するid\n     * @return 同じならばtrue,異なっていればfalseを返す\n     */\n    CubismId.prototype.isNotEqual = function (c) {\n        if (typeof c == 'string') {\n            return !this._id.isEqual(c);\n        }\n        else if (c instanceof _type_csmstring__WEBPACK_IMPORTED_MODULE_0__.csmString) {\n            return !this._id.isEqual(c.s);\n        }\n        else if (c instanceof CubismId) {\n            return !this._id.isEqual(c._id.s);\n        }\n        return false;\n    };\n    return CubismId;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismId = _cubismid__WEBPACK_IMPORTED_MODULE_1__.CubismId;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/id/cubismid.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/id/cubismidmanager.ts":
/*!********************************************************!*\
  !*** ./src/lib/live2d/Framework/id/cubismidmanager.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismIdManager\": () => (/* binding */ CubismIdManager),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismid */ \"./src/lib/live2d/Framework/id/cubismid.ts\");\n/* harmony import */ var _cubismidmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismidmanager */ \"./src/lib/live2d/Framework/id/cubismidmanager.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n/**\n * ID名の管理\n *\n * ID名を管理する。\n */\nvar CubismIdManager = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismIdManager() {\n        this._ids = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismIdManager.prototype.release = function () {\n        for (var i = 0; i < this._ids.getSize(); ++i) {\n            this._ids.set(i, void 0);\n        }\n        this._ids = null;\n    };\n    /**\n     * ID名をリストから登録\n     *\n     * @param ids ID名リスト\n     * @param count IDの個数\n     */\n    CubismIdManager.prototype.registerIds = function (ids) {\n        for (var i = 0; i < ids.length; i++) {\n            this.registerId(ids[i]);\n        }\n    };\n    /**\n     * ID名を登録\n     *\n     * @param id ID名\n     */\n    CubismIdManager.prototype.registerId = function (id) {\n        var result = null;\n        if ('string' == typeof id) {\n            if ((result = this.findId(id)) != null) {\n                return result;\n            }\n            result = new _cubismid__WEBPACK_IMPORTED_MODULE_1__.CubismId(id);\n            this._ids.pushBack(result);\n        }\n        else {\n            return this.registerId(id.s);\n        }\n        return result;\n    };\n    /**\n     * ID名からIDを取得する\n     *\n     * @param id ID名\n     */\n    CubismIdManager.prototype.getId = function (id) {\n        return this.registerId(id);\n    };\n    /**\n     * ID名からIDの確認\n     *\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    CubismIdManager.prototype.isExist = function (id) {\n        if ('string' == typeof id) {\n            return this.findId(id) != null;\n        }\n        return this.isExist(id.s);\n    };\n    /**\n     * ID名からIDを検索する。\n     *\n     * @param id ID名\n     * @return 登録されているID。なければNULL。\n     */\n    CubismIdManager.prototype.findId = function (id) {\n        for (var i = 0; i < this._ids.getSize(); ++i) {\n            if (this._ids.at(i).getString().isEqual(id)) {\n                return this._ids.at(i);\n            }\n        }\n        return null;\n    };\n    return CubismIdManager;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismIdManager = _cubismidmanager__WEBPACK_IMPORTED_MODULE_2__.CubismIdManager;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/id/cubismidmanager.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/live2dcubismframework.ts":
/*!***********************************************************!*\
  !*** ./src/lib/live2d/Framework/live2dcubismframework.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Constant\": () => (/* binding */ Constant),\n/* harmony export */   \"CubismFramework\": () => (/* binding */ CubismFramework),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"LogLevel\": () => (/* binding */ LogLevel),\n/* harmony export */   \"Option\": () => (/* binding */ Option),\n/* harmony export */   \"csmDelete\": () => (/* binding */ csmDelete),\n/* harmony export */   \"strtod\": () => (/* binding */ strtod)\n/* harmony export */ });\n/* harmony import */ var _id_cubismidmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id/cubismidmanager */ \"./src/lib/live2d/Framework/id/cubismidmanager.ts\");\n/* harmony import */ var _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rendering/cubismrenderer */ \"./src/lib/live2d/Framework/rendering/cubismrenderer.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n\nfunction strtod(s, endPtr) {\n    var index = 0;\n    for (var i = 1;; i++) {\n        var testC = s.slice(i - 1, i);\n        // 指数・マイナスの可能性があるのでスキップする\n        if (testC == 'e' || testC == '-' || testC == 'E') {\n            continue;\n        } // 文字列の範囲を広げていく\n        var test = s.substring(0, i);\n        var number = Number(test);\n        if (isNaN(number)) {\n            // 数値として認識できなくなったので終了\n            break;\n        } // 最後に数値としてできたindexを格納しておく\n        index = i;\n    }\n    var d = parseFloat(s); // パースした数値\n    if (isNaN(d)) {\n        // 数値として認識できなくなったので終了\n        d = NaN;\n    }\n    endPtr[0] = s.slice(index); // 後続の文字列\n    return d;\n}\n// ファイルスコープの変数を初期化\nvar s_isStarted = false;\nvar s_isInitialized = false;\nvar s_option = null;\nvar s_cubismIdManager = null;\n/**\n * Framework内で使う定数の宣言\n */\nvar Constant = Object.freeze({\n    vertexOffset: 0,\n    vertexStep: 2, // メッシュ頂点のステップ値\n});\nfunction csmDelete(address) {\n    if (!address) {\n        return;\n    }\n    address = void 0;\n}\n/**\n * Live2D Cubism SDK Original Workflow SDKのエントリポイント\n * 利用開始時はCubismFramework.initialize()を呼び、CubismFramework.dispose()で終了する。\n */\nvar CubismFramework = /** @class */ (function () {\n    /**\n     * 静的クラスとして使用する\n     * インスタンス化させない\n     */\n    function CubismFramework() {\n    }\n    /**\n     * Cubism FrameworkのAPIを使用可能にする。\n     *  APIを実行する前に必ずこの関数を実行すること。\n     *  一度準備が完了して以降は、再び実行しても内部処理がスキップされます。\n     *\n     * @param    option      Optionクラスのインスタンス\n     *\n     * @return   準備処理が完了したらtrueが返ります。\n     */\n    CubismFramework.startUp = function (option) {\n        if (option === void 0) { option = null; }\n        if (s_isStarted) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogInfo)('CubismFramework.startUp() is already done.');\n            return s_isStarted;\n        }\n        s_option = option;\n        if (s_option != null) {\n            Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);\n        }\n        s_isStarted = true;\n        // Live2D Cubism Coreバージョン情報を表示\n        if (s_isStarted) {\n            var version = Live2DCubismCore.Version.csmGetVersion();\n            var major = (version & 0xff000000) >> 24;\n            var minor = (version & 0x00ff0000) >> 16;\n            var patch = version & 0x0000ffff;\n            var versionNumber = version;\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogInfo)(\"Live2D Cubism Core version: {0}.{1}.{2} ({3})\", ('00' + major).slice(-2), ('00' + minor).slice(-2), ('0000' + patch).slice(-4), versionNumber);\n        }\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogInfo)('CubismFramework.startUp() is complete.');\n        return s_isStarted;\n    };\n    /**\n     * StartUp()で初期化したCubismFrameworkの各パラメータをクリアします。\n     * Dispose()したCubismFrameworkを再利用する際に利用してください。\n     */\n    CubismFramework.cleanUp = function () {\n        s_isStarted = false;\n        s_isInitialized = false;\n        s_option = null;\n        s_cubismIdManager = null;\n    };\n    /**\n     * Cubism Framework内のリソースを初期化してモデルを表示可能な状態にします。<br>\n     *     再度Initialize()するには先にDispose()を実行する必要があります。\n     */\n    CubismFramework.initialize = function () {\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CSM_ASSERT)(s_isStarted);\n        if (!s_isStarted) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogWarning)('CubismFramework is not started.');\n            return;\n        }\n        // --- s_isInitializedによる連続初期化ガード ---\n        // 連続してリソース確保が行われないようにする。\n        // 再度Initialize()するには先にDispose()を実行する必要がある。\n        if (s_isInitialized) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogWarning)('CubismFramework.initialize() skipped, already initialized.');\n            return;\n        }\n        //---- static 初期化 ----\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__.Value.staticInitializeNotForClientCall();\n        s_cubismIdManager = new _id_cubismidmanager__WEBPACK_IMPORTED_MODULE_0__.CubismIdManager();\n        s_isInitialized = true;\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogInfo)('CubismFramework.initialize() is complete.');\n    };\n    /**\n     * Cubism Framework内の全てのリソースを解放します。\n     *      ただし、外部で確保されたリソースについては解放しません。\n     *      外部で適切に破棄する必要があります。\n     */\n    CubismFramework.dispose = function () {\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CSM_ASSERT)(s_isStarted);\n        if (!s_isStarted) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogWarning)('CubismFramework is not started.');\n            return;\n        }\n        // --- s_isInitializedによる未初期化解放ガード ---\n        // dispose()するには先にinitialize()を実行する必要がある。\n        if (!s_isInitialized) {\n            // false...リソース未確保の場合\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogWarning)('CubismFramework.dispose() skipped, not initialized.');\n            return;\n        }\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_3__.Value.staticReleaseNotForClientCall();\n        s_cubismIdManager.release();\n        s_cubismIdManager = null;\n        // レンダラの静的リソース（シェーダプログラム他）を解放する\n        _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismRenderer.staticRelease();\n        s_isInitialized = false;\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismLogInfo)('CubismFramework.dispose() is complete.');\n    };\n    /**\n     * Cubism FrameworkのAPIを使用する準備が完了したかどうか\n     * @return APIを使用する準備が完了していればtrueが返ります。\n     */\n    CubismFramework.isStarted = function () {\n        return s_isStarted;\n    };\n    /**\n     * Cubism Frameworkのリソース初期化がすでに行われているかどうか\n     * @return リソース確保が完了していればtrueが返ります\n     */\n    CubismFramework.isInitialized = function () {\n        return s_isInitialized;\n    };\n    /**\n     * Core APIにバインドしたログ関数を実行する\n     *\n     * @praram message ログメッセージ\n     */\n    CubismFramework.coreLogFunction = function (message) {\n        // Return if logging not possible.\n        if (!Live2DCubismCore.Logging.csmGetLogFunction()) {\n            return;\n        }\n        Live2DCubismCore.Logging.csmGetLogFunction()(message);\n    };\n    /**\n     * 現在のログ出力レベル設定の値を返す。\n     *\n     * @return  現在のログ出力レベル設定の値\n     */\n    CubismFramework.getLoggingLevel = function () {\n        if (s_option != null) {\n            return s_option.loggingLevel;\n        }\n        return LogLevel.LogLevel_Off;\n    };\n    /**\n     * IDマネージャのインスタンスを取得する\n     * @return CubismManagerクラスのインスタンス\n     */\n    CubismFramework.getIdManager = function () {\n        return s_cubismIdManager;\n    };\n    return CubismFramework;\n}());\n\nvar Option = /** @class */ (function () {\n    function Option() {\n    }\n    return Option;\n}());\n\n/**\n * ログ出力のレベル\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"LogLevel_Verbose\"] = 0] = \"LogLevel_Verbose\";\n    LogLevel[LogLevel[\"LogLevel_Debug\"] = 1] = \"LogLevel_Debug\";\n    LogLevel[LogLevel[\"LogLevel_Info\"] = 2] = \"LogLevel_Info\";\n    LogLevel[LogLevel[\"LogLevel_Warning\"] = 3] = \"LogLevel_Warning\";\n    LogLevel[LogLevel[\"LogLevel_Error\"] = 4] = \"LogLevel_Error\";\n    LogLevel[LogLevel[\"LogLevel_Off\"] = 5] = \"LogLevel_Off\";\n})(LogLevel || (LogLevel = {}));\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.Constant = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_4__.Constant;\n    Live2DCubismFramework.csmDelete = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_4__.csmDelete;\n    Live2DCubismFramework.CubismFramework = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_4__.CubismFramework;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/live2dcubismframework.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/CubismMatrix44.ts":
/*!*********************************************************!*\
  !*** ./src/lib/live2d/Framework/math/CubismMatrix44.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMatrix44\": () => (/* binding */ CubismMatrix44),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmatrix44 */ \"./src/lib/live2d/Framework/math/cubismmatrix44.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 4x4の行列\n *\n * 4x4行列の便利クラス。\n */\nvar CubismMatrix44 = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMatrix44() {\n        this._tr = new Float32Array(16); // 4 * 4のサイズ\n        this.loadIdentity();\n    }\n    /**\n     * 受け取った２つの行列の乗算を行う。\n     *\n     * @param a 行列a\n     * @param b 行列b\n     * @return 乗算結果の行列\n     */\n    CubismMatrix44.multiply = function (a, b, dst) {\n        var c = new Float32Array([\n            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n            0.0,\n        ]);\n        var n = 4;\n        for (var i = 0; i < n; ++i) {\n            for (var j = 0; j < n; ++j) {\n                for (var k = 0; k < n; ++k) {\n                    c[j + i * 4] += a[k + i * 4] * b[j + k * 4];\n                }\n            }\n        }\n        for (var i = 0; i < 16; ++i) {\n            dst[i] = c[i];\n        }\n    };\n    /**\n     * 単位行列に初期化する\n     */\n    CubismMatrix44.prototype.loadIdentity = function () {\n        var c = new Float32Array([\n            1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,\n            1.0,\n        ]);\n        this.setMatrix(c);\n    };\n    /**\n     * 行列を設定\n     *\n     * @param tr 16個の浮動小数点数で表される4x4の行列\n     */\n    CubismMatrix44.prototype.setMatrix = function (tr) {\n        for (var i = 0; i < 16; ++i) {\n            this._tr[i] = tr[i];\n        }\n    };\n    /**\n     * 行列を浮動小数点数の配列で取得\n     *\n     * @return 16個の浮動小数点数で表される4x4の行列\n     */\n    CubismMatrix44.prototype.getArray = function () {\n        return this._tr;\n    };\n    /**\n     * X軸の拡大率を取得\n     * @return X軸の拡大率\n     */\n    CubismMatrix44.prototype.getScaleX = function () {\n        return this._tr[0];\n    };\n    /**\n     * Y軸の拡大率を取得する\n     *\n     * @return Y軸の拡大率\n     */\n    CubismMatrix44.prototype.getScaleY = function () {\n        return this._tr[5];\n    };\n    /**\n     * X軸の移動量を取得\n     * @return X軸の移動量\n     */\n    CubismMatrix44.prototype.getTranslateX = function () {\n        return this._tr[12];\n    };\n    /**\n     * Y軸の移動量を取得\n     * @return Y軸の移動量\n     */\n    CubismMatrix44.prototype.getTranslateY = function () {\n        return this._tr[13];\n    };\n    /**\n     * X軸の値を現在の行列で計算\n     *\n     * @param src X軸の値\n     * @return 現在の行列で計算されたX軸の値\n     */\n    CubismMatrix44.prototype.transformX = function (src) {\n        return this._tr[0] * src + this._tr[12];\n    };\n    /**\n     * Y軸の値を現在の行列で計算\n     *\n     * @param src Y軸の値\n     * @return 現在の行列で計算されたY軸の値\n     */\n    CubismMatrix44.prototype.transformY = function (src) {\n        return this._tr[5] * src + this._tr[13];\n    };\n    /**\n     * X軸の値を現在の行列で逆計算\n     */\n    CubismMatrix44.prototype.invertTransformX = function (src) {\n        return (src - this._tr[12]) / this._tr[0];\n    };\n    /**\n     * Y軸の値を現在の行列で逆計算\n     */\n    CubismMatrix44.prototype.invertTransformY = function (src) {\n        return (src - this._tr[13]) / this._tr[5];\n    };\n    /**\n     * 現在の行列の位置を起点にして移動\n     *\n     * 現在の行列の位置を起点にして相対的に移動する。\n     *\n     * @param x X軸の移動量\n     * @param y Y軸の移動量\n     */\n    CubismMatrix44.prototype.translateRelative = function (x, y) {\n        var tr1 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            x,\n            y,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    };\n    /**\n     * 現在の行列の位置を移動\n     *\n     * 現在の行列の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     * @param y y軸の移動量\n     */\n    CubismMatrix44.prototype.translate = function (x, y) {\n        this._tr[12] = x;\n        this._tr[13] = y;\n    };\n    /**\n     * 現在の行列のX軸の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     */\n    CubismMatrix44.prototype.translateX = function (x) {\n        this._tr[12] = x;\n    };\n    /**\n     * 現在の行列のY軸の位置を指定した位置へ移動する\n     *\n     * @param y Y軸の移動量\n     */\n    CubismMatrix44.prototype.translateY = function (y) {\n        this._tr[13] = y;\n    };\n    /**\n     * 現在の行列の拡大率を相対的に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    CubismMatrix44.prototype.scaleRelative = function (x, y) {\n        var tr1 = new Float32Array([\n            x,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            y,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    };\n    /**\n     * 現在の行列の拡大率を指定した倍率に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    CubismMatrix44.prototype.scale = function (x, y) {\n        this._tr[0] = x;\n        this._tr[5] = y;\n    };\n    /**\n     * 現在の行列に行列を乗算\n     *\n     * @param m 行列\n     */\n    CubismMatrix44.prototype.multiplyByMatrix = function (m) {\n        CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);\n    };\n    /**\n     * オブジェクトのコピーを生成する\n     */\n    CubismMatrix44.prototype.clone = function () {\n        var cloneMatrix = new CubismMatrix44();\n        for (var i = 0; i < this._tr.length; i++) {\n            cloneMatrix._tr[i] = this._tr[i];\n        }\n        return cloneMatrix;\n    };\n    return CubismMatrix44;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMatrix44 = _cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__.CubismMatrix44;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/CubismMatrix44.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/cubismmath.ts":
/*!*****************************************************!*\
  !*** ./src/lib/live2d/Framework/math/cubismmath.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMath\": () => (/* binding */ CubismMath),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismvector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismvector2 */ \"./src/lib/live2d/Framework/math/cubismvector2.ts\");\n/* harmony import */ var _cubismmath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmath */ \"./src/lib/live2d/Framework/math/cubismmath.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * 数値計算などに使用するユーティリティクラス\n */\nvar CubismMath = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMath() {\n    }\n    /**\n     * 第一引数の値を最小値と最大値の範囲に収めた値を返す\n     *\n     * @param value 収められる値\n     * @param min   範囲の最小値\n     * @param max   範囲の最大値\n     * @return 最小値と最大値の範囲に収めた値\n     */\n    CubismMath.range = function (value, min, max) {\n        if (value < min) {\n            value = min;\n        }\n        else if (value > max) {\n            value = max;\n        }\n        return value;\n    };\n    /**\n     * サイン関数の値を求める\n     *\n     * @param x 角度値（ラジアン）\n     * @return サイン関数sin(x)の値\n     */\n    CubismMath.sin = function (x) {\n        return Math.sin(x);\n    };\n    /**\n     * コサイン関数の値を求める\n     *\n     * @param x 角度値(ラジアン)\n     * @return コサイン関数cos(x)の値\n     */\n    CubismMath.cos = function (x) {\n        return Math.cos(x);\n    };\n    /**\n     * 値の絶対値を求める\n     *\n     * @param x 絶対値を求める値\n     * @return 値の絶対値\n     */\n    CubismMath.abs = function (x) {\n        return Math.abs(x);\n    };\n    /**\n     * 平方根(ルート)を求める\n     * @param x -> 平方根を求める値\n     * @return 値の平方根\n     */\n    CubismMath.sqrt = function (x) {\n        return Math.sqrt(x);\n    };\n    /**\n     * 立方根を求める\n     * @param x -> 立方根を求める値\n     * @return 値の立方根\n     */\n    CubismMath.cbrt = function (x) {\n        if (x === 0) {\n            return x;\n        }\n        var cx = x;\n        var isNegativeNumber = cx < 0;\n        if (isNegativeNumber) {\n            cx = -cx;\n        }\n        var ret;\n        if (cx === Infinity) {\n            ret = Infinity;\n        }\n        else {\n            ret = Math.exp(Math.log(cx) / 3);\n            ret = (cx / (ret * ret) + 2 * ret) / 3;\n        }\n        return isNegativeNumber ? -ret : ret;\n    };\n    /**\n     * イージング処理されたサインを求める\n     * フェードイン・アウト時のイージングに利用できる\n     *\n     * @param value イージングを行う値\n     * @return イージング処理されたサイン値\n     */\n    CubismMath.getEasingSine = function (value) {\n        if (value < 0.0) {\n            return 0.0;\n        }\n        else if (value > 1.0) {\n            return 1.0;\n        }\n        return 0.5 - 0.5 * this.cos(value * Math.PI);\n    };\n    /**\n     * 大きい方の値を返す\n     *\n     * @param left 左辺の値\n     * @param right 右辺の値\n     * @return 大きい方の値\n     */\n    CubismMath.max = function (left, right) {\n        return left > right ? left : right;\n    };\n    /**\n     * 小さい方の値を返す\n     *\n     * @param left  左辺の値\n     * @param right 右辺の値\n     * @return 小さい方の値\n     */\n    CubismMath.min = function (left, right) {\n        return left > right ? right : left;\n    };\n    /**\n     * 角度値をラジアン値に変換する\n     *\n     * @param degrees   角度値\n     * @return 角度値から変換したラジアン値\n     */\n    CubismMath.degreesToRadian = function (degrees) {\n        return (degrees / 180.0) * Math.PI;\n    };\n    /**\n     * ラジアン値を角度値に変換する\n     *\n     * @param radian    ラジアン値\n     * @return ラジアン値から変換した角度値\n     */\n    CubismMath.radianToDegrees = function (radian) {\n        return (radian * 180.0) / Math.PI;\n    };\n    /**\n     * ２つのベクトルからラジアン値を求める\n     *\n     * @param from  始点ベクトル\n     * @param to    終点ベクトル\n     * @return ラジアン値から求めた方向ベクトル\n     */\n    CubismMath.directionToRadian = function (from, to) {\n        var q1 = Math.atan2(to.y, to.x);\n        var q2 = Math.atan2(from.y, from.x);\n        var ret = q1 - q2;\n        while (ret < -Math.PI) {\n            ret += Math.PI * 2.0;\n        }\n        while (ret > Math.PI) {\n            ret -= Math.PI * 2.0;\n        }\n        return ret;\n    };\n    /**\n     * ２つのベクトルから角度値を求める\n     *\n     * @param from  始点ベクトル\n     * @param to    終点ベクトル\n     * @return 角度値から求めた方向ベクトル\n     */\n    CubismMath.directionToDegrees = function (from, to) {\n        var radian = this.directionToRadian(from, to);\n        var degree = this.radianToDegrees(radian);\n        if (to.x - from.x > 0.0) {\n            degree = -degree;\n        }\n        return degree;\n    };\n    /**\n     * ラジアン値を方向ベクトルに変換する。\n     *\n     * @param totalAngle    ラジアン値\n     * @return ラジアン値から変換した方向ベクトル\n     */\n    CubismMath.radianToDirection = function (totalAngle) {\n        var ret = new _cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2();\n        ret.x = this.sin(totalAngle);\n        ret.y = this.cos(totalAngle);\n        return ret;\n    };\n    /**\n     * 三次方程式の三次項の係数が0になったときに補欠的に二次方程式の解をもとめる。\n     * a * x^2 + b * x + c = 0\n     *\n     * @param   a -> 二次項の係数値\n     * @param   b -> 一次項の係数値\n     * @param   c -> 定数項の値\n     * @return  二次方程式の解\n     */\n    CubismMath.quadraticEquation = function (a, b, c) {\n        if (this.abs(a) < CubismMath.Epsilon) {\n            if (this.abs(b) < CubismMath.Epsilon) {\n                return -c;\n            }\n            return -c / b;\n        }\n        return -(b + this.sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n    };\n    /**\n     * カルダノの公式によってベジェのt値に該当する３次方程式の解を求める。\n     * 重解になったときには0.0～1.0の値になる解を返す。\n     *\n     * a * x^3 + b * x^2 + c * x + d = 0\n     *\n     * @param   a -> 三次項の係数値\n     * @param   b -> 二次項の係数値\n     * @param   c -> 一次項の係数値\n     * @param   d -> 定数項の値\n     * @return  0.0～1.0の間にある解\n     */\n    CubismMath.cardanoAlgorithmForBezier = function (a, b, c, d) {\n        if (this.sqrt(a) < CubismMath.Epsilon) {\n            return this.range(this.quadraticEquation(b, c, d), 0.0, 1.0);\n        }\n        var ba = b / a;\n        var ca = c / a;\n        var da = d / a;\n        var p = (3.0 * ca - ba * ba) / 3.0;\n        var p3 = p / 3.0;\n        var q = (2.0 * ba * ba * ba - 9.0 * ba * ca + 27.0 * da) / 27.0;\n        var q2 = q / 2.0;\n        var discriminant = q2 * q2 + p3 * p3 * p3;\n        var center = 0.5;\n        var threshold = center + 0.01;\n        if (discriminant < 0.0) {\n            var mp3 = -p / 3.0;\n            var mp33 = mp3 * mp3 * mp3;\n            var r = this.sqrt(mp33);\n            var t = -q / (2.0 * r);\n            var cosphi = this.range(t, -1.0, 1.0);\n            var phi = Math.acos(cosphi);\n            var crtr = this.cbrt(r);\n            var t1 = 2.0 * crtr;\n            var root1_1 = t1 * this.cos(phi / 3.0) - ba / 3.0;\n            if (this.abs(root1_1 - center) < threshold) {\n                return this.range(root1_1, 0.0, 1.0);\n            }\n            var root2 = t1 * this.cos((phi + 2.0 * Math.PI) / 3.0) - ba / 3.0;\n            if (this.abs(root2 - center) < threshold) {\n                return this.range(root2, 0.0, 1.0);\n            }\n            var root3 = t1 * this.cos((phi + 4.0 * Math.PI) / 3.0) - ba / 3.0;\n            return this.range(root3, 0.0, 1.0);\n        }\n        if (discriminant == 0.0) {\n            var u1_1;\n            if (q2 < 0.0) {\n                u1_1 = this.cbrt(-q2);\n            }\n            else {\n                u1_1 = -this.cbrt(q2);\n            }\n            var root1_2 = 2.0 * u1_1 - ba / 3.0;\n            if (this.abs(root1_2 - center) < threshold) {\n                return this.range(root1_2, 0.0, 1.0);\n            }\n            var root2 = -u1_1 - ba / 3.0;\n            return this.range(root2, 0.0, 1.0);\n        }\n        var sd = this.sqrt(discriminant);\n        var u1 = this.cbrt(sd - q2);\n        var v1 = this.cbrt(sd + q2);\n        var root1 = u1 - v1 - ba / 3.0;\n        return this.range(root1, 0.0, 1.0);\n    };\n    CubismMath.Epsilon = 0.00001;\n    return CubismMath;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMath = _cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/cubismmath.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/cubismmatrix44.ts":
/*!*********************************************************!*\
  !*** ./src/lib/live2d/Framework/math/cubismmatrix44.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMatrix44\": () => (/* binding */ CubismMatrix44),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmatrix44 */ \"./src/lib/live2d/Framework/math/cubismmatrix44.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 4x4の行列\n *\n * 4x4行列の便利クラス。\n */\nvar CubismMatrix44 = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMatrix44() {\n        this._tr = new Float32Array(16); // 4 * 4のサイズ\n        this.loadIdentity();\n    }\n    /**\n     * 受け取った２つの行列の乗算を行う。\n     *\n     * @param a 行列a\n     * @param b 行列b\n     * @return 乗算結果の行列\n     */\n    CubismMatrix44.multiply = function (a, b, dst) {\n        var c = new Float32Array([\n            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n            0.0,\n        ]);\n        var n = 4;\n        for (var i = 0; i < n; ++i) {\n            for (var j = 0; j < n; ++j) {\n                for (var k = 0; k < n; ++k) {\n                    c[j + i * 4] += a[k + i * 4] * b[j + k * 4];\n                }\n            }\n        }\n        for (var i = 0; i < 16; ++i) {\n            dst[i] = c[i];\n        }\n    };\n    /**\n     * 単位行列に初期化する\n     */\n    CubismMatrix44.prototype.loadIdentity = function () {\n        var c = new Float32Array([\n            1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,\n            1.0,\n        ]);\n        this.setMatrix(c);\n    };\n    /**\n     * 行列を設定\n     *\n     * @param tr 16個の浮動小数点数で表される4x4の行列\n     */\n    CubismMatrix44.prototype.setMatrix = function (tr) {\n        for (var i = 0; i < 16; ++i) {\n            this._tr[i] = tr[i];\n        }\n    };\n    /**\n     * 行列を浮動小数点数の配列で取得\n     *\n     * @return 16個の浮動小数点数で表される4x4の行列\n     */\n    CubismMatrix44.prototype.getArray = function () {\n        return this._tr;\n    };\n    /**\n     * X軸の拡大率を取得\n     * @return X軸の拡大率\n     */\n    CubismMatrix44.prototype.getScaleX = function () {\n        return this._tr[0];\n    };\n    /**\n     * Y軸の拡大率を取得する\n     *\n     * @return Y軸の拡大率\n     */\n    CubismMatrix44.prototype.getScaleY = function () {\n        return this._tr[5];\n    };\n    /**\n     * X軸の移動量を取得\n     * @return X軸の移動量\n     */\n    CubismMatrix44.prototype.getTranslateX = function () {\n        return this._tr[12];\n    };\n    /**\n     * Y軸の移動量を取得\n     * @return Y軸の移動量\n     */\n    CubismMatrix44.prototype.getTranslateY = function () {\n        return this._tr[13];\n    };\n    /**\n     * X軸の値を現在の行列で計算\n     *\n     * @param src X軸の値\n     * @return 現在の行列で計算されたX軸の値\n     */\n    CubismMatrix44.prototype.transformX = function (src) {\n        return this._tr[0] * src + this._tr[12];\n    };\n    /**\n     * Y軸の値を現在の行列で計算\n     *\n     * @param src Y軸の値\n     * @return 現在の行列で計算されたY軸の値\n     */\n    CubismMatrix44.prototype.transformY = function (src) {\n        return this._tr[5] * src + this._tr[13];\n    };\n    /**\n     * X軸の値を現在の行列で逆計算\n     */\n    CubismMatrix44.prototype.invertTransformX = function (src) {\n        return (src - this._tr[12]) / this._tr[0];\n    };\n    /**\n     * Y軸の値を現在の行列で逆計算\n     */\n    CubismMatrix44.prototype.invertTransformY = function (src) {\n        return (src - this._tr[13]) / this._tr[5];\n    };\n    /**\n     * 現在の行列の位置を起点にして移動\n     *\n     * 現在の行列の位置を起点にして相対的に移動する。\n     *\n     * @param x X軸の移動量\n     * @param y Y軸の移動量\n     */\n    CubismMatrix44.prototype.translateRelative = function (x, y) {\n        var tr1 = new Float32Array([\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            x,\n            y,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    };\n    /**\n     * 現在の行列の位置を移動\n     *\n     * 現在の行列の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     * @param y y軸の移動量\n     */\n    CubismMatrix44.prototype.translate = function (x, y) {\n        this._tr[12] = x;\n        this._tr[13] = y;\n    };\n    /**\n     * 現在の行列のX軸の位置を指定した位置へ移動する\n     *\n     * @param x X軸の移動量\n     */\n    CubismMatrix44.prototype.translateX = function (x) {\n        this._tr[12] = x;\n    };\n    /**\n     * 現在の行列のY軸の位置を指定した位置へ移動する\n     *\n     * @param y Y軸の移動量\n     */\n    CubismMatrix44.prototype.translateY = function (y) {\n        this._tr[13] = y;\n    };\n    /**\n     * 現在の行列の拡大率を相対的に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    CubismMatrix44.prototype.scaleRelative = function (x, y) {\n        var tr1 = new Float32Array([\n            x,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            y,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n        ]);\n        CubismMatrix44.multiply(tr1, this._tr, this._tr);\n    };\n    /**\n     * 現在の行列の拡大率を指定した倍率に設定する\n     *\n     * @param x X軸の拡大率\n     * @param y Y軸の拡大率\n     */\n    CubismMatrix44.prototype.scale = function (x, y) {\n        this._tr[0] = x;\n        this._tr[5] = y;\n    };\n    /**\n     * 現在の行列に行列を乗算\n     *\n     * @param m 行列\n     */\n    CubismMatrix44.prototype.multiplyByMatrix = function (m) {\n        CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);\n    };\n    /**\n     * オブジェクトのコピーを生成する\n     */\n    CubismMatrix44.prototype.clone = function () {\n        var cloneMatrix = new CubismMatrix44();\n        for (var i = 0; i < this._tr.length; i++) {\n            cloneMatrix._tr[i] = this._tr[i];\n        }\n        return cloneMatrix;\n    };\n    return CubismMatrix44;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMatrix44 = _cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__.CubismMatrix44;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/cubismmatrix44.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/cubismmodelmatrix.ts":
/*!************************************************************!*\
  !*** ./src/lib/live2d/Framework/math/cubismmodelmatrix.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismModelMatrix\": () => (/* binding */ CubismModelMatrix),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmatrix44 */ \"./src/lib/live2d/Framework/math/cubismmatrix44.ts\");\n/* harmony import */ var _cubismmodelmatrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmodelmatrix */ \"./src/lib/live2d/Framework/math/cubismmodelmatrix.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * モデル座標設定用の4x4行列\n *\n * モデル座標設定用の4x4行列クラス\n */\nvar CubismModelMatrix = /** @class */ (function (_super) {\n    __extends(CubismModelMatrix, _super);\n    /**\n     * コンストラクタ\n     *\n     * @param w 横幅\n     * @param h 縦幅\n     */\n    function CubismModelMatrix(w, h) {\n        var _this = _super.call(this) || this;\n        _this._width = w !== undefined ? w : 0.0;\n        _this._height = h !== undefined ? h : 0.0;\n        _this.setHeight(2.0);\n        return _this;\n    }\n    /**\n     * 横幅を設定\n     *\n     * @param w 横幅\n     */\n    CubismModelMatrix.prototype.setWidth = function (w) {\n        var scaleX = w / this._width;\n        var scaleY = scaleX;\n        this.scale(scaleX, scaleY);\n    };\n    /**\n     * 縦幅を設定\n     * @param h 縦幅\n     */\n    CubismModelMatrix.prototype.setHeight = function (h) {\n        var scaleX = h / this._height;\n        var scaleY = scaleX;\n        this.scale(scaleX, scaleY);\n    };\n    /**\n     * 位置を設定\n     *\n     * @param x X軸の位置\n     * @param y Y軸の位置\n     */\n    CubismModelMatrix.prototype.setPosition = function (x, y) {\n        this.translate(x, y);\n    };\n    /**\n     * 中心位置を設定\n     *\n     * @param x X軸の中心位置\n     * @param y Y軸の中心位置\n     *\n     * @note widthかheightを設定したあとでないと、拡大率が正しく取得できないためずれる。\n     */\n    CubismModelMatrix.prototype.setCenterPosition = function (x, y) {\n        this.centerX(x);\n        this.centerY(y);\n    };\n    /**\n     * 上辺の位置を設定する\n     *\n     * @param y 上辺のY軸位置\n     */\n    CubismModelMatrix.prototype.top = function (y) {\n        this.setY(y);\n    };\n    /**\n     * 下辺の位置を設定する\n     *\n     * @param y 下辺のY軸位置\n     */\n    CubismModelMatrix.prototype.bottom = function (y) {\n        var h = this._height * this.getScaleY();\n        this.translateY(y - h);\n    };\n    /**\n     * 左辺の位置を設定\n     *\n     * @param x 左辺のX軸位置\n     */\n    CubismModelMatrix.prototype.left = function (x) {\n        this.setX(x);\n    };\n    /**\n     * 右辺の位置を設定\n     *\n     * @param x 右辺のX軸位置\n     */\n    CubismModelMatrix.prototype.right = function (x) {\n        var w = this._width * this.getScaleX();\n        this.translateX(x - w);\n    };\n    /**\n     * X軸の中心位置を設定\n     *\n     * @param x X軸の中心位置\n     */\n    CubismModelMatrix.prototype.centerX = function (x) {\n        var w = this._width * this.getScaleX();\n        this.translateX(x - w / 2.0);\n    };\n    /**\n     * X軸の位置を設定\n     *\n     * @param x X軸の位置\n     */\n    CubismModelMatrix.prototype.setX = function (x) {\n        this.translateX(x);\n    };\n    /**\n     * Y軸の中心位置を設定\n     *\n     * @param y Y軸の中心位置\n     */\n    CubismModelMatrix.prototype.centerY = function (y) {\n        var h = this._height * this.getScaleY();\n        this.translateY(y - h / 2.0);\n    };\n    /**\n     * Y軸の位置を設定する\n     *\n     * @param y Y軸の位置\n     */\n    CubismModelMatrix.prototype.setY = function (y) {\n        this.translateY(y);\n    };\n    /**\n     * レイアウト情報から位置を設定\n     *\n     * @param layout レイアウト情報\n     */\n    CubismModelMatrix.prototype.setupFromLayout = function (layout) {\n        var keyWidth = 'width';\n        var keyHeight = 'height';\n        var keyX = 'x';\n        var keyY = 'y';\n        var keyCenterX = 'center_x';\n        var keyCenterY = 'center_y';\n        var keyTop = 'top';\n        var keyBottom = 'bottom';\n        var keyLeft = 'left';\n        var keyRight = 'right';\n        for (var ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {\n            var key = ite.ptr().first;\n            var value = ite.ptr().second;\n            if (key == keyWidth) {\n                this.setWidth(value);\n            }\n            else if (key == keyHeight) {\n                this.setHeight(value);\n            }\n        }\n        for (var ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {\n            var key = ite.ptr().first;\n            var value = ite.ptr().second;\n            if (key == keyX) {\n                this.setX(value);\n            }\n            else if (key == keyY) {\n                this.setY(value);\n            }\n            else if (key == keyCenterX) {\n                this.centerX(value);\n            }\n            else if (key == keyCenterY) {\n                this.centerY(value);\n            }\n            else if (key == keyTop) {\n                this.top(value);\n            }\n            else if (key == keyBottom) {\n                this.bottom(value);\n            }\n            else if (key == keyLeft) {\n                this.left(value);\n            }\n            else if (key == keyRight) {\n                this.right(value);\n            }\n        }\n    };\n    return CubismModelMatrix;\n}(_cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__.CubismMatrix44));\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelMatrix = _cubismmodelmatrix__WEBPACK_IMPORTED_MODULE_1__.CubismModelMatrix;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/cubismmodelmatrix.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/cubismtargetpoint.ts":
/*!************************************************************!*\
  !*** ./src/lib/live2d/Framework/math/cubismtargetpoint.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismTargetPoint\": () => (/* binding */ CubismTargetPoint),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmath */ \"./src/lib/live2d/Framework/math/cubismmath.ts\");\n/* harmony import */ var _cubismtargetpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismtargetpoint */ \"./src/lib/live2d/Framework/math/cubismtargetpoint.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\nvar FrameRate = 30;\nvar Epsilon = 0.01;\n/**\n * 顔の向きの制御機能\n *\n * 顔の向きの制御機能を提供するクラス。\n */\nvar CubismTargetPoint = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismTargetPoint() {\n        this._faceTargetX = 0.0;\n        this._faceTargetY = 0.0;\n        this._faceX = 0.0;\n        this._faceY = 0.0;\n        this._faceVX = 0.0;\n        this._faceVY = 0.0;\n        this._lastTimeSeconds = 0.0;\n        this._userTimeSeconds = 0.0;\n    }\n    /**\n     * 更新処理\n     */\n    CubismTargetPoint.prototype.update = function (deltaTimeSeconds) {\n        // デルタ時間を加算する\n        this._userTimeSeconds += deltaTimeSeconds;\n        // 首を中央から左右に振るときの平均的な速さは 秒速度。加速・減速を考慮して、その２倍を最高速度とする\n        // 顔の振り具合を、中央（0.0）から、左右は（+-1.0）とする\n        var faceParamMaxV = 40.0 / 10.0; // 7.5秒間に40分移動(5.3/sc)\n        var maxV = (faceParamMaxV * 1.0) / FrameRate; // 1frameあたりに変化できる速度の上限\n        if (this._lastTimeSeconds == 0.0) {\n            this._lastTimeSeconds = this._userTimeSeconds;\n            return;\n        }\n        var deltaTimeWeight = (this._userTimeSeconds - this._lastTimeSeconds) * FrameRate;\n        this._lastTimeSeconds = this._userTimeSeconds;\n        // 最高速度になるまでの時間を\n        var timeToMaxSpeed = 0.15;\n        var frameToMaxSpeed = timeToMaxSpeed * FrameRate; // sec * frame/sec\n        var maxA = (deltaTimeWeight * maxV) / frameToMaxSpeed; // 1frameあたりの加速度\n        // 目指す向きは、（dx, dy）方向のベクトルとなる\n        var dx = this._faceTargetX - this._faceX;\n        var dy = this._faceTargetY - this._faceY;\n        if (_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.abs(dx) <= Epsilon && _cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.abs(dy) <= Epsilon) {\n            return; // 変化なし\n        }\n        // 速度の最大よりも大きい場合は、速度を落とす\n        var d = _cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sqrt(dx * dx + dy * dy);\n        // 進行方向の最大速度ベクトル\n        var vx = (maxV * dx) / d;\n        var vy = (maxV * dy) / d;\n        // 現在の速度から、新規速度への変化（加速度）を求める\n        var ax = vx - this._faceVX;\n        var ay = vy - this._faceVY;\n        var a = _cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sqrt(ax * ax + ay * ay);\n        // 加速のとき\n        if (a < -maxA || a > maxA) {\n            ax *= maxA / a;\n            ay *= maxA / a;\n        }\n        // 加速度を元の速度に足して、新速度とする\n        this._faceVX += ax;\n        this._faceVY += ay;\n        // 目的の方向に近づいたとき、滑らかに減速するための処理\n        // 設定された加速度で止まる事の出来る距離と速度の関係から\n        // 現在とりうる最高速度を計算し、それ以上の時は速度を落とす\n        // ※本来、人間は筋力で力（加速度）を調整できるため、より自由度が高いが、簡単な処理で済ませている\n        {\n            // 加速度、速度、距離の関係式。\n            //            2  6           2               3\n            //      sqrt(a  t  + 16 a h t  - 8 a h) - a t\n            // v = --------------------------------------\n            //                    2\n            //                 4 t  - 2\n            // (t=1)\n            // \t時刻tは、あらかじめ加速度、速度を1/60(フレームレート、単位なし)で\n            // \t考えているので、t＝１として消してよい（※未検証）\n            var maxV_1 = 0.5 *\n                (_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sqrt(maxA * maxA + 16.0 * maxA * d - 8.0 * maxA * d) -\n                    maxA);\n            var curV = _cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sqrt(this._faceVX * this._faceVX + this._faceVY * this._faceVY);\n            if (curV > maxV_1) {\n                // 現在の速度 > 最高速度のとき、最高速度まで減速\n                this._faceVX *= maxV_1 / curV;\n                this._faceVY *= maxV_1 / curV;\n            }\n        }\n        this._faceX += this._faceVX;\n        this._faceY += this._faceVY;\n    };\n    /**\n     * X軸の顔の向きの値を取得\n     *\n     * @return X軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    CubismTargetPoint.prototype.getX = function () {\n        return this._faceX;\n    };\n    /**\n     * Y軸の顔の向きの値を取得\n     *\n     * @return Y軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    CubismTargetPoint.prototype.getY = function () {\n        return this._faceY;\n    };\n    /**\n     * 顔の向きの目標値を設定\n     *\n     * @param x X軸の顔の向きの値（-1.0 ~ 1.0）\n     * @param y Y軸の顔の向きの値（-1.0 ~ 1.0）\n     */\n    CubismTargetPoint.prototype.set = function (x, y) {\n        this._faceTargetX = x;\n        this._faceTargetY = y;\n    };\n    return CubismTargetPoint;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismTargetPoint = _cubismtargetpoint__WEBPACK_IMPORTED_MODULE_1__.CubismTargetPoint;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/cubismtargetpoint.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/math/cubismvector2.ts":
/*!********************************************************!*\
  !*** ./src/lib/live2d/Framework/math/cubismvector2.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismVector2\": () => (/* binding */ CubismVector2),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismvector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismvector2 */ \"./src/lib/live2d/Framework/math/cubismvector2.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 2次元ベクトル型\n *\n * 2次元ベクトル型の機能を提供する。\n */\nvar CubismVector2 = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismVector2(x, y) {\n        this.x = x;\n        this.y = y;\n        this.x = x == undefined ? 0.0 : x;\n        this.y = y == undefined ? 0.0 : y;\n    }\n    /**\n     * ベクトルの加算\n     *\n     * @param vector2 加算するベクトル値\n     * @return 加算結果 ベクトル値\n     */\n    CubismVector2.prototype.add = function (vector2) {\n        var ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x + vector2.x;\n        ret.y = this.y + vector2.y;\n        return ret;\n    };\n    /**\n     * ベクトルの減算\n     *\n     * @param vector2 減算するベクトル値\n     * @return 減算結果 ベクトル値\n     */\n    CubismVector2.prototype.substract = function (vector2) {\n        var ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x - vector2.x;\n        ret.y = this.y - vector2.y;\n        return ret;\n    };\n    /**\n     * ベクトルの乗算\n     *\n     * @param vector2 乗算するベクトル値\n     * @return 乗算結果 ベクトル値\n     */\n    CubismVector2.prototype.multiply = function (vector2) {\n        var ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x * vector2.x;\n        ret.y = this.y * vector2.y;\n        return ret;\n    };\n    /**\n     * ベクトルの乗算(スカラー)\n     *\n     * @param scalar 乗算するスカラー値\n     * @return 乗算結果 ベクトル値\n     */\n    CubismVector2.prototype.multiplyByScaler = function (scalar) {\n        return this.multiply(new CubismVector2(scalar, scalar));\n    };\n    /**\n     * ベクトルの除算\n     *\n     * @param vector2 除算するベクトル値\n     * @return 除算結果 ベクトル値\n     */\n    CubismVector2.prototype.division = function (vector2) {\n        var ret = new CubismVector2(0.0, 0.0);\n        ret.x = this.x / vector2.x;\n        ret.y = this.y / vector2.y;\n        return ret;\n    };\n    /**\n     * ベクトルの除算(スカラー)\n     *\n     * @param scalar 除算するスカラー値\n     * @return 除算結果 ベクトル値\n     */\n    CubismVector2.prototype.divisionByScalar = function (scalar) {\n        return this.division(new CubismVector2(scalar, scalar));\n    };\n    /**\n     * ベクトルの長さを取得する\n     *\n     * @return ベクトルの長さ\n     */\n    CubismVector2.prototype.getLength = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    };\n    /**\n     * ベクトルの距離の取得\n     *\n     * @param a 点\n     * @return ベクトルの距離\n     */\n    CubismVector2.prototype.getDistanceWith = function (a) {\n        return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));\n    };\n    /**\n     * ドット積の計算\n     *\n     * @param a 値\n     * @return 結果\n     */\n    CubismVector2.prototype.dot = function (a) {\n        return this.x * a.x + this.y * a.y;\n    };\n    /**\n     * 正規化の適用\n     */\n    CubismVector2.prototype.normalize = function () {\n        var length = Math.pow(this.x * this.x + this.y * this.y, 0.5);\n        this.x = this.x / length;\n        this.y = this.y / length;\n    };\n    /**\n     * 等しさの確認（等しいか？）\n     *\n     * 値が等しいか？\n     *\n     * @param rhs 確認する値\n     * @return true 値は等しい\n     * @return false 値は等しくない\n     */\n    CubismVector2.prototype.isEqual = function (rhs) {\n        return this.x == rhs.x && this.y == rhs.y;\n    };\n    /**\n     * 等しさの確認（等しくないか？）\n     *\n     * 値が等しくないか？\n     *\n     * @param rhs 確認する値\n     * @return true 値は等しくない\n     * @return false 値は等しい\n     */\n    CubismVector2.prototype.isNotEqual = function (rhs) {\n        return !this.isEqual(rhs);\n    };\n    return CubismVector2;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismVector2 = _cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/math/cubismvector2.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/model/cubismmoc.ts":
/*!*****************************************************!*\
  !*** ./src/lib/live2d/Framework/model/cubismmoc.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMoc\": () => (/* binding */ CubismMoc),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _cubismmodel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmodel */ \"./src/lib/live2d/Framework/model/cubismmodel.ts\");\n/* harmony import */ var _cubismmoc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismmoc */ \"./src/lib/live2d/Framework/model/cubismmoc.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n/**\n * Mocデータの管理\n *\n * Mocデータの管理を行うクラス。\n */\nvar CubismMoc = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMoc(moc) {\n        this._moc = moc;\n        this._modelCount = 0;\n        this._mocVersion = 0;\n    }\n    /**\n     * Mocデータの作成\n     */\n    CubismMoc.create = function (mocBytes) {\n        var cubismMoc = null;\n        var moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);\n        if (moc) {\n            cubismMoc = new CubismMoc(moc);\n            cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(moc, mocBytes);\n        }\n        return cubismMoc;\n    };\n    /**\n     * Mocデータを削除\n     *\n     * Mocデータを削除する\n     */\n    CubismMoc.delete = function (moc) {\n        moc._moc._release();\n        moc._moc = null;\n        moc = null;\n    };\n    /**\n     * モデルを作成する\n     *\n     * @return Mocデータから作成されたモデル\n     */\n    CubismMoc.prototype.createModel = function () {\n        var cubismModel = null;\n        var model = Live2DCubismCore.Model.fromMoc(this._moc);\n        if (model) {\n            cubismModel = new _cubismmodel__WEBPACK_IMPORTED_MODULE_1__.CubismModel(model);\n            cubismModel.initialize();\n            ++this._modelCount;\n        }\n        return cubismModel;\n    };\n    /**\n     * モデルを削除する\n     */\n    CubismMoc.prototype.deleteModel = function (model) {\n        if (model != null) {\n            model.release();\n            model = null;\n            --this._modelCount;\n        }\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismMoc.prototype.release = function () {\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_0__.CSM_ASSERT)(this._modelCount == 0);\n        this._moc._release();\n        this._moc = null;\n    };\n    /**\n     * 最新の.moc3 Versionを取得\n     */\n    CubismMoc.prototype.getLatestMocVersion = function () {\n        return Live2DCubismCore.Version.csmGetLatestMocVersion();\n    };\n    /**\n     * 読み込んだモデルの.moc3 Versionを取得\n     */\n    CubismMoc.prototype.getMocVersion = function () {\n        return this._mocVersion;\n    };\n    return CubismMoc;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMoc = _cubismmoc__WEBPACK_IMPORTED_MODULE_2__.CubismMoc;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/model/cubismmoc.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/model/cubismmodel.ts":
/*!*******************************************************!*\
  !*** ./src/lib/live2d/Framework/model/cubismmodel.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismModel\": () => (/* binding */ CubismModel),\n/* harmony export */   \"DrawableColorData\": () => (/* binding */ DrawableColorData),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/cubismrenderer */ \"./src/lib/live2d/Framework/rendering/cubismrenderer.ts\");\n/* harmony import */ var _type_csmmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmmap */ \"./src/lib/live2d/Framework/type/csmmap.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _cubismmodel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cubismmodel */ \"./src/lib/live2d/Framework/model/cubismmodel.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n\n\n/**\n * SDK側から与えられたDrawableの乗算色・スクリーン色上書きフラグと\n * その色を保持する構造体\n */\nvar DrawableColorData = /** @class */ (function () {\n    function DrawableColorData() {\n        this.isOverwritten = false;\n        this.Color = new _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismTextureColor();\n    }\n    return DrawableColorData;\n}());\n\n/**\n * モデル\n *\n * Mocデータから生成されるモデルのクラス。\n */\nvar CubismModel = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param model モデル\n     */\n    function CubismModel(model) {\n        this._model = model;\n        this._parameterValues = null;\n        this._parameterMaximumValues = null;\n        this._parameterMinimumValues = null;\n        this._partOpacities = null;\n        this._savedParameters = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n        this._parameterIds = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n        this._drawableIds = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n        this._partIds = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n        this._isOverwrittenModelMultiplyColors = false;\n        this._isOverwrittenModelScreenColors = false;\n        this._userMultiplyColors = null;\n        this._userScreenColors = null;\n        this._notExistPartId = new _type_csmmap__WEBPACK_IMPORTED_MODULE_2__.csmMap();\n        this._notExistParameterId = new _type_csmmap__WEBPACK_IMPORTED_MODULE_2__.csmMap();\n        this._notExistParameterValues = new _type_csmmap__WEBPACK_IMPORTED_MODULE_2__.csmMap();\n        this._notExistPartOpacities = new _type_csmmap__WEBPACK_IMPORTED_MODULE_2__.csmMap();\n    }\n    /**\n     * モデルのパラメータの更新\n     */\n    CubismModel.prototype.update = function () {\n        // Update model\n        this._model.update();\n        this._model.drawables.resetDynamicFlags();\n    };\n    /**\n     * キャンバスの幅を取得する\n     */\n    CubismModel.prototype.getCanvasWidth = function () {\n        if (this._model == null) {\n            return 0.0;\n        }\n        return (this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit);\n    };\n    /**\n     * キャンバスの高さを取得する\n     */\n    CubismModel.prototype.getCanvasHeight = function () {\n        if (this._model == null) {\n            return 0.0;\n        }\n        return (this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit);\n    };\n    /**\n     * パラメータを保存する\n     */\n    CubismModel.prototype.saveParameters = function () {\n        var parameterCount = this._model.parameters.count;\n        var savedParameterCount = this._savedParameters.getSize();\n        for (var i = 0; i < parameterCount; ++i) {\n            if (i < savedParameterCount) {\n                this._savedParameters.set(i, this._parameterValues[i]);\n            }\n            else {\n                this._savedParameters.pushBack(this._parameterValues[i]);\n            }\n        }\n    };\n    /**\n     * 乗算色を取得する\n     * @param index Drawablesのインデックス\n     * @returns 指定したdrawableの乗算色(RGBA)\n     */\n    CubismModel.prototype.getMultiplyColor = function (index) {\n        // Drawableとモデル全体の乗算色上書きフラグがどちらもtrueな場合、モデル全体の上書きフラグが優先される\n        if (this.getOverwriteFlagForModelMultiplyColors() ||\n            this.getOverwriteFlagForDrawableMultiplyColors(index)) {\n            return this._userMultiplyColors.at(index).Color;\n        }\n        var color = this.getDrawableMultiplyColor(index);\n        return color;\n    };\n    /**\n     * スクリーン色を取得する\n     * @param index Drawablesのインデックス\n     * @returns 指定したdrawableのスクリーン色(RGBA)\n     */\n    CubismModel.prototype.getScreenColor = function (index) {\n        // Drawableとモデル全体のスクリーン色上書きフラグがどちらもtrueな場合、モデル全体の上書きフラグが優先される\n        if (this.getOverwriteFlagForModelScreenColors() ||\n            this.getOverwriteFlagForDrawableScreenColors(index)) {\n            return this._userScreenColors.at(index).Color;\n        }\n        var color = this.getDrawableScreenColor(index);\n        return color;\n    };\n    /**\n     * 乗算色をセットする\n     * @param index Drawablesのインデックス\n     * @param color 設定する乗算色(CubismTextureColor)\n     */\n    CubismModel.prototype.setMultiplyColorByTextureColor = function (index, color) {\n        this.setMultiplyColorByRGBA(index, color.R, color.G, color.B, color.A);\n    };\n    /**\n     * 乗算色をセットする\n     * @param index Drawablesのインデックス\n     * @param r 設定する乗算色のR値\n     * @param g 設定する乗算色のG値\n     * @param b 設定する乗算色のB値\n     * @param a 設定する乗算色のA値\n     */\n    CubismModel.prototype.setMultiplyColorByRGBA = function (index, r, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        this._userMultiplyColors.at(index).Color.R = r;\n        this._userMultiplyColors.at(index).Color.G = g;\n        this._userMultiplyColors.at(index).Color.B = b;\n        this._userMultiplyColors.at(index).Color.A = a;\n    };\n    /**\n     * スクリーン色をセットする\n     * @param index Drawablesのインデックス\n     * @param color 設定するスクリーン色(CubismTextureColor)\n     */\n    CubismModel.prototype.setScreenColorByTextureColor = function (index, color) {\n        this.setScreenColorByRGBA(index, color.R, color.G, color.B, color.A);\n    };\n    /**\n     * スクリーン色をセットする\n     * @param index Drawablesのインデックス\n     * @param r 設定するスクリーン色のR値\n     * @param g 設定するスクリーン色のG値\n     * @param b 設定するスクリーン色のB値\n     * @param a 設定するスクリーン色のA値\n     */\n    CubismModel.prototype.setScreenColorByRGBA = function (index, r, g, b, a) {\n        if (a === void 0) { a = 1.0; }\n        this._userScreenColors.at(index).Color.R = r;\n        this._userScreenColors.at(index).Color.G = g;\n        this._userScreenColors.at(index).Color.B = b;\n        this._userScreenColors.at(index).Color.A = a;\n    };\n    /**\n     * SDKから指定したモデルの乗算色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.getOverwriteFlagForModelMultiplyColors = function () {\n        return this._isOverwrittenModelMultiplyColors;\n    };\n    /**\n     * SDKから指定したモデルのスクリーン色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.getOverwriteFlagForModelScreenColors = function () {\n        return this._isOverwrittenModelScreenColors;\n    };\n    /**\n     * SDKから指定したモデルの乗算色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.setOverwriteFlagForModelMultiplyColors = function (value) {\n        this._isOverwrittenModelMultiplyColors = value;\n    };\n    /**\n     * SDKから指定したモデルのスクリーン色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.setOverwriteFlagForModelScreenColors = function (value) {\n        this._isOverwrittenModelScreenColors = value;\n    };\n    /**\n     * SDKから指定したDrawableIndexの乗算色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.getOverwriteFlagForDrawableMultiplyColors = function (drawableindex) {\n        return this._userMultiplyColors.at(drawableindex).isOverwritten;\n    };\n    /**\n     * SDKから指定したDrawableIndexのスクリーン色を上書きするか\n     * @returns true -> SDKからの情報を優先する\n     *          false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.getOverwriteFlagForDrawableScreenColors = function (drawableindex) {\n        return this._userMultiplyColors.at(drawableindex).isOverwritten;\n    };\n    /**\n     * SDKから指定したDrawableIndexの乗算色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.setOverwriteFlagForDrawableMultiplyColors = function (drawableindex, value) {\n        this._userMultiplyColors.at(drawableindex).isOverwritten = value;\n    };\n    /**\n     * SDKから指定したDrawableIndexのスクリーン色を上書きするかセットする\n     * @param value true -> SDKからの情報を優先する\n     *              false -> モデルに設定されている色情報を使用\n     */\n    CubismModel.prototype.setOverwriteFlagForDrawableScreenColors = function (drawableindex, value) {\n        this._userScreenColors.at(drawableindex).isOverwritten = value;\n    };\n    /**\n     * モデルを取得\n     */\n    CubismModel.prototype.getModel = function () {\n        return this._model;\n    };\n    /**\n     * パーツのインデックスを取得\n     * @param partId パーツのID\n     * @return パーツのインデックス\n     */\n    CubismModel.prototype.getPartIndex = function (partId) {\n        var partIndex;\n        var partCount = this._model.parts.count;\n        for (partIndex = 0; partIndex < partCount; ++partIndex) {\n            if (partId == this._partIds.at(partIndex)) {\n                return partIndex;\n            }\n        }\n        // モデルに存在していない場合、非存在パーツIDリスト内にあるかを検索し、そのインデックスを返す\n        if (this._notExistPartId.isExist(partId)) {\n            return this._notExistPartId.getValue(partId);\n        }\n        // 非存在パーツIDリストにない場合、新しく要素を追加する\n        partIndex = partCount + this._notExistPartId.getSize();\n        this._notExistPartId.setValue(partId, partIndex);\n        this._notExistPartOpacities.appendKey(partIndex);\n        return partIndex;\n    };\n    /**\n     * パーツの個数の取得\n     * @return パーツの個数\n     */\n    CubismModel.prototype.getPartCount = function () {\n        var partCount = this._model.parts.count;\n        return partCount;\n    };\n    /**\n     * パーツの不透明度の設定(Index)\n     * @param partIndex パーツのインデックス\n     * @param opacity 不透明度\n     */\n    CubismModel.prototype.setPartOpacityByIndex = function (partIndex, opacity) {\n        if (this._notExistPartOpacities.isExist(partIndex)) {\n            this._notExistPartOpacities.setValue(partIndex, opacity);\n            return;\n        }\n        // インデックスの範囲内検知\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CSM_ASSERT)(0 <= partIndex && partIndex < this.getPartCount());\n        this._partOpacities[partIndex] = opacity;\n    };\n    /**\n     * パーツの不透明度の設定(Id)\n     * @param partId パーツのID\n     * @param opacity パーツの不透明度\n     */\n    CubismModel.prototype.setPartOpacityById = function (partId, opacity) {\n        // 高速化のためにPartIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        var index = this.getPartIndex(partId);\n        if (index < 0) {\n            return; // パーツがないのでスキップ\n        }\n        this.setPartOpacityByIndex(index, opacity);\n    };\n    /**\n     * パーツの不透明度の取得(index)\n     * @param partIndex パーツのインデックス\n     * @return パーツの不透明度\n     */\n    CubismModel.prototype.getPartOpacityByIndex = function (partIndex) {\n        if (this._notExistPartOpacities.isExist(partIndex)) {\n            // モデルに存在しないパーツIDの場合、非存在パーツリストから不透明度を返す。\n            return this._notExistPartOpacities.getValue(partIndex);\n        }\n        // インデックスの範囲内検知\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CSM_ASSERT)(0 <= partIndex && partIndex < this.getPartCount());\n        return this._partOpacities[partIndex];\n    };\n    /**\n     * パーツの不透明度の取得(id)\n     * @param partId パーツのＩｄ\n     * @return パーツの不透明度\n     */\n    CubismModel.prototype.getPartOpacityById = function (partId) {\n        // 高速化のためにPartIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        var index = this.getPartIndex(partId);\n        if (index < 0) {\n            return 0; // パーツが無いのでスキップ\n        }\n        return this.getPartOpacityByIndex(index);\n    };\n    /**\n     * パラメータのインデックスの取得\n     * @param パラメータID\n     * @return パラメータのインデックス\n     */\n    CubismModel.prototype.getParameterIndex = function (parameterId) {\n        var parameterIndex;\n        var idCount = this._model.parameters.count;\n        for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {\n            if (parameterId != this._parameterIds.at(parameterIndex)) {\n                continue;\n            }\n            return parameterIndex;\n        }\n        // モデルに存在していない場合、非存在パラメータIDリスト内を検索し、そのインデックスを返す\n        if (this._notExistParameterId.isExist(parameterId)) {\n            return this._notExistParameterId.getValue(parameterId);\n        }\n        // 非存在パラメータIDリストにない場合新しく要素を追加する\n        parameterIndex =\n            this._model.parameters.count + this._notExistParameterId.getSize();\n        this._notExistParameterId.setValue(parameterId, parameterIndex);\n        this._notExistParameterValues.appendKey(parameterIndex);\n        return parameterIndex;\n    };\n    /**\n     * パラメータの個数の取得\n     * @return パラメータの個数\n     */\n    CubismModel.prototype.getParameterCount = function () {\n        return this._model.parameters.count;\n    };\n    /**\n     * パラメータの種類の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return csmParameterType_Normal -> 通常のパラメータ\n     *          csmParameterType_BlendShape -> ブレンドシェイプパラメータ\n     */\n    CubismModel.prototype.getParameterType = function (parameterIndex) {\n        return this._model.parameters.types[parameterIndex];\n    };\n    /**\n     * パラメータの最大値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータの最大値\n     */\n    CubismModel.prototype.getParameterMaximumValue = function (parameterIndex) {\n        return this._model.parameters.maximumValues[parameterIndex];\n    };\n    /**\n     * パラメータの最小値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータの最小値\n     */\n    CubismModel.prototype.getParameterMinimumValue = function (parameterIndex) {\n        return this._model.parameters.minimumValues[parameterIndex];\n    };\n    /**\n     * パラメータのデフォルト値の取得\n     * @param parameterIndex パラメータのインデックス\n     * @return パラメータのデフォルト値\n     */\n    CubismModel.prototype.getParameterDefaultValue = function (parameterIndex) {\n        return this._model.parameters.defaultValues[parameterIndex];\n    };\n    /**\n     * パラメータの値の取得\n     * @param parameterIndex    パラメータのインデックス\n     * @return パラメータの値\n     */\n    CubismModel.prototype.getParameterValueByIndex = function (parameterIndex) {\n        if (this._notExistParameterValues.isExist(parameterIndex)) {\n            return this._notExistParameterValues.getValue(parameterIndex);\n        }\n        // インデックスの範囲内検知\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CSM_ASSERT)(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n        return this._parameterValues[parameterIndex];\n    };\n    /**\n     * パラメータの値の取得\n     * @param parameterId    パラメータのID\n     * @return パラメータの値\n     */\n    CubismModel.prototype.getParameterValueById = function (parameterId) {\n        // 高速化のためにparameterIndexを取得できる機構になっているが、外部からの設定の時は呼び出し頻度が低いため不要\n        var parameterIndex = this.getParameterIndex(parameterId);\n        return this.getParameterValueByIndex(parameterIndex);\n    };\n    /**\n     * パラメータの値の設定\n     * @param parameterIndex パラメータのインデックス\n     * @param value パラメータの値\n     * @param weight 重み\n     */\n    CubismModel.prototype.setParameterValueByIndex = function (parameterIndex, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        if (this._notExistParameterValues.isExist(parameterIndex)) {\n            this._notExistParameterValues.setValue(parameterIndex, weight == 1\n                ? value\n                : this._notExistParameterValues.getValue(parameterIndex) *\n                    (1 - weight) +\n                    value * weight);\n            return;\n        }\n        // インデックスの範囲内検知\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CSM_ASSERT)(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n        if (this._model.parameters.maximumValues[parameterIndex] < value) {\n            value = this._model.parameters.maximumValues[parameterIndex];\n        }\n        if (this._model.parameters.minimumValues[parameterIndex] > value) {\n            value = this._model.parameters.minimumValues[parameterIndex];\n        }\n        this._parameterValues[parameterIndex] =\n            weight == 1\n                ? value\n                : (this._parameterValues[parameterIndex] =\n                    this._parameterValues[parameterIndex] * (1 - weight) +\n                        value * weight);\n    };\n    /**\n     * パラメータの値の設定\n     * @param parameterId パラメータのID\n     * @param value パラメータの値\n     * @param weight 重み\n     */\n    CubismModel.prototype.setParameterValueById = function (parameterId, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        var index = this.getParameterIndex(parameterId);\n        this.setParameterValueByIndex(index, value, weight);\n    };\n    /**\n     * パラメータの値の加算(index)\n     * @param parameterIndex パラメータインデックス\n     * @param value 加算する値\n     * @param weight 重み\n     */\n    CubismModel.prototype.addParameterValueByIndex = function (parameterIndex, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);\n    };\n    /**\n     * パラメータの値の加算(id)\n     * @param parameterId パラメータＩＤ\n     * @param value 加算する値\n     * @param weight 重み\n     */\n    CubismModel.prototype.addParameterValueById = function (parameterId, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        var index = this.getParameterIndex(parameterId);\n        this.addParameterValueByIndex(index, value, weight);\n    };\n    /**\n     * パラメータの値の乗算\n     * @param parameterId パラメータのID\n     * @param value 乗算する値\n     * @param weight 重み\n     */\n    CubismModel.prototype.multiplyParameterValueById = function (parameterId, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        var index = this.getParameterIndex(parameterId);\n        this.multiplyParameterValueByIndex(index, value, weight);\n    };\n    /**\n     * パラメータの値の乗算\n     * @param parameterIndex パラメータのインデックス\n     * @param value 乗算する値\n     * @param weight 重み\n     */\n    CubismModel.prototype.multiplyParameterValueByIndex = function (parameterIndex, value, weight) {\n        if (weight === void 0) { weight = 1.0; }\n        this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) *\n            (1.0 + (value - 1.0) * weight));\n    };\n    /**\n     * Drawableのインデックスの取得\n     * @param drawableId DrawableのID\n     * @return Drawableのインデックス\n     */\n    CubismModel.prototype.getDrawableIndex = function (drawableId) {\n        var drawableCount = this._model.drawables.count;\n        for (var drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {\n            if (this._drawableIds.at(drawableIndex) == drawableId) {\n                return drawableIndex;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Drawableの個数の取得\n     * @return drawableの個数\n     */\n    CubismModel.prototype.getDrawableCount = function () {\n        var drawableCount = this._model.drawables.count;\n        return drawableCount;\n    };\n    /**\n     * DrawableのIDを取得する\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのID\n     */\n    CubismModel.prototype.getDrawableId = function (drawableIndex) {\n        var parameterIds = this._model.drawables.ids;\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(parameterIds[drawableIndex]);\n    };\n    /**\n     * Drawableの描画順リストの取得\n     * @return Drawableの描画順リスト\n     */\n    CubismModel.prototype.getDrawableRenderOrders = function () {\n        var renderOrders = this._model.drawables.renderOrders;\n        return renderOrders;\n    };\n    /**\n     * @deprecated\n     * 関数名が誤っていたため、代替となる getDrawableTextureIndex を追加し、この関数は非推奨となりました。\n     *\n     * Drawableのテクスチャインデックスリストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのテクスチャインデックスリスト\n     */\n    CubismModel.prototype.getDrawableTextureIndices = function (drawableIndex) {\n        return this.getDrawableTextureIndex(drawableIndex);\n    };\n    /**\n     * Drawableのテクスチャインデックスの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのテクスチャインデックス\n     */\n    CubismModel.prototype.getDrawableTextureIndex = function (drawableIndex) {\n        var textureIndices = this._model.drawables.textureIndices;\n        return textureIndices[drawableIndex];\n    };\n    /**\n     * DrawableのVertexPositionsの変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。\n     *\n     * @param   drawableIndex   Drawableのインデックス\n     * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した\n     * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない\n     */\n    CubismModel.prototype.getDrawableDynamicFlagVertexPositionsDidChange = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * Drawableの頂点インデックスの個数の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点インデックスの個数\n     */\n    CubismModel.prototype.getDrawableVertexIndexCount = function (drawableIndex) {\n        var indexCounts = this._model.drawables.indexCounts;\n        return indexCounts[drawableIndex];\n    };\n    /**\n     * Drawableの頂点の個数の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点の個数\n     */\n    CubismModel.prototype.getDrawableVertexCount = function (drawableIndex) {\n        var vertexCounts = this._model.drawables.vertexCounts;\n        return vertexCounts[drawableIndex];\n    };\n    /**\n     * Drawableの頂点リストの取得\n     * @param drawableIndex drawableのインデックス\n     * @return drawableの頂点リスト\n     */\n    CubismModel.prototype.getDrawableVertices = function (drawableIndex) {\n        return this.getDrawableVertexPositions(drawableIndex);\n    };\n    /**\n     * Drawableの頂点インデックスリストの取得\n     * @param drarableIndex Drawableのインデックス\n     * @return drawableの頂点インデックスリスト\n     */\n    CubismModel.prototype.getDrawableVertexIndices = function (drawableIndex) {\n        var indicesArray = this._model.drawables.indices;\n        return indicesArray[drawableIndex];\n    };\n    /**\n     * Drawableの頂点リストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点リスト\n     */\n    CubismModel.prototype.getDrawableVertexPositions = function (drawableIndex) {\n        var verticesArray = this._model.drawables.vertexPositions;\n        return verticesArray[drawableIndex];\n    };\n    /**\n     * Drawableの頂点のUVリストの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの頂点UVリスト\n     */\n    CubismModel.prototype.getDrawableVertexUvs = function (drawableIndex) {\n        var uvsArray = this._model.drawables.vertexUvs;\n        return uvsArray[drawableIndex];\n    };\n    /**\n     * Drawableの不透明度の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの不透明度\n     */\n    CubismModel.prototype.getDrawableOpacity = function (drawableIndex) {\n        var opacities = this._model.drawables.opacities;\n        return opacities[drawableIndex];\n    };\n    /**\n     * Drawableの乗算色の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの乗算色(RGBA)\n     * スクリーン色はRGBAで取得されるが、Aは必ず0\n     */\n    CubismModel.prototype.getDrawableMultiplyColor = function (drawableIndex) {\n        var multiplyColors = this._model.drawables.multiplyColors;\n        var index = drawableIndex * 4;\n        var multiplyColor = new _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismTextureColor();\n        multiplyColor.R = multiplyColors[index];\n        multiplyColor.G = multiplyColors[index + 1];\n        multiplyColor.B = multiplyColors[index + 2];\n        multiplyColor.A = multiplyColors[index + 3];\n        return multiplyColor;\n    };\n    /**\n     * Drawableのスクリーン色の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのスクリーン色(RGBA)\n     * スクリーン色はRGBAで取得されるが、Aは必ず0\n     */\n    CubismModel.prototype.getDrawableScreenColor = function (drawableIndex) {\n        var screenColors = this._model.drawables.screenColors;\n        var index = drawableIndex * 4;\n        var screenColor = new _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismTextureColor();\n        screenColor.R = screenColors[index];\n        screenColor.G = screenColors[index + 1];\n        screenColor.B = screenColors[index + 2];\n        screenColor.A = screenColors[index + 3];\n        return screenColor;\n    };\n    /**\n     * Drawableの親パーツのインデックスの取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableの親パーツのインデックス\n     */\n    CubismModel.prototype.getDrawableParentPartIndex = function (drawableIndex) {\n        return this._model.drawables.parentPartIndices[drawableIndex];\n    };\n    /**\n     * Drawableのカリング情報の取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのカリング情報\n     */\n    CubismModel.prototype.getDrawableCulling = function (drawableIndex) {\n        var constantFlags = this._model.drawables.constantFlags;\n        return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);\n    };\n    /**\n     * Drawableのブレンドモードを取得\n     * @param drawableIndex Drawableのインデックス\n     * @return drawableのブレンドモード\n     */\n    CubismModel.prototype.getDrawableBlendMode = function (drawableIndex) {\n        var constantFlags = this._model.drawables.constantFlags;\n        return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex])\n            ? _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismBlendMode.CubismBlendMode_Additive\n            : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex])\n                ? _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismBlendMode.CubismBlendMode_Multiplicative\n                : _rendering_cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismBlendMode.CubismBlendMode_Normal;\n    };\n    /**\n     * Drawableのマスクの反転使用の取得\n     *\n     * Drawableのマスク使用時の反転設定を取得する。\n     * マスクを使用しない場合は無視される。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return Drawableの反転設定\n     */\n    CubismModel.prototype.getDrawableInvertedMaskBit = function (drawableIndex) {\n        var constantFlags = this._model.drawables.constantFlags;\n        return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);\n    };\n    /**\n     * Drawableのクリッピングマスクリストの取得\n     * @return Drawableのクリッピングマスクリスト\n     */\n    CubismModel.prototype.getDrawableMasks = function () {\n        var masks = this._model.drawables.masks;\n        return masks;\n    };\n    /**\n     * Drawableのクリッピングマスクの個数リストの取得\n     * @return Drawableのクリッピングマスクの個数リスト\n     */\n    CubismModel.prototype.getDrawableMaskCounts = function () {\n        var maskCounts = this._model.drawables.maskCounts;\n        return maskCounts;\n    };\n    /**\n     * クリッピングマスクの使用状態\n     *\n     * @return true クリッピングマスクを使用している\n     * @return false クリッピングマスクを使用していない\n     */\n    CubismModel.prototype.isUsingMasking = function () {\n        for (var d = 0; d < this._model.drawables.count; ++d) {\n            if (this._model.drawables.maskCounts[d] <= 0) {\n                continue;\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Drawableの表示情報を取得する\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableが表示\n     * @return false Drawableが非表示\n     */\n    CubismModel.prototype.getDrawableDynamicFlagIsVisible = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * DrawableのDrawOrderの変化情報の取得\n     *\n     * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。\n     * drawOrderはartMesh上で指定する0から1000の情報\n     * @param drawableIndex drawableのインデックス\n     * @return true drawableの不透明度が直近のCubismModel.update関数で変化した\n     * @return false drawableの不透明度が直近のCubismModel.update関数で変化している\n     */\n    CubismModel.prototype.getDrawableDynamicFlagVisibilityDidChange = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * Drawableの不透明度の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。\n     *\n     * @param drawableIndex drawableのインデックス\n     * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した\n     * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない\n     */\n    CubismModel.prototype.getDrawableDynamicFlagOpacityDidChange = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * Drawableの描画順序の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した\n     * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない\n     */\n    CubismModel.prototype.getDrawableDynamicFlagRenderOrderDidChange = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * Drawableの乗算色・スクリーン色の変化情報の取得\n     *\n     * 直近のCubismModel.update関数でDrawableの乗算色・スクリーン色が変化したかを取得する。\n     *\n     * @param drawableIndex Drawableのインデックス\n     * @return true Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化した\n     * @return false Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化してない\n     */\n    CubismModel.prototype.getDrawableDynamicFlagBlendColorDidChange = function (drawableIndex) {\n        var dynamicFlags = this._model.drawables.dynamicFlags;\n        return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(dynamicFlags[drawableIndex]);\n    };\n    /**\n     * 保存されたパラメータの読み込み\n     */\n    CubismModel.prototype.loadParameters = function () {\n        var parameterCount = this._model.parameters.count;\n        var savedParameterCount = this._savedParameters.getSize();\n        if (parameterCount > savedParameterCount) {\n            parameterCount = savedParameterCount;\n        }\n        for (var i = 0; i < parameterCount; ++i) {\n            this._parameterValues[i] = this._savedParameters.at(i);\n        }\n    };\n    /**\n     * 初期化する\n     */\n    CubismModel.prototype.initialize = function () {\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CSM_ASSERT)(this._model);\n        this._parameterValues = this._model.parameters.values;\n        this._partOpacities = this._model.parts.opacities;\n        this._parameterMaximumValues = this._model.parameters.maximumValues;\n        this._parameterMinimumValues = this._model.parameters.minimumValues;\n        {\n            var parameterIds = this._model.parameters.ids;\n            var parameterCount = this._model.parameters.count;\n            this._parameterIds.prepareCapacity(parameterCount);\n            for (var i = 0; i < parameterCount; ++i) {\n                this._parameterIds.pushBack(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(parameterIds[i]));\n            }\n        }\n        {\n            var partIds = this._model.parts.ids;\n            var partCount = this._model.parts.count;\n            this._partIds.prepareCapacity(partCount);\n            for (var i = 0; i < partCount; ++i) {\n                this._partIds.pushBack(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(partIds[i]));\n            }\n        }\n        {\n            var drawableIds = this._model.drawables.ids;\n            var drawableCount = this._model.drawables.count;\n            this._userMultiplyColors = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n            this._userMultiplyColors.updateSize(drawableCount, DrawableColorData, true);\n            this._userScreenColors = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n            this._userScreenColors.updateSize(drawableCount, DrawableColorData, true);\n            this._drawableIds.prepareCapacity(drawableCount);\n            for (var i = 0; i < drawableCount; ++i) {\n                this._drawableIds.pushBack(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(drawableIds[i]));\n                // shaderに影響しない色で初期化\n                this.setMultiplyColorByRGBA(i, 1.0, 1.0, 1.0, 1.0);\n                this.setScreenColorByRGBA(i, 0.0, 0.0, 0.0, 1.0);\n            }\n        }\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismModel.prototype.release = function () {\n        this._model.release();\n        this._model = null;\n    };\n    return CubismModel;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModel = _cubismmodel__WEBPACK_IMPORTED_MODULE_5__.CubismModel;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/model/cubismmodel.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/model/cubismmodeluserdata.ts":
/*!***************************************************************!*\
  !*** ./src/lib/live2d/Framework/model/cubismmodeluserdata.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismModelUserData\": () => (/* binding */ CubismModelUserData),\n/* harmony export */   \"CubismModelUserDataNode\": () => (/* binding */ CubismModelUserDataNode),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmstring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismmodeluserdatajson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubismmodeluserdatajson */ \"./src/lib/live2d/Framework/model/cubismmodeluserdatajson.ts\");\n/* harmony import */ var _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cubismmodeluserdata */ \"./src/lib/live2d/Framework/model/cubismmodeluserdata.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n\nvar ArtMesh = 'ArtMesh';\n/**\n * ユーザーデータインターフェース\n *\n * Jsonから読み込んだユーザーデータを記録しておくための構造体\n */\nvar CubismModelUserDataNode = /** @class */ (function () {\n    function CubismModelUserDataNode() {\n    }\n    return CubismModelUserDataNode;\n}());\n\n/**\n * ユーザデータの管理クラス\n *\n * ユーザデータをロード、管理、検索インターフェイス、解放までを行う。\n */\nvar CubismModelUserData = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismModelUserData() {\n        this._userDataNodes = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector();\n        this._artMeshUserDataNode = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector();\n    }\n    /**\n     * インスタンスの作成\n     *\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    CubismModelUserData.create = function (buffer, size) {\n        var ret = new CubismModelUserData();\n        ret.parseUserData(buffer, size);\n        return ret;\n    };\n    /**\n     * インスタンスを破棄する\n     *\n     * @param modelUserData 破棄するインスタンス\n     */\n    CubismModelUserData.delete = function (modelUserData) {\n        if (modelUserData != null) {\n            modelUserData.release();\n            modelUserData = null;\n        }\n    };\n    /**\n     * ArtMeshのユーザーデータのリストの取得\n     *\n     * @return ユーザーデータリスト\n     */\n    CubismModelUserData.prototype.getArtMeshUserDatas = function () {\n        return this._artMeshUserDataNode;\n    };\n    /**\n     * userdata3.jsonのパース\n     *\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     */\n    CubismModelUserData.prototype.parseUserData = function (buffer, size) {\n        var json = new _cubismmodeluserdatajson__WEBPACK_IMPORTED_MODULE_3__.CubismModelUserDataJson(buffer, size);\n        var typeOfArtMesh = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(ArtMesh);\n        var nodeCount = json.getUserDataCount();\n        for (var i = 0; i < nodeCount; i++) {\n            var addNode = new CubismModelUserDataNode();\n            addNode.targetId = json.getUserDataId(i);\n            addNode.targetType = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(json.getUserDataTargetType(i));\n            addNode.value = new _type_csmstring__WEBPACK_IMPORTED_MODULE_1__.csmString(json.getUserDataValue(i));\n            this._userDataNodes.pushBack(addNode);\n            if (addNode.targetType == typeOfArtMesh) {\n                this._artMeshUserDataNode.pushBack(addNode);\n            }\n        }\n        json.release();\n        json = void 0;\n    };\n    /**\n     * デストラクタ相当の処理\n     *\n     * ユーザーデータ構造体配列を解放する\n     */\n    CubismModelUserData.prototype.release = function () {\n        for (var i = 0; i < this._userDataNodes.getSize(); ++i) {\n            this._userDataNodes.set(i, null);\n        }\n        this._userDataNodes = null;\n    };\n    return CubismModelUserData;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelUserData = _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_4__.CubismModelUserData;\n    Live2DCubismFramework.CubismModelUserDataNode = _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_4__.CubismModelUserDataNode;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/model/cubismmodeluserdata.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/model/cubismmodeluserdatajson.ts":
/*!*******************************************************************!*\
  !*** ./src/lib/live2d/Framework/model/cubismmodeluserdatajson.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismModelUserDataJson\": () => (/* binding */ CubismModelUserDataJson),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismmodeluserdatajson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismmodeluserdatajson */ \"./src/lib/live2d/Framework/model/cubismmodeluserdatajson.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\nvar Meta = 'Meta';\nvar UserDataCount = 'UserDataCount';\nvar TotalUserDataSize = 'TotalUserDataSize';\nvar UserData = 'UserData';\nvar Target = 'Target';\nvar Id = 'Id';\nvar Value = 'Value';\nvar CubismModelUserDataJson = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param buffer    userdata3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     */\n    function CubismModelUserDataJson(buffer, size) {\n        this._json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_1__.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismModelUserDataJson.prototype.release = function () {\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_1__.CubismJson[\"delete\"](this._json);\n    };\n    /**\n     * ユーザーデータ個数の取得\n     * @return ユーザーデータの個数\n     */\n    CubismModelUserDataJson.prototype.getUserDataCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(UserDataCount)\n            .toInt();\n    };\n    /**\n     * ユーザーデータ総文字列数の取得\n     *\n     * @return ユーザーデータ総文字列数\n     */\n    CubismModelUserDataJson.prototype.getTotalUserDataSize = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalUserDataSize)\n            .toInt();\n    };\n    /**\n     * ユーザーデータのタイプの取得\n     *\n     * @return ユーザーデータのタイプ\n     */\n    CubismModelUserDataJson.prototype.getUserDataTargetType = function (i) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Target)\n            .getRawString();\n    };\n    /**\n     * ユーザーデータのターゲットIDの取得\n     *\n     * @param i インデックス\n     * @return ユーザーデータターゲットID\n     */\n    CubismModelUserDataJson.prototype.getUserDataId = function (i) {\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Id)\n            .getRawString());\n    };\n    /**\n     * ユーザーデータの文字列の取得\n     *\n     * @param i インデックス\n     * @return ユーザーデータ\n     */\n    CubismModelUserDataJson.prototype.getUserDataValue = function (i) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(i)\n            .getValueByString(Value)\n            .getRawString();\n    };\n    return CubismModelUserDataJson;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismModelUserDataJson = _cubismmodeluserdatajson__WEBPACK_IMPORTED_MODULE_2__.CubismModelUserDataJson;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/model/cubismmodeluserdatajson.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/model/cubismusermodel.ts":
/*!***********************************************************!*\
  !*** ./src/lib/live2d/Framework/model/cubismusermodel.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismUserModel\": () => (/* binding */ CubismUserModel),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _effect_cubismbreath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../effect/cubismbreath */ \"./src/lib/live2d/Framework/effect/cubismbreath.ts\");\n/* harmony import */ var _effect_cubismeyeblink__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effect/cubismeyeblink */ \"./src/lib/live2d/Framework/effect/cubismeyeblink.ts\");\n/* harmony import */ var _effect_cubismpose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../effect/cubismpose */ \"./src/lib/live2d/Framework/effect/cubismpose.ts\");\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _math_cubismmodelmatrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/cubismmodelmatrix */ \"./src/lib/live2d/Framework/math/cubismmodelmatrix.ts\");\n/* harmony import */ var _math_cubismtargetpoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/cubismtargetpoint */ \"./src/lib/live2d/Framework/math/cubismtargetpoint.ts\");\n/* harmony import */ var _motion_cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../motion/cubismexpressionmotion */ \"./src/lib/live2d/Framework/motion/cubismexpressionmotion.ts\");\n/* harmony import */ var _motion_cubismmotion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../motion/cubismmotion */ \"./src/lib/live2d/Framework/motion/cubismmotion.ts\");\n/* harmony import */ var _motion_cubismmotionmanager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../motion/cubismmotionmanager */ \"./src/lib/live2d/Framework/motion/cubismmotionmanager.ts\");\n/* harmony import */ var _physics_cubismphysics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../physics/cubismphysics */ \"./src/lib/live2d/Framework/physics/cubismphysics.ts\");\n/* harmony import */ var _rendering_cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../rendering/cubismrenderer_webgl */ \"./src/lib/live2d/Framework/rendering/cubismrenderer_webgl.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _cubismmoc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cubismmoc */ \"./src/lib/live2d/Framework/model/cubismmoc.ts\");\n/* harmony import */ var _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cubismmodeluserdata */ \"./src/lib/live2d/Framework/model/cubismmodeluserdata.ts\");\n/* harmony import */ var _cubismusermodel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cubismusermodel */ \"./src/lib/live2d/Framework/model/cubismusermodel.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * ユーザーが実際に使用するモデル\n *\n * ユーザーが実際に使用するモデルの基底クラス。これを継承してユーザーが実装する。\n */\nvar CubismUserModel = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismUserModel() {\n        /**\n         * モーションデータを読み込む\n         * @param buffer motion3.jsonファイルが読み込まれているバッファ\n         * @param size バッファのサイズ\n         * @param name モーションの名前\n         * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n         * @return モーションクラス\n         */\n        this.loadMotion = function (buffer, size, name, onFinishedMotionHandler) { return _motion_cubismmotion__WEBPACK_IMPORTED_MODULE_7__.CubismMotion.create(buffer, size, onFinishedMotionHandler); };\n        // 各変数初期化\n        this._moc = null;\n        this._model = null;\n        this._motionManager = null;\n        this._expressionManager = null;\n        this._eyeBlink = null;\n        this._breath = null;\n        this._modelMatrix = null;\n        this._pose = null;\n        this._dragManager = null;\n        this._physics = null;\n        this._modelUserData = null;\n        this._initialized = false;\n        this._updating = false;\n        this._opacity = 1.0;\n        this._lipsync = true;\n        this._lastLipSyncValue = 0.0;\n        this._dragX = 0.0;\n        this._dragY = 0.0;\n        this._accelerationX = 0.0;\n        this._accelerationY = 0.0;\n        this._accelerationZ = 0.0;\n        this._debugMode = false;\n        this._renderer = null;\n        // モーションマネージャーを作成\n        this._motionManager = new _motion_cubismmotionmanager__WEBPACK_IMPORTED_MODULE_8__.CubismMotionManager();\n        this._motionManager.setEventCallback(CubismUserModel.cubismDefaultMotionEventCallback, this);\n        // 表情マネージャーを作成\n        this._expressionManager = new _motion_cubismmotionmanager__WEBPACK_IMPORTED_MODULE_8__.CubismMotionManager();\n        // ドラッグによるアニメーション\n        this._dragManager = new _math_cubismtargetpoint__WEBPACK_IMPORTED_MODULE_5__.CubismTargetPoint();\n    }\n    /**\n     * 初期化状態の取得\n     *\n     * 初期化されている状態か？\n     *\n     * @return true     初期化されている\n     * @return false    初期化されていない\n     */\n    CubismUserModel.prototype.isInitialized = function () {\n        return this._initialized;\n    };\n    /**\n     * 初期化状態の設定\n     *\n     * 初期化状態を設定する。\n     *\n     * @param v 初期化状態\n     */\n    CubismUserModel.prototype.setInitialized = function (v) {\n        this._initialized = v;\n    };\n    /**\n     * 更新状態の取得\n     *\n     * 更新されている状態か？\n     *\n     * @return true     更新されている\n     * @return false    更新されていない\n     */\n    CubismUserModel.prototype.isUpdating = function () {\n        return this._updating;\n    };\n    /**\n     * 更新状態の設定\n     *\n     * 更新状態を設定する\n     *\n     * @param v 更新状態\n     */\n    CubismUserModel.prototype.setUpdating = function (v) {\n        this._updating = v;\n    };\n    /**\n     * マウスドラッグ情報の設定\n     * @param ドラッグしているカーソルのX位置\n     * @param ドラッグしているカーソルのY位置\n     */\n    CubismUserModel.prototype.setDragging = function (x, y) {\n        this._dragManager.set(x, y);\n    };\n    /**\n     * 加速度の情報を設定する\n     * @param x X軸方向の加速度\n     * @param y Y軸方向の加速度\n     * @param z Z軸方向の加速度\n     */\n    CubismUserModel.prototype.setAcceleration = function (x, y, z) {\n        this._accelerationX = x;\n        this._accelerationY = y;\n        this._accelerationZ = z;\n    };\n    /**\n     * モデル行列を取得する\n     * @return モデル行列\n     */\n    CubismUserModel.prototype.getModelMatrix = function () {\n        return this._modelMatrix;\n    };\n    /**\n     * 不透明度の設定\n     * @param a 不透明度\n     */\n    CubismUserModel.prototype.setOpacity = function (a) {\n        this._opacity = a;\n    };\n    /**\n     * 不透明度の取得\n     * @return 不透明度\n     */\n    CubismUserModel.prototype.getOpacity = function () {\n        return this._opacity;\n    };\n    /**\n     * モデルデータを読み込む\n     *\n     * @param buffer    moc3ファイルが読み込まれているバッファ\n     */\n    CubismUserModel.prototype.loadModel = function (buffer) {\n        this._moc = _cubismmoc__WEBPACK_IMPORTED_MODULE_12__.CubismMoc.create(buffer);\n        if (this._moc == null) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_11__.CubismLogError)('Failed to CubismMoc.create().');\n            return;\n        }\n        this._model = this._moc.createModel();\n        if (this._model == null) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_11__.CubismLogError)('Failed to CreateModel().');\n            return;\n        }\n        this._model.saveParameters();\n        this._modelMatrix = new _math_cubismmodelmatrix__WEBPACK_IMPORTED_MODULE_4__.CubismModelMatrix(this._model.getCanvasWidth(), this._model.getCanvasHeight());\n    };\n    /**\n     * 表情データの読み込み\n     * @param buffer expファイルが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @param name 表情の名前\n     */\n    CubismUserModel.prototype.loadExpression = function (buffer, size, name) {\n        return _motion_cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_6__.CubismExpressionMotion.create(buffer, size);\n    };\n    /**\n     * ポーズデータの読み込み\n     * @param buffer pose3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    CubismUserModel.prototype.loadPose = function (buffer, size) {\n        this._pose = _effect_cubismpose__WEBPACK_IMPORTED_MODULE_2__.CubismPose.create(buffer, size);\n    };\n    /**\n     * モデルに付属するユーザーデータを読み込む\n     * @param buffer userdata3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    CubismUserModel.prototype.loadUserData = function (buffer, size) {\n        this._modelUserData = _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_13__.CubismModelUserData.create(buffer, size);\n    };\n    /**\n     * 物理演算データの読み込み\n     * @param buffer  physics3.jsonが読み込まれているバッファ\n     * @param size    バッファのサイズ\n     */\n    CubismUserModel.prototype.loadPhysics = function (buffer, size) {\n        this._physics = _physics_cubismphysics__WEBPACK_IMPORTED_MODULE_9__.CubismPhysics.create(buffer, size);\n    };\n    /**\n     * 当たり判定の取得\n     * @param drawableId 検証したいDrawableのID\n     * @param pointX X位置\n     * @param pointY Y位置\n     * @return true ヒットしている\n     * @return false ヒットしていない\n     */\n    CubismUserModel.prototype.isHit = function (drawableId, pointX, pointY) {\n        var drawIndex = this._model.getDrawableIndex(drawableId);\n        if (drawIndex < 0) {\n            return false; // 存在しない場合はfalse\n        }\n        var count = this._model.getDrawableVertexCount(drawIndex);\n        var vertices = this._model.getDrawableVertices(drawIndex);\n        var left = vertices[0];\n        var right = vertices[0];\n        var top = vertices[1];\n        var bottom = vertices[1];\n        for (var j = 1; j < count; ++j) {\n            var x = vertices[_live2dcubismframework__WEBPACK_IMPORTED_MODULE_3__.Constant.vertexOffset + j * _live2dcubismframework__WEBPACK_IMPORTED_MODULE_3__.Constant.vertexStep];\n            var y = vertices[_live2dcubismframework__WEBPACK_IMPORTED_MODULE_3__.Constant.vertexOffset + j * _live2dcubismframework__WEBPACK_IMPORTED_MODULE_3__.Constant.vertexStep + 1];\n            if (x < left) {\n                left = x; // Min x\n            }\n            if (x > right) {\n                right = x; // Max x\n            }\n            if (y < top) {\n                top = y; // Min y\n            }\n            if (y > bottom) {\n                bottom = y; // Max y\n            }\n        }\n        var tx = this._modelMatrix.invertTransformX(pointX);\n        var ty = this._modelMatrix.invertTransformY(pointY);\n        return left <= tx && tx <= right && top <= ty && ty <= bottom;\n    };\n    /**\n     * モデルの取得\n     * @return モデル\n     */\n    CubismUserModel.prototype.getModel = function () {\n        return this._model;\n    };\n    /**\n     * レンダラの取得\n     * @return レンダラ\n     */\n    CubismUserModel.prototype.getRenderer = function () {\n        return this._renderer;\n    };\n    /**\n     * レンダラを作成して初期化を実行する\n     */\n    CubismUserModel.prototype.createRenderer = function () {\n        if (this._renderer) {\n            this.deleteRenderer();\n        }\n        this._renderer = new _rendering_cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_10__.CubismRenderer_WebGL();\n        this._renderer.initialize(this._model);\n    };\n    /**\n     * レンダラの解放\n     */\n    CubismUserModel.prototype.deleteRenderer = function () {\n        if (this._renderer != null) {\n            this._renderer.release();\n            this._renderer = null;\n        }\n    };\n    /**\n     * イベント発火時の標準処理\n     *\n     * Eventが再生処理時にあった場合の処理をする。\n     * 継承で上書きすることを想定している。\n     * 上書きしない場合はログ出力をする。\n     *\n     * @param eventValue 発火したイベントの文字列データ\n     */\n    CubismUserModel.prototype.motionEventFired = function (eventValue) {\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_11__.CubismLogInfo)('{0}', eventValue.s);\n    };\n    /**\n     * イベント用のコールバック\n     *\n     * CubismMotionQueueManagerにイベント用に登録するためのCallback。\n     * CubismUserModelの継承先のEventFiredを呼ぶ。\n     *\n     * @param caller 発火したイベントを管理していたモーションマネージャー、比較用\n     * @param eventValue 発火したイベントの文字列データ\n     * @param customData CubismUserModelを継承したインスタンスを想定\n     */\n    CubismUserModel.cubismDefaultMotionEventCallback = function (caller, eventValue, customData) {\n        var model = customData;\n        if (model != null) {\n            model.motionEventFired(eventValue);\n        }\n    };\n    /**\n     * デストラクタに相当する処理\n     */\n    CubismUserModel.prototype.release = function () {\n        if (this._motionManager != null) {\n            this._motionManager.release();\n            this._motionManager = null;\n        }\n        if (this._expressionManager != null) {\n            this._expressionManager.release();\n            this._expressionManager = null;\n        }\n        if (this._moc != null) {\n            this._moc.deleteModel(this._model);\n            this._moc.release();\n            this._moc = null;\n        }\n        this._modelMatrix = null;\n        _effect_cubismpose__WEBPACK_IMPORTED_MODULE_2__.CubismPose[\"delete\"](this._pose);\n        _effect_cubismeyeblink__WEBPACK_IMPORTED_MODULE_1__.CubismEyeBlink[\"delete\"](this._eyeBlink);\n        _effect_cubismbreath__WEBPACK_IMPORTED_MODULE_0__.CubismBreath[\"delete\"](this._breath);\n        this._dragManager = null;\n        _physics_cubismphysics__WEBPACK_IMPORTED_MODULE_9__.CubismPhysics[\"delete\"](this._physics);\n        _cubismmodeluserdata__WEBPACK_IMPORTED_MODULE_13__.CubismModelUserData[\"delete\"](this._modelUserData);\n        this.deleteRenderer();\n    };\n    return CubismUserModel;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismUserModel = _cubismusermodel__WEBPACK_IMPORTED_MODULE_14__.CubismUserModel;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/model/cubismusermodel.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/acubismmotion.ts":
/*!**********************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/acubismmotion.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACubismMotion\": () => (/* binding */ ACubismMotion),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/cubismmath */ \"./src/lib/live2d/Framework/math/cubismmath.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _acubismmotion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./acubismmotion */ \"./src/lib/live2d/Framework/motion/acubismmotion.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n/**\n * モーションの抽象基底クラス\n *\n * モーションの抽象基底クラス。MotionQueueManagerによってモーションの再生を管理する。\n */\nvar ACubismMotion = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function ACubismMotion() {\n        var _this = this;\n        /**\n         * モーション再生終了コールバックの登録\n         *\n         * モーション再生終了コールバックを登録する。\n         * isFinishedフラグを設定するタイミングで呼び出される。\n         * 以下の状態の際には呼び出されない:\n         *   1. 再生中のモーションが「ループ」として設定されているとき\n         *   2. コールバックが登録されていない時\n         *\n         * @param onFinishedMotionHandler モーション再生終了コールバック関数\n         */\n        this.setFinishedMotionHandler = function (onFinishedMotionHandler) { return (_this._onFinishedMotion = onFinishedMotionHandler); };\n        /**\n         * モーション再生終了コールバックの取得\n         *\n         * モーション再生終了コールバックを取得する。\n         *\n         * @return 登録されているモーション再生終了コールバック関数\n         */\n        this.getFinishedMotionHandler = function () { return _this._onFinishedMotion; };\n        this._fadeInSeconds = -1.0;\n        this._fadeOutSeconds = -1.0;\n        this._weight = 1.0;\n        this._offsetSeconds = 0.0; // 再生の開始時刻\n        this._firedEventValues = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n    }\n    /**\n     * インスタンスの破棄\n     */\n    ACubismMotion.delete = function (motion) {\n        motion.release();\n        motion = null;\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    ACubismMotion.prototype.release = function () {\n        this._weight = 0.0;\n    };\n    /**\n     * モデルのパラメータ\n     * @param model 対象のモデル\n     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     */\n    ACubismMotion.prototype.updateParameters = function (model, motionQueueEntry, userTimeSeconds) {\n        if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {\n            return;\n        }\n        if (!motionQueueEntry.isStarted()) {\n            motionQueueEntry.setIsStarted(true);\n            motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds); // モーションの開始時刻を記録\n            motionQueueEntry.setFadeInStartTime(userTimeSeconds); // フェードインの開始時刻\n            var duration = this.getDuration();\n            if (motionQueueEntry.getEndTime() < 0) {\n                // 開始していないうちに終了設定している場合がある。\n                motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);\n                // duration == -1 の場合はループする\n            }\n        }\n        var fadeWeight = this._weight; // 現在の値と掛け合わせる割合\n        //---- フェードイン・アウトの処理 ----\n        // 単純なサイン関数でイージングする\n        var fadeIn = this._fadeInSeconds == 0.0\n            ? 1.0\n            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                this._fadeInSeconds);\n        var fadeOut = this._fadeOutSeconds == 0.0 || motionQueueEntry.getEndTime() < 0.0\n            ? 1.0\n            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                this._fadeOutSeconds);\n        fadeWeight = fadeWeight * fadeIn * fadeOut;\n        motionQueueEntry.setState(userTimeSeconds, fadeWeight);\n        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CSM_ASSERT)(0.0 <= fadeWeight && fadeWeight <= 1.0);\n        //---- 全てのパラメータIDをループする ----\n        this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);\n        // 後処理\n        // 終了時刻を過ぎたら終了フラグを立てる(CubismMotionQueueManager)\n        if (motionQueueEntry.getEndTime() > 0 &&\n            motionQueueEntry.getEndTime() < userTimeSeconds) {\n            motionQueueEntry.setIsFinished(true); // 終了\n        }\n    };\n    /**\n     * フェードインの時間を設定する\n     * @param fadeInSeconds フェードインにかかる時間[秒]\n     */\n    ACubismMotion.prototype.setFadeInTime = function (fadeInSeconds) {\n        this._fadeInSeconds = fadeInSeconds;\n    };\n    /**\n     * フェードアウトの時間を設定する\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     */\n    ACubismMotion.prototype.setFadeOutTime = function (fadeOutSeconds) {\n        this._fadeOutSeconds = fadeOutSeconds;\n    };\n    /**\n     * フェードアウトにかかる時間の取得\n     * @return フェードアウトにかかる時間[秒]\n     */\n    ACubismMotion.prototype.getFadeOutTime = function () {\n        return this._fadeOutSeconds;\n    };\n    /**\n     * フェードインにかかる時間の取得\n     * @return フェードインにかかる時間[秒]\n     */\n    ACubismMotion.prototype.getFadeInTime = function () {\n        return this._fadeInSeconds;\n    };\n    /**\n     * モーション適用の重みの設定\n     * @param weight 重み（0.0 - 1.0）\n     */\n    ACubismMotion.prototype.setWeight = function (weight) {\n        this._weight = weight;\n    };\n    /**\n     * モーション適用の重みの取得\n     * @return 重み（0.0 - 1.0）\n     */\n    ACubismMotion.prototype.getWeight = function () {\n        return this._weight;\n    };\n    /**\n     * モーションの長さの取得\n     * @return モーションの長さ[秒]\n     *\n     * @note ループの時は「-1」。\n     *       ループでない場合は、オーバーライドする。\n     *       正の値の時は取得される時間で終了する。\n     *       「-1」の時は外部から停止命令がない限り終わらない処理となる。\n     */\n    ACubismMotion.prototype.getDuration = function () {\n        return -1.0;\n    };\n    /**\n     * モーションのループ1回分の長さの取得\n     * @return モーションのループ一回分の長さ[秒]\n     *\n     * @note ループしない場合は、getDuration()と同じ値を返す\n     *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す\n     */\n    ACubismMotion.prototype.getLoopDuration = function () {\n        return -1.0;\n    };\n    /**\n     * モーション再生の開始時刻の設定\n     * @param offsetSeconds モーション再生の開始時刻[秒]\n     */\n    ACubismMotion.prototype.setOffsetTime = function (offsetSeconds) {\n        this._offsetSeconds = offsetSeconds;\n    };\n    /**\n     * モデルのパラメータ更新\n     *\n     * イベント発火のチェック。\n     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n     *\n     * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]\n     * @param motionTimeSeconds 今回の再生時間[秒]\n     */\n    ACubismMotion.prototype.getFiredEvent = function (beforeCheckTimeSeconds, motionTimeSeconds) {\n        return this._firedEventValues;\n    };\n    return ACubismMotion;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.ACubismMotion = _acubismmotion__WEBPACK_IMPORTED_MODULE_3__.ACubismMotion;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/acubismmotion.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismexpressionmotion.ts":
/*!*******************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismexpressionmotion.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismExpressionMotion\": () => (/* binding */ CubismExpressionMotion),\n/* harmony export */   \"ExpressionBlendType\": () => (/* binding */ ExpressionBlendType),\n/* harmony export */   \"ExpressionParameter\": () => (/* binding */ ExpressionParameter),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _acubismmotion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./acubismmotion */ \"./src/lib/live2d/Framework/motion/acubismmotion.ts\");\n/* harmony import */ var _cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cubismexpressionmotion */ \"./src/lib/live2d/Framework/motion/cubismexpressionmotion.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n// exp3.jsonのキーとデフォルト\nvar ExpressionKeyFadeIn = 'FadeInTime';\nvar ExpressionKeyFadeOut = 'FadeOutTime';\nvar ExpressionKeyParameters = 'Parameters';\nvar ExpressionKeyId = 'Id';\nvar ExpressionKeyValue = 'Value';\nvar ExpressionKeyBlend = 'Blend';\nvar BlendValueAdd = 'Add';\nvar BlendValueMultiply = 'Multiply';\nvar BlendValueOverwrite = 'Overwrite';\nvar DefaultFadeTime = 1.0;\n/**\n * 表情のモーション\n *\n * 表情のモーションクラス。\n */\nvar CubismExpressionMotion = /** @class */ (function (_super) {\n    __extends(CubismExpressionMotion, _super);\n    /**\n     * コンストラクタ\n     */\n    function CubismExpressionMotion() {\n        var _this = _super.call(this) || this;\n        _this._parameters = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        return _this;\n    }\n    /**\n     * インスタンスを作成する。\n     * @param buffer expファイルが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    CubismExpressionMotion.create = function (buffer, size) {\n        var expression = new CubismExpressionMotion();\n        var json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson.create(buffer, size);\n        var root = json.getRoot();\n        expression.setFadeInTime(root.getValueByString(ExpressionKeyFadeIn).toFloat(DefaultFadeTime)); // フェードイン\n        expression.setFadeOutTime(root.getValueByString(ExpressionKeyFadeOut).toFloat(DefaultFadeTime)); // フェードアウト\n        // 各パラメータについて\n        var parameterCount = root\n            .getValueByString(ExpressionKeyParameters)\n            .getSize();\n        expression._parameters.prepareCapacity(parameterCount);\n        for (var i = 0; i < parameterCount; ++i) {\n            var param = root\n                .getValueByString(ExpressionKeyParameters)\n                .getValueByIndex(i);\n            var parameterId = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(param.getValueByString(ExpressionKeyId).getRawString()); // パラメータID\n            var value = param\n                .getValueByString(ExpressionKeyValue)\n                .toFloat(); // 値\n            // 計算方法の設定\n            var blendType = void 0;\n            if (param.getValueByString(ExpressionKeyBlend).isNull() ||\n                param.getValueByString(ExpressionKeyBlend).getString() == BlendValueAdd) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Add;\n            }\n            else if (param.getValueByString(ExpressionKeyBlend).getString() ==\n                BlendValueMultiply) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Multiply;\n            }\n            else if (param.getValueByString(ExpressionKeyBlend).getString() ==\n                BlendValueOverwrite) {\n                blendType = ExpressionBlendType.ExpressionBlendType_Overwrite;\n            }\n            else {\n                // その他 仕様にない値を設定した時は加算モードにすることで復旧\n                blendType = ExpressionBlendType.ExpressionBlendType_Add;\n            }\n            // 設定オブジェクトを作成してリストに追加する\n            var item = new ExpressionParameter();\n            item.parameterId = parameterId;\n            item.blendType = blendType;\n            item.value = value;\n            expression._parameters.pushBack(item);\n        }\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson[\"delete\"](json); // JSONデータは不要になったら削除する\n        return expression;\n    };\n    /**\n     * モデルのパラメータの更新の実行\n     * @param model 対象のモデル\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     * @param weight モーションの重み\n     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション\n     */\n    CubismExpressionMotion.prototype.doUpdateParameters = function (model, userTimeSeconds, weight, motionQueueEntry) {\n        for (var i = 0; i < this._parameters.getSize(); ++i) {\n            var parameter = this._parameters.at(i);\n            switch (parameter.blendType) {\n                case ExpressionBlendType.ExpressionBlendType_Add: {\n                    model.addParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                case ExpressionBlendType.ExpressionBlendType_Multiply: {\n                    model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                case ExpressionBlendType.ExpressionBlendType_Overwrite: {\n                    model.setParameterValueById(parameter.parameterId, parameter.value, weight);\n                    break;\n                }\n                default:\n                    // 仕様にない値を設定した時はすでに加算モードになっている\n                    break;\n            }\n        }\n    };\n    return CubismExpressionMotion;\n}(_acubismmotion__WEBPACK_IMPORTED_MODULE_3__.ACubismMotion));\n\n/**\n * 表情パラメータ値の計算方式\n */\nvar ExpressionBlendType;\n(function (ExpressionBlendType) {\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Add\"] = 0] = \"ExpressionBlendType_Add\";\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Multiply\"] = 1] = \"ExpressionBlendType_Multiply\";\n    ExpressionBlendType[ExpressionBlendType[\"ExpressionBlendType_Overwrite\"] = 2] = \"ExpressionBlendType_Overwrite\";\n})(ExpressionBlendType || (ExpressionBlendType = {}));\n/**\n * 表情のパラメータ情報\n */\nvar ExpressionParameter = /** @class */ (function () {\n    function ExpressionParameter() {\n    }\n    return ExpressionParameter;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismExpressionMotion = _cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_4__.CubismExpressionMotion;\n    Live2DCubismFramework.ExpressionBlendType = _cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_4__.ExpressionBlendType;\n    Live2DCubismFramework.ExpressionParameter = _cubismexpressionmotion__WEBPACK_IMPORTED_MODULE_4__.ExpressionParameter;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismexpressionmotion.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotion.ts":
/*!*********************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotion.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotion\": () => (/* binding */ CubismMotion),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/cubismmath */ \"./src/lib/live2d/Framework/math/cubismmath.ts\");\n/* harmony import */ var _type_csmstring__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _acubismmotion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./acubismmotion */ \"./src/lib/live2d/Framework/motion/acubismmotion.ts\");\n/* harmony import */ var _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cubismmotioninternal */ \"./src/lib/live2d/Framework/motion/cubismmotioninternal.ts\");\n/* harmony import */ var _cubismmotionjson__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cubismmotionjson */ \"./src/lib/live2d/Framework/motion/cubismmotionjson.ts\");\n/* harmony import */ var _cubismmotion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cubismmotion */ \"./src/lib/live2d/Framework/motion/cubismmotion.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\nvar EffectNameEyeBlink = 'EyeBlink';\nvar EffectNameLipSync = 'LipSync';\nvar TargetNameModel = 'Model';\nvar TargetNameParameter = 'Parameter';\nvar TargetNamePartOpacity = 'PartOpacity';\n/**\n * Cubism SDK R2 以前のモーションを再現させるなら true 、アニメータのモーションを正しく再現するなら false 。\n */\nvar UseOldBeziersCurveMotion = false;\nfunction lerpPoints(a, b, t) {\n    var result = new _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionPoint();\n    result.time = a.time + (b.time - a.time) * t;\n    result.value = a.value + (b.value - a.value) * t;\n    return result;\n}\nfunction linearEvaluate(points, time) {\n    var t = (time - points[0].time) / (points[1].time - points[0].time);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    return points[0].value + (points[1].value - points[0].value) * t;\n}\nfunction bezierEvaluate(points, time) {\n    var t = (time - points[0].time) / (points[3].time - points[0].time);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    var p01 = lerpPoints(points[0], points[1], t);\n    var p12 = lerpPoints(points[1], points[2], t);\n    var p23 = lerpPoints(points[2], points[3], t);\n    var p012 = lerpPoints(p01, p12, t);\n    var p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateBinarySearch(points, time) {\n    var x_error = 0.01;\n    var x = time;\n    var x1 = points[0].time;\n    var x2 = points[3].time;\n    var cx1 = points[1].time;\n    var cx2 = points[2].time;\n    var ta = 0.0;\n    var tb = 1.0;\n    var t = 0.0;\n    var i = 0;\n    for (var var33 = true; i < 20; ++i) {\n        if (x < x1 + x_error) {\n            t = ta;\n            break;\n        }\n        if (x2 - x_error < x) {\n            t = tb;\n            break;\n        }\n        var centerx = (cx1 + cx2) * 0.5;\n        cx1 = (x1 + cx1) * 0.5;\n        cx2 = (x2 + cx2) * 0.5;\n        var ctrlx12 = (cx1 + centerx) * 0.5;\n        var ctrlx21 = (cx2 + centerx) * 0.5;\n        centerx = (ctrlx12 + ctrlx21) * 0.5;\n        if (x < centerx) {\n            tb = (ta + tb) * 0.5;\n            if (centerx - x_error < x) {\n                t = tb;\n                break;\n            }\n            x2 = centerx;\n            cx2 = ctrlx12;\n        }\n        else {\n            ta = (ta + tb) * 0.5;\n            if (x < centerx + x_error) {\n                t = ta;\n                break;\n            }\n            x1 = centerx;\n            cx1 = ctrlx21;\n        }\n    }\n    if (i == 20) {\n        t = (ta + tb) * 0.5;\n    }\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    if (t > 1.0) {\n        t = 1.0;\n    }\n    var p01 = lerpPoints(points[0], points[1], t);\n    var p12 = lerpPoints(points[1], points[2], t);\n    var p23 = lerpPoints(points[2], points[3], t);\n    var p012 = lerpPoints(p01, p12, t);\n    var p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateCardanoInterpretation(points, time) {\n    var x = time;\n    var x1 = points[0].time;\n    var x2 = points[3].time;\n    var cx1 = points[1].time;\n    var cx2 = points[2].time;\n    var a = x2 - 3.0 * cx2 + 3.0 * cx1 - x1;\n    var b = 3.0 * cx2 - 6.0 * cx1 + 3.0 * x1;\n    var c = 3.0 * cx1 - 3.0 * x1;\n    var d = x1 - x;\n    var t = _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath.cardanoAlgorithmForBezier(a, b, c, d);\n    var p01 = lerpPoints(points[0], points[1], t);\n    var p12 = lerpPoints(points[1], points[2], t);\n    var p23 = lerpPoints(points[2], points[3], t);\n    var p012 = lerpPoints(p01, p12, t);\n    var p123 = lerpPoints(p12, p23, t);\n    return lerpPoints(p012, p123, t).value;\n}\nfunction steppedEvaluate(points, time) {\n    return points[0].value;\n}\nfunction inverseSteppedEvaluate(points, time) {\n    return points[1].value;\n}\nfunction evaluateCurve(motionData, index, time) {\n    // Find segment to evaluate.\n    var curve = motionData.curves.at(index);\n    var target = -1;\n    var totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;\n    var pointPosition = 0;\n    for (var i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {\n        // Get first point of next segment.\n        pointPosition =\n            motionData.segments.at(i).basePointIndex +\n                (motionData.segments.at(i).segmentType ==\n                    _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Bezier\n                    ? 3\n                    : 1);\n        // Break if time lies within current segment.\n        if (motionData.points.at(pointPosition).time > time) {\n            target = i;\n            break;\n        }\n    }\n    if (target == -1) {\n        return motionData.points.at(pointPosition).value;\n    }\n    var segment = motionData.segments.at(target);\n    return segment.evaluate(motionData.points.get(segment.basePointIndex), time);\n}\n/**\n * モーションクラス\n *\n * モーションのクラス。\n */\nvar CubismMotion = /** @class */ (function (_super) {\n    __extends(CubismMotion, _super);\n    /**\n     * コンストラクタ\n     */\n    function CubismMotion() {\n        var _this = _super.call(this) || this;\n        _this._sourceFrameRate = 30.0;\n        _this._loopDurationSeconds = -1.0;\n        _this._isLoop = false; // trueから false へデフォルトを変更\n        _this._isLoopFadeIn = true; // ループ時にフェードインが有効かどうかのフラグ\n        _this._lastWeight = 0.0;\n        _this._motionData = null;\n        _this._modelCurveIdEyeBlink = null;\n        _this._modelCurveIdLipSync = null;\n        _this._eyeBlinkParameterIds = null;\n        _this._lipSyncParameterIds = null;\n        return _this;\n    }\n    /**\n     * インスタンスを作成する\n     *\n     * @param buffer motion3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数\n     * @return 作成されたインスタンス\n     */\n    CubismMotion.create = function (buffer, size, onFinishedMotionHandler) {\n        var ret = new CubismMotion();\n        ret.parse(buffer, size);\n        ret._sourceFrameRate = ret._motionData.fps;\n        ret._loopDurationSeconds = ret._motionData.duration;\n        ret._onFinishedMotion = onFinishedMotionHandler;\n        // NOTE: Editorではループありのモーション書き出しは非対応\n        // ret->_loop = (ret->_motionData->Loop > 0);\n        return ret;\n    };\n    /**\n     * モデルのパラメータの更新の実行\n     * @param model             対象のモデル\n     * @param userTimeSeconds   現在の時刻[秒]\n     * @param fadeWeight        モーションの重み\n     * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション\n     */\n    CubismMotion.prototype.doUpdateParameters = function (model, userTimeSeconds, fadeWeight, motionQueueEntry) {\n        if (this._modelCurveIdEyeBlink == null) {\n            this._modelCurveIdEyeBlink =\n                _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(EffectNameEyeBlink);\n        }\n        if (this._modelCurveIdLipSync == null) {\n            this._modelCurveIdLipSync =\n                _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(EffectNameLipSync);\n        }\n        var timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();\n        if (timeOffsetSeconds < 0.0) {\n            timeOffsetSeconds = 0.0; // エラー回避\n        }\n        var lipSyncValue = Number.MAX_VALUE;\n        var eyeBlinkValue = Number.MAX_VALUE;\n        //まばたき、リップシンクのうちモーションの適用を検出するためのビット（maxFlagCount個まで\n        var MaxTargetSize = 64;\n        var lipSyncFlags = 0;\n        var eyeBlinkFlags = 0;\n        //瞬き、リップシンクのターゲット数が上限を超えている場合\n        if (this._eyeBlinkParameterIds.getSize() > MaxTargetSize) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_3__.CubismLogDebug)('too many eye blink targets : {0}', this._eyeBlinkParameterIds.getSize());\n        }\n        if (this._lipSyncParameterIds.getSize() > MaxTargetSize) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_3__.CubismLogDebug)('too many lip sync targets : {0}', this._lipSyncParameterIds.getSize());\n        }\n        var tmpFadeIn = this._fadeInSeconds <= 0.0\n            ? 1.0\n            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                this._fadeInSeconds);\n        var tmpFadeOut = this._fadeOutSeconds <= 0.0 || motionQueueEntry.getEndTime() < 0.0\n            ? 1.0\n            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                this._fadeOutSeconds);\n        var value;\n        var c, parameterIndex;\n        // 'Repeat' time as necessary.\n        var time = timeOffsetSeconds;\n        if (this._isLoop) {\n            while (time > this._motionData.duration) {\n                time -= this._motionData.duration;\n            }\n        }\n        var curves = this._motionData.curves;\n        // Evaluate model curves.\n        for (c = 0; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {\n            // Evaluate curve and call handler.\n            value = evaluateCurve(this._motionData, c, time);\n            if (curves.at(c).id == this._modelCurveIdEyeBlink) {\n                eyeBlinkValue = value;\n            }\n            else if (curves.at(c).id == this._modelCurveIdLipSync) {\n                lipSyncValue = value;\n            }\n        }\n        var parameterMotionCurveCount = 0;\n        for (; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {\n            parameterMotionCurveCount++;\n            // Find parameter index.\n            parameterIndex = model.getParameterIndex(curves.at(c).id);\n            // Skip curve evaluation if no value in sink.\n            if (parameterIndex == -1) {\n                continue;\n            }\n            var sourceValue = model.getParameterValueByIndex(parameterIndex);\n            // Evaluate curve and apply value.\n            value = evaluateCurve(this._motionData, c, time);\n            if (eyeBlinkValue != Number.MAX_VALUE) {\n                for (var i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {\n                        value *= eyeBlinkValue;\n                        eyeBlinkFlags |= 1 << i;\n                        break;\n                    }\n                }\n            }\n            if (lipSyncValue != Number.MAX_VALUE) {\n                for (var i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {\n                        value += lipSyncValue;\n                        lipSyncFlags |= 1 << i;\n                        break;\n                    }\n                }\n            }\n            var v = void 0;\n            // パラメータごとのフェード\n            if (curves.at(c).fadeInTime < 0.0 && curves.at(c).fadeOutTime < 0.0) {\n                // モーションのフェードを適用\n                v = sourceValue + (value - sourceValue) * fadeWeight;\n            }\n            else {\n                // パラメータに対してフェードインかフェードアウトが設定してある場合はそちらを適用\n                var fin = void 0;\n                var fout = void 0;\n                if (curves.at(c).fadeInTime < 0.0) {\n                    fin = tmpFadeIn;\n                }\n                else {\n                    fin =\n                        curves.at(c).fadeInTime == 0.0\n                            ? 1.0\n                            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) /\n                                curves.at(c).fadeInTime);\n                }\n                if (curves.at(c).fadeOutTime < 0.0) {\n                    fout = tmpFadeOut;\n                }\n                else {\n                    fout =\n                        curves.at(c).fadeOutTime == 0.0 ||\n                            motionQueueEntry.getEndTime() < 0.0\n                            ? 1.0\n                            : _math_cubismmath__WEBPACK_IMPORTED_MODULE_1__.CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) /\n                                curves.at(c).fadeOutTime);\n                }\n                var paramWeight = this._weight * fin * fout;\n                // パラメータごとのフェードを適用\n                v = sourceValue + (value - sourceValue) * paramWeight;\n            }\n            model.setParameterValueByIndex(parameterIndex, v, 1.0);\n        }\n        {\n            if (eyeBlinkValue != Number.MAX_VALUE) {\n                for (var i = 0; i < this._eyeBlinkParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    var sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds.at(i));\n                    // モーションでの上書きがあった時にはまばたきは適用しない\n                    if ((eyeBlinkFlags >> i) & 0x01) {\n                        continue;\n                    }\n                    var v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;\n                    model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);\n                }\n            }\n            if (lipSyncValue != Number.MAX_VALUE) {\n                for (var i = 0; i < this._lipSyncParameterIds.getSize() && i < MaxTargetSize; ++i) {\n                    var sourceValue = model.getParameterValueById(this._lipSyncParameterIds.at(i));\n                    // モーションでの上書きがあった時にはリップシンクは適用しない\n                    if ((lipSyncFlags >> i) & 0x01) {\n                        continue;\n                    }\n                    var v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;\n                    model.setParameterValueById(this._lipSyncParameterIds.at(i), v);\n                }\n            }\n        }\n        for (; c < this._motionData.curveCount &&\n            curves.at(c).type ==\n                _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {\n            // Find parameter index.\n            parameterIndex = model.getParameterIndex(curves.at(c).id);\n            // Skip curve evaluation if no value in sink.\n            if (parameterIndex == -1) {\n                continue;\n            }\n            // Evaluate curve and apply value.\n            value = evaluateCurve(this._motionData, c, time);\n            model.setParameterValueByIndex(parameterIndex, value);\n        }\n        if (timeOffsetSeconds >= this._motionData.duration) {\n            if (this._isLoop) {\n                motionQueueEntry.setStartTime(userTimeSeconds); // 最初の状態へ\n                if (this._isLoopFadeIn) {\n                    // ループ内でループ用フェードインが有効の時は、フェードイン設定し直し\n                    motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n                }\n            }\n            else {\n                if (this._onFinishedMotion) {\n                    this._onFinishedMotion(this);\n                }\n                motionQueueEntry.setIsFinished(true);\n            }\n        }\n        this._lastWeight = fadeWeight;\n    };\n    /**\n     * ループ情報の設定\n     * @param loop ループ情報\n     */\n    CubismMotion.prototype.setIsLoop = function (loop) {\n        this._isLoop = loop;\n    };\n    /**\n     * ループ情報の取得\n     * @return true ループする\n     * @return false ループしない\n     */\n    CubismMotion.prototype.isLoop = function () {\n        return this._isLoop;\n    };\n    /**\n     * ループ時のフェードイン情報の設定\n     * @param loopFadeIn  ループ時のフェードイン情報\n     */\n    CubismMotion.prototype.setIsLoopFadeIn = function (loopFadeIn) {\n        this._isLoopFadeIn = loopFadeIn;\n    };\n    /**\n     * ループ時のフェードイン情報の取得\n     *\n     * @return  true    する\n     * @return  false   しない\n     */\n    CubismMotion.prototype.isLoopFadeIn = function () {\n        return this._isLoopFadeIn;\n    };\n    /**\n     * モーションの長さを取得する。\n     *\n     * @return  モーションの長さ[秒]\n     */\n    CubismMotion.prototype.getDuration = function () {\n        return this._isLoop ? -1.0 : this._loopDurationSeconds;\n    };\n    /**\n     * モーションのループ時の長さを取得する。\n     *\n     * @return  モーションのループ時の長さ[秒]\n     */\n    CubismMotion.prototype.getLoopDuration = function () {\n        return this._loopDurationSeconds;\n    };\n    /**\n     * パラメータに対するフェードインの時間を設定する。\n     *\n     * @param parameterId     パラメータID\n     * @param value           フェードインにかかる時間[秒]\n     */\n    CubismMotion.prototype.setParameterFadeInTime = function (parameterId, value) {\n        var curves = this._motionData.curves;\n        for (var i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                curves.at(i).fadeInTime = value;\n                return;\n            }\n        }\n    };\n    /**\n     * パラメータに対するフェードアウトの時間の設定\n     * @param parameterId     パラメータID\n     * @param value           フェードアウトにかかる時間[秒]\n     */\n    CubismMotion.prototype.setParameterFadeOutTime = function (parameterId, value) {\n        var curves = this._motionData.curves;\n        for (var i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                curves.at(i).fadeOutTime = value;\n                return;\n            }\n        }\n    };\n    /**\n     * パラメータに対するフェードインの時間の取得\n     * @param    parameterId     パラメータID\n     * @return   フェードインにかかる時間[秒]\n     */\n    CubismMotion.prototype.getParameterFadeInTime = function (parameterId) {\n        var curves = this._motionData.curves;\n        for (var i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                return curves.at(i).fadeInTime;\n            }\n        }\n        return -1;\n    };\n    /**\n     * パラメータに対するフェードアウトの時間を取得\n     *\n     * @param   parameterId     パラメータID\n     * @return   フェードアウトにかかる時間[秒]\n     */\n    CubismMotion.prototype.getParameterFadeOutTime = function (parameterId) {\n        var curves = this._motionData.curves;\n        for (var i = 0; i < this._motionData.curveCount; ++i) {\n            if (parameterId == curves.at(i).id) {\n                return curves.at(i).fadeOutTime;\n            }\n        }\n        return -1;\n    };\n    /**\n     * 自動エフェクトがかかっているパラメータIDリストの設定\n     * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト\n     * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト\n     */\n    CubismMotion.prototype.setEffectIds = function (eyeBlinkParameterIds, lipSyncParameterIds) {\n        this._eyeBlinkParameterIds = eyeBlinkParameterIds;\n        this._lipSyncParameterIds = lipSyncParameterIds;\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismMotion.prototype.release = function () {\n        this._motionData = void 0;\n        this._motionData = null;\n    };\n    /**\n     * motion3.jsonをパースする。\n     *\n     * @param motionJson  motion3.jsonが読み込まれているバッファ\n     * @param size        バッファのサイズ\n     */\n    CubismMotion.prototype.parse = function (motionJson, size) {\n        this._motionData = new _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionData();\n        var json = new _cubismmotionjson__WEBPACK_IMPORTED_MODULE_6__.CubismMotionJson(motionJson, size);\n        this._motionData.duration = json.getMotionDuration();\n        this._motionData.loop = json.isMotionLoop();\n        this._motionData.curveCount = json.getMotionCurveCount();\n        this._motionData.fps = json.getMotionFps();\n        this._motionData.eventCount = json.getEventCount();\n        var areBeziersRestructed = json.getEvaluationOptionFlag(_cubismmotionjson__WEBPACK_IMPORTED_MODULE_6__.EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);\n        if (json.isExistMotionFadeInTime()) {\n            this._fadeInSeconds =\n                json.getMotionFadeInTime() < 0.0 ? 1.0 : json.getMotionFadeInTime();\n        }\n        else {\n            this._fadeInSeconds = 1.0;\n        }\n        if (json.isExistMotionFadeOutTime()) {\n            this._fadeOutSeconds =\n                json.getMotionFadeOutTime() < 0.0 ? 1.0 : json.getMotionFadeOutTime();\n        }\n        else {\n            this._fadeOutSeconds = 1.0;\n        }\n        this._motionData.curves.updateSize(this._motionData.curveCount, _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurve, true);\n        this._motionData.segments.updateSize(json.getMotionTotalSegmentCount(), _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegment, true);\n        this._motionData.points.updateSize(json.getMotionTotalPointCount(), _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionPoint, true);\n        this._motionData.events.updateSize(this._motionData.eventCount, _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionEvent, true);\n        var totalPointCount = 0;\n        var totalSegmentCount = 0;\n        // Curves\n        for (var curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {\n            if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {\n                this._motionData.curves.at(curveCount).type =\n                    _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n            }\n            else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {\n                this._motionData.curves.at(curveCount).type =\n                    _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n            }\n            else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {\n                this._motionData.curves.at(curveCount).type =\n                    _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n            }\n            else {\n                (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_3__.CubismLogWarning)('Warning : Unable to get segment type from Curve! The number of \"CurveCount\" may be incorrect!');\n            }\n            this._motionData.curves.at(curveCount).id =\n                json.getMotionCurveId(curveCount);\n            this._motionData.curves.at(curveCount).baseSegmentIndex =\n                totalSegmentCount;\n            this._motionData.curves.at(curveCount).fadeInTime =\n                json.isExistMotionCurveFadeInTime(curveCount)\n                    ? json.getMotionCurveFadeInTime(curveCount)\n                    : -1.0;\n            this._motionData.curves.at(curveCount).fadeOutTime =\n                json.isExistMotionCurveFadeOutTime(curveCount)\n                    ? json.getMotionCurveFadeOutTime(curveCount)\n                    : -1.0;\n            // Segments\n            for (var segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount);) {\n                if (segmentPosition == 0) {\n                    this._motionData.segments.at(totalSegmentCount).basePointIndex =\n                        totalPointCount;\n                    this._motionData.points.at(totalPointCount).time =\n                        json.getMotionCurveSegment(curveCount, segmentPosition);\n                    this._motionData.points.at(totalPointCount).value =\n                        json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                    totalPointCount += 1;\n                    segmentPosition += 2;\n                }\n                else {\n                    this._motionData.segments.at(totalSegmentCount).basePointIndex =\n                        totalPointCount - 1;\n                }\n                var segment = json.getMotionCurveSegment(curveCount, segmentPosition);\n                switch (segment) {\n                    case _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Linear: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Linear;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            linearEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    case _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Bezier;\n                        if (areBeziersRestructed || UseOldBeziersCurveMotion) {\n                            this._motionData.segments.at(totalSegmentCount).evaluate =\n                                bezierEvaluate;\n                        }\n                        else {\n                            this._motionData.segments.at(totalSegmentCount).evaluate =\n                                bezierEvaluateCardanoInterpretation;\n                        }\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        this._motionData.points.at(totalPointCount + 1).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 3);\n                        this._motionData.points.at(totalPointCount + 1).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 4);\n                        this._motionData.points.at(totalPointCount + 2).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 5);\n                        this._motionData.points.at(totalPointCount + 2).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 6);\n                        totalPointCount += 3;\n                        segmentPosition += 7;\n                        break;\n                    }\n                    case _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_Stepped;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            steppedEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    case _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {\n                        this._motionData.segments.at(totalSegmentCount).segmentType =\n                            _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_5__.CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;\n                        this._motionData.segments.at(totalSegmentCount).evaluate =\n                            inverseSteppedEvaluate;\n                        this._motionData.points.at(totalPointCount).time =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 1);\n                        this._motionData.points.at(totalPointCount).value =\n                            json.getMotionCurveSegment(curveCount, segmentPosition + 2);\n                        totalPointCount += 1;\n                        segmentPosition += 3;\n                        break;\n                    }\n                    default: {\n                        (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_3__.CSM_ASSERT)(0);\n                        break;\n                    }\n                }\n                ++this._motionData.curves.at(curveCount).segmentCount;\n                ++totalSegmentCount;\n            }\n        }\n        for (var userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {\n            this._motionData.events.at(userdatacount).fireTime =\n                json.getEventTime(userdatacount);\n            this._motionData.events.at(userdatacount).value =\n                json.getEventValue(userdatacount);\n        }\n        json.release();\n        json = void 0;\n        json = null;\n    };\n    /**\n     * モデルのパラメータ更新\n     *\n     * イベント発火のチェック。\n     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。\n     *\n     * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]\n     * @param motionTimeSeconds        今回の再生時間[秒]\n     */\n    CubismMotion.prototype.getFiredEvent = function (beforeCheckTimeSeconds, motionTimeSeconds) {\n        this._firedEventValues.updateSize(0);\n        // イベントの発火チェック\n        for (var u = 0; u < this._motionData.eventCount; ++u) {\n            if (this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds &&\n                this._motionData.events.at(u).fireTime <= motionTimeSeconds) {\n                this._firedEventValues.pushBack(new _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString(this._motionData.events.at(u).value.s));\n            }\n        }\n        return this._firedEventValues;\n    };\n    return CubismMotion;\n}(_acubismmotion__WEBPACK_IMPORTED_MODULE_4__.ACubismMotion));\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotion = _cubismmotion__WEBPACK_IMPORTED_MODULE_7__.CubismMotion;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotion.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotioninternal.ts":
/*!*****************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotioninternal.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotionCurve\": () => (/* binding */ CubismMotionCurve),\n/* harmony export */   \"CubismMotionCurveTarget\": () => (/* binding */ CubismMotionCurveTarget),\n/* harmony export */   \"CubismMotionData\": () => (/* binding */ CubismMotionData),\n/* harmony export */   \"CubismMotionEvent\": () => (/* binding */ CubismMotionEvent),\n/* harmony export */   \"CubismMotionPoint\": () => (/* binding */ CubismMotionPoint),\n/* harmony export */   \"CubismMotionSegment\": () => (/* binding */ CubismMotionSegment),\n/* harmony export */   \"CubismMotionSegmentType\": () => (/* binding */ CubismMotionSegmentType),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmotioninternal */ \"./src/lib/live2d/Framework/motion/cubismmotioninternal.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * @brief モーションカーブの種類\n *\n * モーションカーブの種類。\n */\nvar CubismMotionCurveTarget;\n(function (CubismMotionCurveTarget) {\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_Model\"] = 0] = \"CubismMotionCurveTarget_Model\";\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_Parameter\"] = 1] = \"CubismMotionCurveTarget_Parameter\";\n    CubismMotionCurveTarget[CubismMotionCurveTarget[\"CubismMotionCurveTarget_PartOpacity\"] = 2] = \"CubismMotionCurveTarget_PartOpacity\";\n})(CubismMotionCurveTarget || (CubismMotionCurveTarget = {}));\n/**\n * @brief モーションカーブのセグメントの種類\n *\n * モーションカーブのセグメントの種類。\n */\nvar CubismMotionSegmentType;\n(function (CubismMotionSegmentType) {\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Linear\"] = 0] = \"CubismMotionSegmentType_Linear\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Bezier\"] = 1] = \"CubismMotionSegmentType_Bezier\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_Stepped\"] = 2] = \"CubismMotionSegmentType_Stepped\";\n    CubismMotionSegmentType[CubismMotionSegmentType[\"CubismMotionSegmentType_InverseStepped\"] = 3] = \"CubismMotionSegmentType_InverseStepped\";\n})(CubismMotionSegmentType || (CubismMotionSegmentType = {}));\n/**\n * @brief モーションカーブの制御点\n *\n * モーションカーブの制御点。\n */\nvar CubismMotionPoint = /** @class */ (function () {\n    function CubismMotionPoint() {\n        this.time = 0.0; // 時間[秒]\n        this.value = 0.0; // 値\n    }\n    return CubismMotionPoint;\n}());\n\n/**\n * @brief モーションカーブのセグメント\n *\n * モーションカーブのセグメント。\n */\nvar CubismMotionSegment = /** @class */ (function () {\n    /**\n     * @brief コンストラクタ\n     *\n     * コンストラクタ。\n     */\n    function CubismMotionSegment() {\n        this.evaluate = null;\n        this.basePointIndex = 0;\n        this.segmentType = 0;\n    }\n    return CubismMotionSegment;\n}());\n\n/**\n * @brief モーションカーブ\n *\n * モーションカーブ。\n */\nvar CubismMotionCurve = /** @class */ (function () {\n    function CubismMotionCurve() {\n        this.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n        this.segmentCount = 0;\n        this.baseSegmentIndex = 0;\n        this.fadeInTime = 0.0;\n        this.fadeOutTime = 0.0;\n    }\n    return CubismMotionCurve;\n}());\n\n/**\n * イベント。\n */\nvar CubismMotionEvent = /** @class */ (function () {\n    function CubismMotionEvent() {\n        this.fireTime = 0.0;\n    }\n    return CubismMotionEvent;\n}());\n\n/**\n * @brief モーションデータ\n *\n * モーションデータ。\n */\nvar CubismMotionData = /** @class */ (function () {\n    function CubismMotionData() {\n        this.duration = 0.0;\n        this.loop = false;\n        this.curveCount = 0;\n        this.eventCount = 0;\n        this.fps = 0.0;\n        this.curves = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        this.segments = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        this.points = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n        this.events = new _type_csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector();\n    }\n    return CubismMotionData;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionCurve = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionCurve;\n    Live2DCubismFramework.CubismMotionCurveTarget = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionCurveTarget;\n    Live2DCubismFramework.CubismMotionData = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionData;\n    Live2DCubismFramework.CubismMotionEvent = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionEvent;\n    Live2DCubismFramework.CubismMotionPoint = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionPoint;\n    Live2DCubismFramework.CubismMotionSegment = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionSegment;\n    Live2DCubismFramework.CubismMotionSegmentType = _cubismmotioninternal__WEBPACK_IMPORTED_MODULE_1__.CubismMotionSegmentType;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotioninternal.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotionjson.ts":
/*!*************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotionjson.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotionJson\": () => (/* binding */ CubismMotionJson),\n/* harmony export */   \"EvaluationOptionFlag\": () => (/* binding */ EvaluationOptionFlag),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmstring__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismmotionjson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubismmotionjson */ \"./src/lib/live2d/Framework/motion/cubismmotionjson.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n// JSON keys\nvar Meta = 'Meta';\nvar Duration = 'Duration';\nvar Loop = 'Loop';\nvar AreBeziersRestricted = 'AreBeziersRestricted';\nvar CurveCount = 'CurveCount';\nvar Fps = 'Fps';\nvar TotalSegmentCount = 'TotalSegmentCount';\nvar TotalPointCount = 'TotalPointCount';\nvar Curves = 'Curves';\nvar Target = 'Target';\nvar Id = 'Id';\nvar FadeInTime = 'FadeInTime';\nvar FadeOutTime = 'FadeOutTime';\nvar Segments = 'Segments';\nvar UserData = 'UserData';\nvar UserDataCount = 'UserDataCount';\nvar TotalUserDataSize = 'TotalUserDataSize';\nvar Time = 'Time';\nvar Value = 'Value';\n/**\n * motion3.jsonのコンテナ。\n */\nvar CubismMotionJson = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param buffer motion3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    function CubismMotionJson(buffer, size) {\n        this._json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismMotionJson.prototype.release = function () {\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson[\"delete\"](this._json);\n    };\n    /**\n     * モーションの長さを取得する\n     * @return モーションの長さ[秒]\n     */\n    CubismMotionJson.prototype.getMotionDuration = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Duration)\n            .toFloat();\n    };\n    /**\n     * モーションのループ情報の取得\n     * @return true ループする\n     * @return false ループしない\n     */\n    CubismMotionJson.prototype.isMotionLoop = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Loop)\n            .toBoolean();\n    };\n    CubismMotionJson.prototype.getEvaluationOptionFlag = function (flagType) {\n        if (EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted == flagType) {\n            return this._json\n                .getRoot()\n                .getValueByString(Meta)\n                .getValueByString(AreBeziersRestricted)\n                .toBoolean();\n        }\n        return false;\n    };\n    /**\n     * モーションカーブの個数の取得\n     * @return モーションカーブの個数\n     */\n    CubismMotionJson.prototype.getMotionCurveCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(CurveCount)\n            .toInt();\n    };\n    /**\n     * モーションのフレームレートの取得\n     * @return フレームレート[FPS]\n     */\n    CubismMotionJson.prototype.getMotionFps = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Fps)\n            .toFloat();\n    };\n    /**\n     * モーションのセグメントの総合計の取得\n     * @return モーションのセグメントの取得\n     */\n    CubismMotionJson.prototype.getMotionTotalSegmentCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalSegmentCount)\n            .toInt();\n    };\n    /**\n     * モーションのカーブの制御店の総合計の取得\n     * @return モーションのカーブの制御点の総合計\n     */\n    CubismMotionJson.prototype.getMotionTotalPointCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalPointCount)\n            .toInt();\n    };\n    /**\n     * モーションのフェードイン時間の存在\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    CubismMotionJson.prototype.isExistMotionFadeInTime = function () {\n        return !this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeInTime)\n            .isNull();\n    };\n    /**\n     * モーションのフェードアウト時間の存在\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    CubismMotionJson.prototype.isExistMotionFadeOutTime = function () {\n        return !this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeOutTime)\n            .isNull();\n    };\n    /**\n     * モーションのフェードイン時間の取得\n     * @return フェードイン時間[秒]\n     */\n    CubismMotionJson.prototype.getMotionFadeInTime = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    };\n    /**\n     * モーションのフェードアウト時間の取得\n     * @return フェードアウト時間[秒]\n     */\n    CubismMotionJson.prototype.getMotionFadeOutTime = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    };\n    /**\n     * モーションのカーブの種類の取得\n     * @param curveIndex カーブのインデックス\n     * @return カーブの種類\n     */\n    CubismMotionJson.prototype.getMotionCurveTarget = function (curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Target)\n            .getRawString();\n    };\n    /**\n     * モーションのカーブのIDの取得\n     * @param curveIndex カーブのインデックス\n     * @return カーブのID\n     */\n    CubismMotionJson.prototype.getMotionCurveId = function (curveIndex) {\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Id)\n            .getRawString());\n    };\n    /**\n     * モーションのカーブのフェードイン時間の存在\n     * @param curveIndex カーブのインデックス\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    CubismMotionJson.prototype.isExistMotionCurveFadeInTime = function (curveIndex) {\n        return !this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeInTime)\n            .isNull();\n    };\n    /**\n     * モーションのカーブのフェードアウト時間の存在\n     * @param curveIndex カーブのインデックス\n     * @return true 存在する\n     * @return false 存在しない\n     */\n    CubismMotionJson.prototype.isExistMotionCurveFadeOutTime = function (curveIndex) {\n        return !this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeOutTime)\n            .isNull();\n    };\n    /**\n     * モーションのカーブのフェードイン時間の取得\n     * @param curveIndex カーブのインデックス\n     * @return フェードイン時間[秒]\n     */\n    CubismMotionJson.prototype.getMotionCurveFadeInTime = function (curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeInTime)\n            .toFloat();\n    };\n    /**\n     * モーションのカーブのフェードアウト時間の取得\n     * @param curveIndex カーブのインデックス\n     * @return フェードアウト時間[秒]\n     */\n    CubismMotionJson.prototype.getMotionCurveFadeOutTime = function (curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(FadeOutTime)\n            .toFloat();\n    };\n    /**\n     * モーションのカーブのセグメントの個数を取得する\n     * @param curveIndex カーブのインデックス\n     * @return モーションのカーブのセグメントの個数\n     */\n    CubismMotionJson.prototype.getMotionCurveSegmentCount = function (curveIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Segments)\n            .getVector()\n            .getSize();\n    };\n    /**\n     * モーションのカーブのセグメントの値の取得\n     * @param curveIndex カーブのインデックス\n     * @param segmentIndex セグメントのインデックス\n     * @return セグメントの値\n     */\n    CubismMotionJson.prototype.getMotionCurveSegment = function (curveIndex, segmentIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(Curves)\n            .getValueByIndex(curveIndex)\n            .getValueByString(Segments)\n            .getValueByIndex(segmentIndex)\n            .toFloat();\n    };\n    /**\n     * イベントの個数の取得\n     * @return イベントの個数\n     */\n    CubismMotionJson.prototype.getEventCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(UserDataCount)\n            .toInt();\n    };\n    /**\n     *  イベントの総文字数の取得\n     * @return イベントの総文字数\n     */\n    CubismMotionJson.prototype.getTotalEventValueSize = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalUserDataSize)\n            .toInt();\n    };\n    /**\n     * イベントの時間の取得\n     * @param userDataIndex イベントのインデックス\n     * @return イベントの時間[秒]\n     */\n    CubismMotionJson.prototype.getEventTime = function (userDataIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(userDataIndex)\n            .getValueByString(Time)\n            .toFloat();\n    };\n    /**\n     * イベントの取得\n     * @param userDataIndex イベントのインデックス\n     * @return イベントの文字列\n     */\n    CubismMotionJson.prototype.getEventValue = function (userDataIndex) {\n        return new _type_csmstring__WEBPACK_IMPORTED_MODULE_1__.csmString(this._json\n            .getRoot()\n            .getValueByString(UserData)\n            .getValueByIndex(userDataIndex)\n            .getValueByString(Value)\n            .getRawString());\n    };\n    return CubismMotionJson;\n}());\n\n/**\n * @brief ベジェカーブの解釈方法のフラグタイプ\n */\nvar EvaluationOptionFlag;\n(function (EvaluationOptionFlag) {\n    EvaluationOptionFlag[EvaluationOptionFlag[\"EvaluationOptionFlag_AreBeziersRistricted\"] = 0] = \"EvaluationOptionFlag_AreBeziersRistricted\";\n})(EvaluationOptionFlag || (EvaluationOptionFlag = {}));\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionJson = _cubismmotionjson__WEBPACK_IMPORTED_MODULE_3__.CubismMotionJson;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotionjson.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotionmanager.ts":
/*!****************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotionmanager.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotionManager\": () => (/* binding */ CubismMotionManager),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmotionqueuemanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmotionqueuemanager */ \"./src/lib/live2d/Framework/motion/cubismmotionqueuemanager.ts\");\n/* harmony import */ var _cubismmotionmanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmotionmanager */ \"./src/lib/live2d/Framework/motion/cubismmotionmanager.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * モーションの管理\n *\n * モーションの管理を行うクラス\n */\nvar CubismMotionManager = /** @class */ (function (_super) {\n    __extends(CubismMotionManager, _super);\n    /**\n     * コンストラクタ\n     */\n    function CubismMotionManager() {\n        var _this = _super.call(this) || this;\n        _this._currentPriority = 0;\n        _this._reservePriority = 0;\n        return _this;\n    }\n    /**\n     * 再生中のモーションの優先度の取得\n     * @return  モーションの優先度\n     */\n    CubismMotionManager.prototype.getCurrentPriority = function () {\n        return this._currentPriority;\n    };\n    /**\n     * 予約中のモーションの優先度を取得する。\n     * @return  モーションの優先度\n     */\n    CubismMotionManager.prototype.getReservePriority = function () {\n        return this._reservePriority;\n    };\n    /**\n     * 予約中のモーションの優先度を設定する。\n     * @param   val     優先度\n     */\n    CubismMotionManager.prototype.setReservePriority = function (val) {\n        this._reservePriority = val;\n    };\n    /**\n     * 優先度を設定してモーションを開始する。\n     *\n     * @param motion          モーション\n     * @param autoDelete      再生が狩猟したモーションのインスタンスを削除するならtrue\n     * @param priority        優先度\n     * @return                開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n     */\n    CubismMotionManager.prototype.startMotionPriority = function (motion, autoDelete, priority) {\n        if (priority == this._reservePriority) {\n            this._reservePriority = 0; // 予約を解除\n        }\n        this._currentPriority = priority; // 再生中モーションの優先度を設定\n        return _super.prototype.startMotion.call(this, motion, autoDelete, this._userTimeSeconds);\n    };\n    /**\n     * モーションを更新して、モデルにパラメータ値を反映する。\n     *\n     * @param model   対象のモデル\n     * @param deltaTimeSeconds    デルタ時間[秒]\n     * @return  true    更新されている\n     * @return  false   更新されていない\n     */\n    CubismMotionManager.prototype.updateMotion = function (model, deltaTimeSeconds) {\n        this._userTimeSeconds += deltaTimeSeconds;\n        var updated = _super.prototype.doUpdateMotion.call(this, model, this._userTimeSeconds);\n        if (this.isFinished()) {\n            this._currentPriority = 0; // 再生中のモーションの優先度を解除\n        }\n        return updated;\n    };\n    /**\n     * モーションを予約する。\n     *\n     * @param   priority    優先度\n     * @return  true    予約できた\n     * @return  false   予約できなかった\n     */\n    CubismMotionManager.prototype.reserveMotion = function (priority) {\n        if (priority <= this._reservePriority ||\n            priority <= this._currentPriority) {\n            return false;\n        }\n        this._reservePriority = priority;\n        return true;\n    };\n    return CubismMotionManager;\n}(_cubismmotionqueuemanager__WEBPACK_IMPORTED_MODULE_0__.CubismMotionQueueManager));\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionManager = _cubismmotionmanager__WEBPACK_IMPORTED_MODULE_1__.CubismMotionManager;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotionmanager.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotionqueueentry.ts":
/*!*******************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotionqueueentry.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotionQueueEntry\": () => (/* binding */ CubismMotionQueueEntry),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _acubismmotion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./acubismmotion */ \"./src/lib/live2d/Framework/motion/acubismmotion.ts\");\n/* harmony import */ var _cubismmotionqueueentry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismmotionqueueentry */ \"./src/lib/live2d/Framework/motion/cubismmotionqueueentry.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * CubismMotionQueueManagerで再生している各モーションの管理クラス。\n */\nvar CubismMotionQueueEntry = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMotionQueueEntry() {\n        this._autoDelete = false;\n        this._motion = null;\n        this._available = true;\n        this._finished = false;\n        this._started = false;\n        this._startTimeSeconds = -1.0;\n        this._fadeInStartTimeSeconds = 0.0;\n        this._endTimeSeconds = -1.0;\n        this._stateTimeSeconds = 0.0;\n        this._stateWeight = 0.0;\n        this._lastEventCheckSeconds = 0.0;\n        this._motionQueueEntryHandle = this;\n        this._fadeOutSeconds = 0.0;\n        this._isTriggeredFadeOut = false;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismMotionQueueEntry.prototype.release = function () {\n        if (this._autoDelete && this._motion) {\n            _acubismmotion__WEBPACK_IMPORTED_MODULE_0__.ACubismMotion[\"delete\"](this._motion); //\n        }\n    };\n    /**\n     * フェードアウト時間と開始判定の設定\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     */\n    CubismMotionQueueEntry.prototype.setFadeOut = function (fadeOutSeconds) {\n        this._fadeOutSeconds = fadeOutSeconds;\n        this._isTriggeredFadeOut = true;\n    };\n    /**\n     * フェードアウトの開始\n     * @param fadeOutSeconds フェードアウトにかかる時間[秒]\n     * @param userTimeSeconds デルタ時間の積算値[秒]\n     */\n    CubismMotionQueueEntry.prototype.startFadeOut = function (fadeOutSeconds, userTimeSeconds) {\n        var newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;\n        this._isTriggeredFadeOut = true;\n        if (this._endTimeSeconds < 0.0 ||\n            newEndTimeSeconds < this._endTimeSeconds) {\n            this._endTimeSeconds = newEndTimeSeconds;\n        }\n    };\n    /**\n     * モーションの終了の確認\n     *\n     * @return true モーションが終了した\n     * @return false 終了していない\n     */\n    CubismMotionQueueEntry.prototype.isFinished = function () {\n        return this._finished;\n    };\n    /**\n     * モーションの開始の確認\n     * @return true モーションが開始した\n     * @return false 開始していない\n     */\n    CubismMotionQueueEntry.prototype.isStarted = function () {\n        return this._started;\n    };\n    /**\n     * モーションの開始時刻の取得\n     * @return モーションの開始時刻[秒]\n     */\n    CubismMotionQueueEntry.prototype.getStartTime = function () {\n        return this._startTimeSeconds;\n    };\n    /**\n     * フェードインの開始時刻の取得\n     * @return フェードインの開始時刻[秒]\n     */\n    CubismMotionQueueEntry.prototype.getFadeInStartTime = function () {\n        return this._fadeInStartTimeSeconds;\n    };\n    /**\n     * フェードインの終了時刻の取得\n     * @return フェードインの終了時刻の取得\n     */\n    CubismMotionQueueEntry.prototype.getEndTime = function () {\n        return this._endTimeSeconds;\n    };\n    /**\n     * モーションの開始時刻の設定\n     * @param startTime モーションの開始時刻\n     */\n    CubismMotionQueueEntry.prototype.setStartTime = function (startTime) {\n        this._startTimeSeconds = startTime;\n    };\n    /**\n     * フェードインの開始時刻の設定\n     * @param startTime フェードインの開始時刻[秒]\n     */\n    CubismMotionQueueEntry.prototype.setFadeInStartTime = function (startTime) {\n        this._fadeInStartTimeSeconds = startTime;\n    };\n    /**\n     * フェードインの終了時刻の設定\n     * @param endTime フェードインの終了時刻[秒]\n     */\n    CubismMotionQueueEntry.prototype.setEndTime = function (endTime) {\n        this._endTimeSeconds = endTime;\n    };\n    /**\n     * モーションの終了の設定\n     * @param f trueならモーションの終了\n     */\n    CubismMotionQueueEntry.prototype.setIsFinished = function (f) {\n        this._finished = f;\n    };\n    /**\n     * モーション開始の設定\n     * @param f trueならモーションの開始\n     */\n    CubismMotionQueueEntry.prototype.setIsStarted = function (f) {\n        this._started = f;\n    };\n    /**\n     * モーションの有効性の確認\n     * @return true モーションは有効\n     * @return false モーションは無効\n     */\n    CubismMotionQueueEntry.prototype.isAvailable = function () {\n        return this._available;\n    };\n    /**\n     * モーションの有効性の設定\n     * @param v trueならモーションは有効\n     */\n    CubismMotionQueueEntry.prototype.setIsAvailable = function (v) {\n        this._available = v;\n    };\n    /**\n     * モーションの状態の設定\n     * @param timeSeconds 現在時刻[秒]\n     * @param weight モーション尾重み\n     */\n    CubismMotionQueueEntry.prototype.setState = function (timeSeconds, weight) {\n        this._stateTimeSeconds = timeSeconds;\n        this._stateWeight = weight;\n    };\n    /**\n     * モーションの現在時刻の取得\n     * @return モーションの現在時刻[秒]\n     */\n    CubismMotionQueueEntry.prototype.getStateTime = function () {\n        return this._stateTimeSeconds;\n    };\n    /**\n     * モーションの重みの取得\n     * @return モーションの重み\n     */\n    CubismMotionQueueEntry.prototype.getStateWeight = function () {\n        return this._stateWeight;\n    };\n    /**\n     * 最後にイベントの発火をチェックした時間を取得\n     *\n     * @return 最後にイベントの発火をチェックした時間[秒]\n     */\n    CubismMotionQueueEntry.prototype.getLastCheckEventSeconds = function () {\n        return this._lastEventCheckSeconds;\n    };\n    /**\n     * 最後にイベントをチェックした時間を設定\n     * @param checkSeconds 最後にイベントをチェックした時間[秒]\n     */\n    CubismMotionQueueEntry.prototype.setLastCheckEventSeconds = function (checkSeconds) {\n        this._lastEventCheckSeconds = checkSeconds;\n    };\n    /**\n     * フェードアウト開始判定の取得\n     * @return フェードアウト開始するかどうか\n     */\n    CubismMotionQueueEntry.prototype.isTriggeredFadeOut = function () {\n        return this._isTriggeredFadeOut;\n    };\n    /**\n     * フェードアウト時間の取得\n     * @return フェードアウト時間[秒]\n     */\n    CubismMotionQueueEntry.prototype.getFadeOutSeconds = function () {\n        return this._fadeOutSeconds;\n    };\n    return CubismMotionQueueEntry;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionQueueEntry = _cubismmotionqueueentry__WEBPACK_IMPORTED_MODULE_1__.CubismMotionQueueEntry;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotionqueueentry.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/motion/cubismmotionqueuemanager.ts":
/*!*********************************************************************!*\
  !*** ./src/lib/live2d/Framework/motion/cubismmotionqueuemanager.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismMotionQueueManager\": () => (/* binding */ CubismMotionQueueManager),\n/* harmony export */   \"InvalidMotionQueueEntryHandleValue\": () => (/* binding */ InvalidMotionQueueEntryHandleValue),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismmotionqueueentry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismmotionqueueentry */ \"./src/lib/live2d/Framework/motion/cubismmotionqueueentry.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismmotionqueuemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismmotionqueuemanager */ \"./src/lib/live2d/Framework/motion/cubismmotionqueuemanager.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n/**\n * モーション再生の管理\n *\n * モーション再生の管理用クラス。CubismMotionモーションなどACubismMotionのサブクラスを再生するために使用する。\n *\n * @note 再生中に別のモーションが StartMotion()された場合は、新しいモーションに滑らかに変化し旧モーションは中断する。\n *       表情用モーション、体用モーションなどを分けてモーション化した場合など、\n *       複数のモーションを同時に再生させる場合は、複数のCubismMotionQueueManagerインスタンスを使用する。\n */\nvar CubismMotionQueueManager = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismMotionQueueManager() {\n        this._userTimeSeconds = 0.0;\n        this._eventCallBack = null;\n        this._eventCustomData = null;\n        this._motions = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n    }\n    /**\n     * デストラクタ\n     */\n    CubismMotionQueueManager.prototype.release = function () {\n        for (var i = 0; i < this._motions.getSize(); ++i) {\n            if (this._motions.at(i)) {\n                this._motions.at(i).release();\n                this._motions.set(i, null);\n            }\n        }\n        this._motions = null;\n    };\n    /**\n     * 指定したモーションの開始\n     *\n     * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。\n     *\n     * @param   motion          開始するモーション\n     * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true\n     * @param   userTimeSeconds デルタ時間の積算値[秒]\n     * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」\n     */\n    CubismMotionQueueManager.prototype.startMotion = function (motion, autoDelete, userTimeSeconds) {\n        if (motion == null) {\n            return InvalidMotionQueueEntryHandleValue;\n        }\n        var motionQueueEntry = null;\n        // 既にモーションがあれば終了フラグを立てる\n        for (var i = 0; i < this._motions.getSize(); ++i) {\n            motionQueueEntry = this._motions.at(i);\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime()); // フェードアウト設定\n        }\n        motionQueueEntry = new _cubismmotionqueueentry__WEBPACK_IMPORTED_MODULE_0__.CubismMotionQueueEntry(); // 終了時に破棄する\n        motionQueueEntry._autoDelete = autoDelete;\n        motionQueueEntry._motion = motion;\n        this._motions.pushBack(motionQueueEntry);\n        return motionQueueEntry._motionQueueEntryHandle;\n    };\n    /**\n     * 全てのモーションの終了の確認\n     * @return true 全て終了している\n     * @return false 終了していない\n     */\n    CubismMotionQueueManager.prototype.isFinished = function () {\n        // ------- 処理を行う -------\n        // 既にモーションがあれば終了フラグを立てる\n        for (var ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            var motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            var motion = motionQueueEntry._motion;\n            if (motion == null) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            // ----- 終了済みの処理があれば削除する ------\n            if (!motionQueueEntry.isFinished()) {\n                return false;\n            }\n            else {\n                ite.preIncrement();\n            }\n        }\n        return true;\n    };\n    /**\n     * 指定したモーションの終了の確認\n     * @param motionQueueEntryNumber モーションの識別番号\n     * @return true 全て終了している\n     * @return false 終了していない\n     */\n    CubismMotionQueueManager.prototype.isFinishedByHandle = function (motionQueueEntryNumber) {\n        for (var ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {\n            var motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber &&\n                !motionQueueEntry.isFinished()) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * 全てのモーションを停止する\n     */\n    CubismMotionQueueManager.prototype.stopAllMotions = function () {\n        // ------- 処理を行う -------\n        // 既にモーションがあれば終了フラグを立てる\n        for (var ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            var motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite);\n                continue;\n            }\n            // ----- 終了済みの処理があれば削除する ------\n            motionQueueEntry.release();\n            motionQueueEntry = null;\n            ite = this._motions.erase(ite); // 削除\n        }\n    };\n    /**\n         * 指定したCubismMotionQueueEntryの取得\n  \n          * @param   motionQueueEntryNumber  モーションの識別番号\n          * @return  指定したCubismMotionQueueEntry\n          * @return  null   見つからなかった\n          */\n    CubismMotionQueueManager.prototype.getCubismMotionQueueEntry = function (motionQueueEntryNumber) {\n        //------- 処理を行う -------\n        for (var ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {\n            var motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                continue;\n            }\n            if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {\n                return motionQueueEntry;\n            }\n        }\n        return null;\n    };\n    /**\n     * イベントを受け取るCallbackの登録\n     *\n     * @param callback コールバック関数\n     * @param customData コールバックに返されるデータ\n     */\n    CubismMotionQueueManager.prototype.setEventCallback = function (callback, customData) {\n        if (customData === void 0) { customData = null; }\n        this._eventCallBack = callback;\n        this._eventCustomData = customData;\n    };\n    /**\n     * モーションを更新して、モデルにパラメータ値を反映する。\n     *\n     * @param   model   対象のモデル\n     * @param   userTimeSeconds   デルタ時間の積算値[秒]\n     * @return  true    モデルへパラメータ値の反映あり\n     * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)\n     */\n    CubismMotionQueueManager.prototype.doUpdateMotion = function (model, userTimeSeconds) {\n        var updated = false;\n        // ------- 処理を行う --------\n        // 既にモーションがあれば終了フラグを立てる\n        for (var ite = this._motions.begin(); ite.notEqual(this._motions.end());) {\n            var motionQueueEntry = ite.ptr();\n            if (motionQueueEntry == null) {\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            var motion = motionQueueEntry._motion;\n            if (motion == null) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n                continue;\n            }\n            // ------ 値を反映する ------\n            motion.updateParameters(model, motionQueueEntry, userTimeSeconds);\n            updated = true;\n            // ------ ユーザトリガーイベントを検査する ----\n            var firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() -\n                motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());\n            for (var i = 0; i < firedList.getSize(); ++i) {\n                this._eventCallBack(this, firedList.at(i), this._eventCustomData);\n            }\n            motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);\n            // ------ 終了済みの処理があれば削除する ------\n            if (motionQueueEntry.isFinished()) {\n                motionQueueEntry.release();\n                motionQueueEntry = null;\n                ite = this._motions.erase(ite); // 削除\n            }\n            else {\n                if (motionQueueEntry.isTriggeredFadeOut()) {\n                    motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);\n                }\n                ite.preIncrement();\n            }\n        }\n        return updated;\n    };\n    return CubismMotionQueueManager;\n}());\n\nvar InvalidMotionQueueEntryHandleValue = -1;\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismMotionQueueManager = _cubismmotionqueuemanager__WEBPACK_IMPORTED_MODULE_2__.CubismMotionQueueManager;\n    Live2DCubismFramework.InvalidMotionQueueEntryHandleValue = _cubismmotionqueuemanager__WEBPACK_IMPORTED_MODULE_2__.InvalidMotionQueueEntryHandleValue;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/motion/cubismmotionqueuemanager.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/physics/cubismphysics.ts":
/*!***********************************************************!*\
  !*** ./src/lib/live2d/Framework/physics/cubismphysics.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismPhysics\": () => (/* binding */ CubismPhysics),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"Options\": () => (/* binding */ Options),\n/* harmony export */   \"PhysicsOutput\": () => (/* binding */ PhysicsOutput)\n/* harmony export */ });\n/* harmony import */ var _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/cubismmath */ \"./src/lib/live2d/Framework/math/cubismmath.ts\");\n/* harmony import */ var _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/cubismvector2 */ \"./src/lib/live2d/Framework/math/cubismvector2.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubismphysicsinternal */ \"./src/lib/live2d/Framework/physics/cubismphysicsinternal.ts\");\n/* harmony import */ var _cubismphysicsjson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cubismphysicsjson */ \"./src/lib/live2d/Framework/physics/cubismphysicsjson.ts\");\n/* harmony import */ var _cubismphysics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cubismphysics */ \"./src/lib/live2d/Framework/physics/cubismphysics.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n\n\n// physics types tags.\nvar PhysicsTypeTagX = 'X';\nvar PhysicsTypeTagY = 'Y';\nvar PhysicsTypeTagAngle = 'Angle';\n// Constant of air resistance.\nvar AirResistance = 5.0;\n// Constant of maximum weight of input and output ratio.\nvar MaximumWeight = 100.0;\n// Constant of threshold of movement.\nvar MovementThreshold = 0.001;\n// Constant of maximum allowed delta time\nvar MaxDeltaTime = 5.0;\n/**\n * 物理演算クラス\n */\nvar CubismPhysics = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismPhysics() {\n        this._physicsRig = null;\n        // set default options\n        this._options = new Options();\n        this._options.gravity.y = -1.0;\n        this._options.gravity.x = 0.0;\n        this._options.wind.x = 0.0;\n        this._options.wind.y = 0.0;\n        this._currentRigOutputs = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector();\n        this._previousRigOutputs = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector();\n        this._currentRemainTime = 0.0;\n        this._parameterCaches = null;\n        this._parameterInputCaches = null;\n    }\n    /**\n     * インスタンスの作成\n     * @param buffer    physics3.jsonが読み込まれているバッファ\n     * @param size      バッファのサイズ\n     * @return 作成されたインスタンス\n     */\n    CubismPhysics.create = function (buffer, size) {\n        var ret = new CubismPhysics();\n        ret.parse(buffer, size);\n        ret._physicsRig.gravity.y = 0;\n        return ret;\n    };\n    /**\n     * インスタンスを破棄する\n     * @param physics 破棄するインスタンス\n     */\n    CubismPhysics.delete = function (physics) {\n        if (physics != null) {\n            physics.release();\n            physics = null;\n        }\n    };\n    /**\n     * physics3.jsonをパースする。\n     * @param physicsJson physics3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    CubismPhysics.prototype.parse = function (physicsJson, size) {\n        this._physicsRig = new _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsRig();\n        var json = new _cubismphysicsjson__WEBPACK_IMPORTED_MODULE_4__.CubismPhysicsJson(physicsJson, size);\n        this._physicsRig.gravity = json.getGravity();\n        this._physicsRig.wind = json.getWind();\n        this._physicsRig.subRigCount = json.getSubRigCount();\n        this._physicsRig.fps = json.getFps();\n        this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSubRig, true);\n        this._physicsRig.inputs.updateSize(json.getTotalInputCount(), _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsInput, true);\n        this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsOutput, true);\n        this._physicsRig.particles.updateSize(json.getVertexCount(), _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsParticle, true);\n        this._currentRigOutputs.clear();\n        this._previousRigOutputs.clear();\n        var inputIndex = 0, outputIndex = 0, particleIndex = 0;\n        for (var i = 0; i < this._physicsRig.settings.getSize(); ++i) {\n            this._physicsRig.settings.at(i).normalizationPosition.minimum =\n                json.getNormalizationPositionMinimumValue(i);\n            this._physicsRig.settings.at(i).normalizationPosition.maximum =\n                json.getNormalizationPositionMaximumValue(i);\n            this._physicsRig.settings.at(i).normalizationPosition.defalut =\n                json.getNormalizationPositionDefaultValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.minimum =\n                json.getNormalizationAngleMinimumValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.maximum =\n                json.getNormalizationAngleMaximumValue(i);\n            this._physicsRig.settings.at(i).normalizationAngle.defalut =\n                json.getNormalizationAngleDefaultValue(i);\n            // Input\n            this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);\n            this._physicsRig.settings.at(i).baseInputIndex = inputIndex;\n            for (var j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {\n                this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;\n                this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);\n                this._physicsRig.inputs.at(inputIndex + j).reflect =\n                    json.getInputReflect(i, j);\n                if (json.getInputType(i, j) == PhysicsTypeTagX) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_X;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;\n                }\n                else if (json.getInputType(i, j) == PhysicsTypeTagY) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_Y;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;\n                }\n                else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {\n                    this._physicsRig.inputs.at(inputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_Angle;\n                    this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;\n                }\n                this._physicsRig.inputs.at(inputIndex + j).source.targetType =\n                    _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n                this._physicsRig.inputs.at(inputIndex + j).source.id =\n                    json.getInputSourceId(i, j);\n            }\n            inputIndex += this._physicsRig.settings.at(i).inputCount;\n            // Output\n            this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);\n            this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;\n            var currentRigOutput = new PhysicsOutput();\n            currentRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n            var previousRigOutput = new PhysicsOutput();\n            previousRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);\n            for (var j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {\n                // initialize\n                currentRigOutput.outputs[j] = 0.0;\n                previousRigOutput.outputs[j] = 0.0;\n                this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex =\n                    -1;\n                this._physicsRig.outputs.at(outputIndex + j).vertexIndex =\n                    json.getOutputVertexIndex(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).angleScale =\n                    json.getOutputAngleScale(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).weight =\n                    json.getOutputWeight(i, j);\n                this._physicsRig.outputs.at(outputIndex + j).destination.targetType =\n                    _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n                this._physicsRig.outputs.at(outputIndex + j).destination.id =\n                    json.getOutputDestinationId(i, j);\n                if (json.getOutputType(i, j) == PhysicsTypeTagX) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_X;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputTranslationX;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleTranslationX;\n                }\n                else if (json.getOutputType(i, j) == PhysicsTypeTagY) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_Y;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputTranslationY;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleTranslationY;\n                }\n                else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {\n                    this._physicsRig.outputs.at(outputIndex + j).type =\n                        _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsSource.CubismPhysicsSource_Angle;\n                    this._physicsRig.outputs.at(outputIndex + j).getValue =\n                        getOutputAngle;\n                    this._physicsRig.outputs.at(outputIndex + j).getScale =\n                        getOutputScaleAngle;\n                }\n                this._physicsRig.outputs.at(outputIndex + j).reflect =\n                    json.getOutputReflect(i, j);\n            }\n            this._currentRigOutputs.pushBack(currentRigOutput);\n            this._previousRigOutputs.pushBack(previousRigOutput);\n            outputIndex += this._physicsRig.settings.at(i).outputCount;\n            // Particle\n            this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);\n            this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;\n            for (var j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {\n                this._physicsRig.particles.at(particleIndex + j).mobility =\n                    json.getParticleMobility(i, j);\n                this._physicsRig.particles.at(particleIndex + j).delay =\n                    json.getParticleDelay(i, j);\n                this._physicsRig.particles.at(particleIndex + j).acceleration =\n                    json.getParticleAcceleration(i, j);\n                this._physicsRig.particles.at(particleIndex + j).radius =\n                    json.getParticleRadius(i, j);\n                this._physicsRig.particles.at(particleIndex + j).position =\n                    json.getParticlePosition(i, j);\n            }\n            particleIndex += this._physicsRig.settings.at(i).particleCount;\n        }\n        this.initialize();\n        json.release();\n        json = void 0;\n        json = null;\n    };\n    /**\n     * 現在のパラメータ値で物理演算が安定化する状態を演算する。\n     * @param model 物理演算の結果を適用するモデル\n     */\n    CubismPhysics.prototype.stabilization = function (model) {\n        var _a, _b, _c, _d;\n        var totalAngle;\n        var weight;\n        var radAngle;\n        var outputValue;\n        var totalTranslation = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2();\n        var currentSetting;\n        var currentInputs;\n        var currentOutputs;\n        var currentParticles;\n        var parameterValues;\n        var parameterMaximumValues;\n        var parameterMinimumValues;\n        var parameterDefaultValues;\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        parameterDefaultValues = model.getModel().parameters.defaultValues;\n        if (((_b = (_a = this._parameterCaches) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) < model.getParameterCount()) {\n            this._parameterCaches = new Float32Array(model.getParameterCount());\n        }\n        if (((_d = (_c = this._parameterInputCaches) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < model.getParameterCount()) {\n            this._parameterInputCaches = new Float32Array(model.getParameterCount());\n        }\n        for (var j = 0; j < model.getParameterCount(); ++j) {\n            this._parameterCaches[j] = parameterValues[j];\n            this._parameterInputCaches[j] = parameterValues[j];\n        }\n        for (var settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            totalAngle = { angle: 0.0 };\n            totalTranslation.x = 0.0;\n            totalTranslation.y = 0.0;\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n            currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n            currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n            // Load input parameters\n            for (var i = 0; i < currentSetting.inputCount; ++i) {\n                weight = currentInputs[i].weight / MaximumWeight;\n                if (currentInputs[i].sourceParameterIndex == -1) {\n                    currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n                }\n                currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValues[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n                this._parameterCaches[currentInputs[i].sourceParameterIndex] =\n                    parameterValues[currentInputs[i].sourceParameterIndex];\n            }\n            radAngle = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.degreesToRadian(-totalAngle.angle);\n            totalTranslation.x =\n                totalTranslation.x * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radAngle) -\n                    totalTranslation.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radAngle);\n            totalTranslation.y =\n                totalTranslation.x * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radAngle) +\n                    totalTranslation.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radAngle);\n            // Calculate particles position.\n            updateParticlesForStabilization(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum);\n            // Update output parameters.\n            for (var i = 0; i < currentSetting.outputCount; ++i) {\n                var particleIndex = currentOutputs[i].vertexIndex;\n                if (currentOutputs[i].destinationParameterIndex == -1) {\n                    currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);\n                }\n                if (particleIndex < 1 ||\n                    particleIndex >= currentSetting.particleCount) {\n                    continue;\n                }\n                var translation = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2();\n                translation = currentParticles[particleIndex].position.substract(currentParticles[particleIndex - 1].position);\n                outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n                this._currentRigOutputs.at(settingIndex).outputs[i] = outputValue;\n                this._previousRigOutputs.at(settingIndex).outputs[i] = outputValue;\n                var destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                var outParameterCaches = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n                    ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                    : parameterValues.slice(destinationParameterIndex);\n                updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n                // 値を反映\n                for (var offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n                    parameterValues[offset] = this._parameterCaches[offset] =\n                        outParameterCaches[outParamIndex];\n                }\n            }\n        }\n    };\n    /**\n     * 物理演算の評価\n     *\n     * Pendulum interpolation weights\n     *\n     * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。\n     * The result of the pendulum calculation is saved and\n     * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.\n     *\n     * 図で示すと[1]と[2]で補間されます。\n     * The figure shows the interpolation between [1] and [2].\n     *\n     * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。\n     * The weight of the interpolation are determined by the current time seen between\n     * the latest pendulum calculation timing and the next timing.\n     *\n     * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。\n     * Figure shows the weight of position (3) as seen between [2] and [4].\n     *\n     * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。\n     * As an interpretation, the pendulum calculation and weights are misaligned.\n     *\n     * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。\n     * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.\n     *\n     * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。\n     * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.\n     *\n     * ------------ time -------------->\n     *\n     *                 |+++++|------| <- weight\n     * ==[1]====#=====[2]---(3)----(4)\n     *          ^ output contents\n     *\n     * 1:_previousRigOutputs\n     * 2:_currentRigOutputs\n     * 3:_currentRemainTime (now rendering)\n     * 4:next particles timing\n     * @param model 物理演算の結果を適用するモデル\n     * @param deltaTimeSeconds デルタ時間[秒]\n     */\n    CubismPhysics.prototype.evaluate = function (model, deltaTimeSeconds) {\n        var _a, _b, _c, _d;\n        var totalAngle;\n        var weight;\n        var radAngle;\n        var outputValue;\n        var totalTranslation = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2();\n        var currentSetting;\n        var currentInputs;\n        var currentOutputs;\n        var currentParticles;\n        if (0.0 >= deltaTimeSeconds) {\n            return;\n        }\n        var parameterValues;\n        var parameterMaximumValues;\n        var parameterMinimumValues;\n        var parameterDefaultValues;\n        var physicsDeltaTime;\n        this._currentRemainTime += deltaTimeSeconds;\n        if (this._currentRemainTime > MaxDeltaTime) {\n            this._currentRemainTime = 0.0;\n        }\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        parameterDefaultValues = model.getModel().parameters.defaultValues;\n        if (((_b = (_a = this._parameterCaches) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) < model.getParameterCount()) {\n            this._parameterCaches = new Float32Array(model.getParameterCount());\n        }\n        if (((_d = (_c = this._parameterInputCaches) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < model.getParameterCount()) {\n            this._parameterInputCaches = new Float32Array(model.getParameterCount());\n            for (var j = 0; j < model.getParameterCount(); ++j) {\n                this._parameterInputCaches[j] = parameterValues[j];\n            }\n        }\n        if (this._physicsRig.fps > 0.0) {\n            physicsDeltaTime = 1.0 / this._physicsRig.fps;\n        }\n        else {\n            physicsDeltaTime = deltaTimeSeconds;\n        }\n        while (this._currentRemainTime >= physicsDeltaTime) {\n            // copyRigOutputs _currentRigOutputs to _previousRigOutputs\n            for (var settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n                currentSetting = this._physicsRig.settings.at(settingIndex);\n                currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n                for (var i = 0; i < currentSetting.outputCount; ++i) {\n                    this._previousRigOutputs.at(settingIndex).outputs[i] =\n                        this._currentRigOutputs.at(settingIndex).outputs[i];\n                }\n            }\n            // 入力キャッシュとパラメータで線形補間してUpdateParticlesするタイミングでの入力を計算する。\n            // Calculate the input at the timing to UpdateParticles by linear interpolation with the _parameterInputCache and parameterValue.\n            // _parameterCacheはグループ間での値の伝搬の役割があるので_parameterInputCacheとの分離が必要。\n            // _parameterCache needs to be separated from _parameterInputCache because of its role in propagating values between groups.\n            var inputWeight = physicsDeltaTime / this._currentRemainTime;\n            for (var j = 0; j < model.getParameterCount(); ++j) {\n                this._parameterCaches[j] =\n                    this._parameterInputCaches[j] * (1.0 - inputWeight) +\n                        parameterValues[j] * inputWeight;\n                this._parameterInputCaches[j] = this._parameterCaches[j];\n            }\n            for (var settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n                totalAngle = { angle: 0.0 };\n                totalTranslation.x = 0.0;\n                totalTranslation.y = 0.0;\n                currentSetting = this._physicsRig.settings.at(settingIndex);\n                currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);\n                currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n                currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n                // Load input parameters\n                for (var i = 0; i < currentSetting.inputCount; ++i) {\n                    weight = currentInputs[i].weight / MaximumWeight;\n                    if (currentInputs[i].sourceParameterIndex == -1) {\n                        currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);\n                    }\n                    currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, this._parameterCaches[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);\n                }\n                radAngle = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.degreesToRadian(-totalAngle.angle);\n                totalTranslation.x =\n                    totalTranslation.x * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radAngle) -\n                        totalTranslation.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radAngle);\n                totalTranslation.y =\n                    totalTranslation.x * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radAngle) +\n                        totalTranslation.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radAngle);\n                // Calculate particles position.\n                updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, physicsDeltaTime, AirResistance);\n                // Update output parameters.\n                for (var i = 0; i < currentSetting.outputCount; ++i) {\n                    var particleIndex = currentOutputs[i].vertexIndex;\n                    if (currentOutputs[i].destinationParameterIndex == -1) {\n                        currentOutputs[i].destinationParameterIndex =\n                            model.getParameterIndex(currentOutputs[i].destination.id);\n                    }\n                    if (particleIndex < 1 ||\n                        particleIndex >= currentSetting.particleCount) {\n                        continue;\n                    }\n                    var translation = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2();\n                    translation.x =\n                        currentParticles[particleIndex].position.x -\n                            currentParticles[particleIndex - 1].position.x;\n                    translation.y =\n                        currentParticles[particleIndex].position.y -\n                            currentParticles[particleIndex - 1].position.y;\n                    outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);\n                    this._currentRigOutputs.at(settingIndex).outputs[i] = outputValue;\n                    var destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                    var outParameterCaches = !Float32Array.prototype.slice &&\n                        'subarray' in Float32Array.prototype\n                        ? JSON.parse(JSON.stringify(this._parameterCaches.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                        : this._parameterCaches.slice(destinationParameterIndex);\n                    updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);\n                    // 値を反映\n                    for (var offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {\n                        this._parameterCaches[offset] = outParameterCaches[outParamIndex];\n                    }\n                }\n            }\n            this._currentRemainTime -= physicsDeltaTime;\n        }\n        var alpha = this._currentRemainTime / physicsDeltaTime;\n        this.interpolate(model, alpha);\n    };\n    /**\n     * 物理演算結果の適用\n     * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。\n     * @param model 物理演算の結果を適用するモデル\n     * @param weight 最新結果の重み\n     */\n    CubismPhysics.prototype.interpolate = function (model, weight) {\n        var currentOutputs;\n        var currentSetting;\n        var parameterValues;\n        var parameterMaximumValues;\n        var parameterMinimumValues;\n        parameterValues = model.getModel().parameters.values;\n        parameterMaximumValues = model.getModel().parameters.maximumValues;\n        parameterMinimumValues = model.getModel().parameters.minimumValues;\n        for (var settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);\n            // Load input parameters.\n            for (var i = 0; i < currentSetting.outputCount; ++i) {\n                if (currentOutputs[i].destinationParameterIndex == -1) {\n                    continue;\n                }\n                var destinationParameterIndex = currentOutputs[i].destinationParameterIndex;\n                var outParameterValues = !Float32Array.prototype.slice && 'subarray' in Float32Array.prototype\n                    ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) // 値渡しするため、JSON.parse, JSON.stringify\n                    : parameterValues.slice(destinationParameterIndex);\n                updateOutputParameterValue(outParameterValues, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], this._previousRigOutputs.at(settingIndex).outputs[i] * (1 - weight) +\n                    this._currentRigOutputs.at(settingIndex).outputs[i] * weight, currentOutputs[i]);\n                // 値を反映\n                for (var offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValues.length; offset++, outParamIndex++) {\n                    parameterValues[offset] = outParameterValues[outParamIndex];\n                }\n            }\n        }\n    };\n    /**\n     * オプションの設定\n     * @param options オプション\n     */\n    CubismPhysics.prototype.setOptions = function (options) {\n        this._options = options;\n    };\n    /**\n     * オプションの取得\n     * @return オプション\n     */\n    CubismPhysics.prototype.getOption = function () {\n        return this._options;\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismPhysics.prototype.release = function () {\n        this._physicsRig = void 0;\n        this._physicsRig = null;\n    };\n    /**\n     * 初期化する\n     */\n    CubismPhysics.prototype.initialize = function () {\n        var strand;\n        var currentSetting;\n        var radius;\n        for (var settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n            currentSetting = this._physicsRig.settings.at(settingIndex);\n            strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);\n            // Initialize the top of particle.\n            strand[0].initialPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n            strand[0].lastPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);\n            strand[0].lastGravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, -1.0);\n            strand[0].lastGravity.y *= -1.0;\n            strand[0].velocity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n            strand[0].force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n            // Initialize particles.\n            for (var i = 1; i < currentSetting.particleCount; ++i) {\n                radius = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n                radius.y = strand[i].radius;\n                strand[i].initialPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);\n                strand[i].position = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n                strand[i].lastPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n                strand[i].lastGravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, -1.0);\n                strand[i].lastGravity.y *= -1.0;\n                strand[i].velocity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n                strand[i].force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n            }\n        }\n    };\n    return CubismPhysics;\n}());\n\n/**\n * 物理演算のオプション\n */\nvar Options = /** @class */ (function () {\n    function Options() {\n        this.gravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0, 0);\n        this.wind = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0, 0);\n    }\n    return Options;\n}());\n\n/**\n * パラメータに適用する前の物理演算の出力結果\n */\nvar PhysicsOutput = /** @class */ (function () {\n    function PhysicsOutput() {\n        this.outputs = new _type_csmvector__WEBPACK_IMPORTED_MODULE_2__.csmVector(0);\n    }\n    return PhysicsOutput;\n}());\n\n/**\n * Gets sign.\n *\n * @param value Evaluation target value.\n *\n * @return Sign of value.\n */\nfunction sign(value) {\n    var ret = 0;\n    if (value > 0.0) {\n        ret = 1;\n    }\n    else if (value < 0.0) {\n        ret = -1;\n    }\n    return ret;\n}\nfunction getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.x +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n    targetTranslation.y +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {\n    targetAngle.angle +=\n        normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;\n}\nfunction getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {\n    var outputValue = translation.x;\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {\n    var outputValue = translation.y;\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {\n    var outputValue;\n    if (particleIndex >= 2) {\n        parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);\n    }\n    else {\n        parentGravity = parentGravity.multiplyByScaler(-1.0);\n    }\n    outputValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.directionToRadian(parentGravity, translation);\n    if (isInverted) {\n        outputValue *= -1.0;\n    }\n    return outputValue;\n}\nfunction getRangeValue(min, max) {\n    var maxValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.max(min, max);\n    var minValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.min(min, max);\n    return _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.abs(maxValue - minValue);\n}\nfunction getDefaultValue(min, max) {\n    var minValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.min(min, max);\n    return minValue + getRangeValue(min, max) / 2.0;\n}\nfunction getOutputScaleTranslationX(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.x));\n}\nfunction getOutputScaleTranslationY(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(translationScale.y));\n}\nfunction getOutputScaleAngle(translationScale, angleScale) {\n    return JSON.parse(JSON.stringify(angleScale));\n}\n/**\n * Updates particles.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n * @param deltaTimeSeconds      Delta time.\n * @param airResistance         Air resistance.\n */\nfunction updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {\n    var totalRadian;\n    var delay;\n    var radian;\n    var currentGravity;\n    var direction = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n    var velocity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n    var force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n    var newDirection = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n    strand[0].position = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(totalTranslation.x, totalTranslation.y);\n    totalRadian = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.degreesToRadian(totalAngle);\n    currentGravity = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.radianToDirection(totalRadian);\n    currentGravity.normalize();\n    for (var i = 1; i < strandCount; ++i) {\n        strand[i].force = currentGravity\n            .multiplyByScaler(strand[i].acceleration)\n            .add(windDirection);\n        strand[i].lastPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[i].position.x, strand[i].position.y);\n        delay = strand[i].delay * deltaTimeSeconds * 30.0;\n        direction = strand[i].position.substract(strand[i - 1].position);\n        radian =\n            _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) /\n                airResistance;\n        direction.x =\n            _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radian) * direction.x -\n                direction.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radian);\n        direction.y =\n            _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.sin(radian) * direction.x +\n                direction.y * _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.cos(radian);\n        strand[i].position = strand[i - 1].position.add(direction);\n        velocity = strand[i].velocity.multiplyByScaler(delay);\n        force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n        strand[i].position = strand[i].position.add(velocity).add(force);\n        newDirection = strand[i].position.substract(strand[i - 1].position);\n        newDirection.normalize();\n        strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));\n        if (_math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.abs(strand[i].position.x) < thresholdValue) {\n            strand[i].position.x = 0.0;\n        }\n        if (delay != 0.0) {\n            strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n            strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n            strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);\n        }\n        strand[i].force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n        strand[i].lastGravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(currentGravity.x, currentGravity.y);\n    }\n}\n/**\n * Updates particles for stabilization.\n *\n * @param strand                Target array of particle.\n * @param strandCount           Count of particle.\n * @param totalTranslation      Total translation value.\n * @param totalAngle            Total angle.\n * @param windDirection         Direction of Wind.\n * @param thresholdValue        Threshold of movement.\n */\nfunction updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {\n    var totalRadian;\n    var currentGravity;\n    var force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n    strand[0].position = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(totalTranslation.x, totalTranslation.y);\n    totalRadian = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.degreesToRadian(totalAngle);\n    currentGravity = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.radianToDirection(totalRadian);\n    currentGravity.normalize();\n    for (var i = 1; i < strandCount; ++i) {\n        strand[i].force = currentGravity\n            .multiplyByScaler(strand[i].acceleration)\n            .add(windDirection);\n        strand[i].lastPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(strand[i].position.x, strand[i].position.y);\n        strand[i].velocity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n        force = strand[i].force;\n        force.normalize();\n        force = force.multiplyByScaler(strand[i].radius);\n        strand[i].position = strand[i - 1].position.add(force);\n        if (_math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.abs(strand[i].position.x) < thresholdValue) {\n            strand[i].position.x = 0.0;\n        }\n        strand[i].force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0.0, 0.0);\n        strand[i].lastGravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(currentGravity.x, currentGravity.y);\n    }\n}\n/**\n * Updates output parameter value.\n * @param parameterValue            Target parameter value.\n * @param parameterValueMinimum     Minimum of parameter value.\n * @param parameterValueMaximum     Maximum of parameter value.\n * @param translation               Translation value.\n */\nfunction updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {\n    var outputScale;\n    var value;\n    var weight;\n    outputScale = output.getScale(output.translationScale, output.angleScale);\n    value = translation * outputScale;\n    if (value < parameterValueMinimum) {\n        if (value < output.valueBelowMinimum) {\n            output.valueBelowMinimum = value;\n        }\n        value = parameterValueMinimum;\n    }\n    else if (value > parameterValueMaximum) {\n        if (value > output.valueExceededMaximum) {\n            output.valueExceededMaximum = value;\n        }\n        value = parameterValueMaximum;\n    }\n    weight = output.weight / MaximumWeight;\n    if (weight >= 1.0) {\n        parameterValue[0] = value;\n    }\n    else {\n        value = parameterValue[0] * (1.0 - weight) + value * weight;\n        parameterValue[0] = value;\n    }\n}\nfunction normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {\n    var result = 0.0;\n    var maxValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.max(parameterMaximum, parameterMinimum);\n    if (maxValue < value) {\n        value = maxValue;\n    }\n    var minValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.min(parameterMaximum, parameterMinimum);\n    if (minValue > value) {\n        value = minValue;\n    }\n    var minNormValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.min(normalizedMinimum, normalizedMaximum);\n    var maxNormValue = _math_cubismmath__WEBPACK_IMPORTED_MODULE_0__.CubismMath.max(normalizedMinimum, normalizedMaximum);\n    var middleNormValue = normalizedDefault;\n    var middleValue = getDefaultValue(minValue, maxValue);\n    var paramValue = value - middleValue;\n    switch (sign(paramValue)) {\n        case 1: {\n            var nLength = maxNormValue - middleNormValue;\n            var pLength = maxValue - middleValue;\n            if (pLength != 0.0) {\n                result = paramValue * (nLength / pLength);\n                result += middleNormValue;\n            }\n            break;\n        }\n        case -1: {\n            var nLength = minNormValue - middleNormValue;\n            var pLength = minValue - middleValue;\n            if (pLength != 0.0) {\n                result = paramValue * (nLength / pLength);\n                result += middleNormValue;\n            }\n            break;\n        }\n        case 0: {\n            result = middleNormValue;\n            break;\n        }\n        default: {\n            break;\n        }\n    }\n    return isInverted ? result : result * -1.0;\n}\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysics = _cubismphysics__WEBPACK_IMPORTED_MODULE_5__.CubismPhysics;\n    Live2DCubismFramework.Options = _cubismphysics__WEBPACK_IMPORTED_MODULE_5__.Options;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/physics/cubismphysics.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/physics/cubismphysicsinternal.ts":
/*!*******************************************************************!*\
  !*** ./src/lib/live2d/Framework/physics/cubismphysicsinternal.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismPhysicsInput\": () => (/* binding */ CubismPhysicsInput),\n/* harmony export */   \"CubismPhysicsNormalization\": () => (/* binding */ CubismPhysicsNormalization),\n/* harmony export */   \"CubismPhysicsOutput\": () => (/* binding */ CubismPhysicsOutput),\n/* harmony export */   \"CubismPhysicsParameter\": () => (/* binding */ CubismPhysicsParameter),\n/* harmony export */   \"CubismPhysicsParticle\": () => (/* binding */ CubismPhysicsParticle),\n/* harmony export */   \"CubismPhysicsRig\": () => (/* binding */ CubismPhysicsRig),\n/* harmony export */   \"CubismPhysicsSource\": () => (/* binding */ CubismPhysicsSource),\n/* harmony export */   \"CubismPhysicsSubRig\": () => (/* binding */ CubismPhysicsSubRig),\n/* harmony export */   \"CubismPhysicsTargetType\": () => (/* binding */ CubismPhysicsTargetType),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"PhysicsJsonEffectiveForces\": () => (/* binding */ PhysicsJsonEffectiveForces)\n/* harmony export */ });\n/* harmony import */ var _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/cubismvector2 */ \"./src/lib/live2d/Framework/math/cubismvector2.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismphysicsinternal */ \"./src/lib/live2d/Framework/physics/cubismphysicsinternal.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n/**\n * 物理演算の適用先の種類\n */\nvar CubismPhysicsTargetType;\n(function (CubismPhysicsTargetType) {\n    CubismPhysicsTargetType[CubismPhysicsTargetType[\"CubismPhysicsTargetType_Parameter\"] = 0] = \"CubismPhysicsTargetType_Parameter\";\n})(CubismPhysicsTargetType || (CubismPhysicsTargetType = {}));\n/**\n * 物理演算の入力の種類\n */\nvar CubismPhysicsSource;\n(function (CubismPhysicsSource) {\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_X\"] = 0] = \"CubismPhysicsSource_X\";\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_Y\"] = 1] = \"CubismPhysicsSource_Y\";\n    CubismPhysicsSource[CubismPhysicsSource[\"CubismPhysicsSource_Angle\"] = 2] = \"CubismPhysicsSource_Angle\";\n})(CubismPhysicsSource || (CubismPhysicsSource = {}));\n/**\n * @brief 物理演算で使用する外部の力\n *\n * 物理演算で使用する外部の力。\n */\nvar PhysicsJsonEffectiveForces = /** @class */ (function () {\n    function PhysicsJsonEffectiveForces() {\n        this.gravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.wind = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n    }\n    return PhysicsJsonEffectiveForces;\n}());\n\n/**\n * 物理演算のパラメータ情報\n */\nvar CubismPhysicsParameter = /** @class */ (function () {\n    function CubismPhysicsParameter() {\n    }\n    return CubismPhysicsParameter;\n}());\n\n/**\n * 物理演算の正規化情報\n */\nvar CubismPhysicsNormalization = /** @class */ (function () {\n    function CubismPhysicsNormalization() {\n    }\n    return CubismPhysicsNormalization;\n}());\n\n/**\n * 物理演算の演算委使用する物理点の情報\n */\nvar CubismPhysicsParticle = /** @class */ (function () {\n    function CubismPhysicsParticle() {\n        this.initialPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.position = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.lastPosition = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.lastGravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.force = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.velocity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n    }\n    return CubismPhysicsParticle;\n}());\n\n/**\n * 物理演算の物理点の管理\n */\nvar CubismPhysicsSubRig = /** @class */ (function () {\n    function CubismPhysicsSubRig() {\n        this.normalizationPosition = new CubismPhysicsNormalization();\n        this.normalizationAngle = new CubismPhysicsNormalization();\n    }\n    return CubismPhysicsSubRig;\n}());\n\n/**\n * 物理演算の入力情報\n */\nvar CubismPhysicsInput = /** @class */ (function () {\n    function CubismPhysicsInput() {\n        this.source = new CubismPhysicsParameter();\n    }\n    return CubismPhysicsInput;\n}());\n\n/**\n * @brief 物理演算の出力情報\n *\n * 物理演算の出力情報。\n */\nvar CubismPhysicsOutput = /** @class */ (function () {\n    function CubismPhysicsOutput() {\n        this.destination = new CubismPhysicsParameter();\n        this.translationScale = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n    }\n    return CubismPhysicsOutput;\n}());\n\n/**\n * @brief 物理演算のデータ\n *\n * 物理演算のデータ。\n */\nvar CubismPhysicsRig = /** @class */ (function () {\n    function CubismPhysicsRig() {\n        this.settings = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        this.inputs = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        this.outputs = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        this.particles = new _type_csmvector__WEBPACK_IMPORTED_MODULE_1__.csmVector();\n        this.gravity = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.wind = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_0__.CubismVector2(0, 0);\n        this.fps = 0.0;\n    }\n    return CubismPhysicsRig;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysicsInput = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsInput;\n    Live2DCubismFramework.CubismPhysicsNormalization = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsNormalization;\n    Live2DCubismFramework.CubismPhysicsOutput = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsOutput;\n    Live2DCubismFramework.CubismPhysicsParameter = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsParameter;\n    Live2DCubismFramework.CubismPhysicsParticle = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsParticle;\n    Live2DCubismFramework.CubismPhysicsRig = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsRig;\n    Live2DCubismFramework.CubismPhysicsSource = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsSource;\n    Live2DCubismFramework.CubismPhysicsSubRig = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsSubRig;\n    Live2DCubismFramework.CubismPhysicsTargetType = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.CubismPhysicsTargetType;\n    Live2DCubismFramework.PhysicsJsonEffectiveForces = _cubismphysicsinternal__WEBPACK_IMPORTED_MODULE_2__.PhysicsJsonEffectiveForces;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/physics/cubismphysicsinternal.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/physics/cubismphysicsjson.ts":
/*!***************************************************************!*\
  !*** ./src/lib/live2d/Framework/physics/cubismphysicsjson.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismPhysicsJson\": () => (/* binding */ CubismPhysicsJson),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/cubismvector2 */ \"./src/lib/live2d/Framework/math/cubismvector2.ts\");\n/* harmony import */ var _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismphysicsjson__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cubismphysicsjson */ \"./src/lib/live2d/Framework/physics/cubismphysicsjson.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\n\n// JSON keys\nvar Position = 'Position';\nvar X = 'X';\nvar Y = 'Y';\nvar Angle = 'Angle';\nvar Type = 'Type';\nvar Id = 'Id';\n// Meta\nvar Meta = 'Meta';\nvar EffectiveForces = 'EffectiveForces';\nvar TotalInputCount = 'TotalInputCount';\nvar TotalOutputCount = 'TotalOutputCount';\nvar PhysicsSettingCount = 'PhysicsSettingCount';\nvar Gravity = 'Gravity';\nvar Wind = 'Wind';\nvar VertexCount = 'VertexCount';\nvar Fps = 'Fps';\n// PhysicsSettings\nvar PhysicsSettings = 'PhysicsSettings';\nvar Normalization = 'Normalization';\nvar Minimum = 'Minimum';\nvar Maximum = 'Maximum';\nvar Default = 'Default';\nvar Reflect = 'Reflect';\nvar Weight = 'Weight';\n// Input\nvar Input = 'Input';\nvar Source = 'Source';\n// Output\nvar Output = 'Output';\nvar Scale = 'Scale';\nvar VertexIndex = 'VertexIndex';\nvar Destination = 'Destination';\n// Particle\nvar Vertices = 'Vertices';\nvar Mobility = 'Mobility';\nvar Delay = 'Delay';\nvar Radius = 'Radius';\nvar Acceleration = 'Acceleration';\n/**\n * physics3.jsonのコンテナ。\n */\nvar CubismPhysicsJson = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param buffer physics3.jsonが読み込まれているバッファ\n     * @param size バッファのサイズ\n     */\n    function CubismPhysicsJson(buffer, size) {\n        this._json = _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson.create(buffer, size);\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismPhysicsJson.prototype.release = function () {\n        _utils_cubismjson__WEBPACK_IMPORTED_MODULE_2__.CubismJson[\"delete\"](this._json);\n    };\n    /**\n     * 重力の取得\n     * @return 重力\n     */\n    CubismPhysicsJson.prototype.getGravity = function () {\n        var ret = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Gravity)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Gravity)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    };\n    /**\n     * 風の取得\n     * @return 風\n     */\n    CubismPhysicsJson.prototype.getWind = function () {\n        var ret = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Wind)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(EffectiveForces)\n            .getValueByString(Wind)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    };\n    /**\n     * 物理演算設定FPSの取得\n     * @return 物理演算設定FPS\n     */\n    CubismPhysicsJson.prototype.getFps = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(Fps)\n            .toFloat(0.0);\n    };\n    /**\n     * 物理店の管理の個数の取得\n     * @return 物理店の管理の個数\n     */\n    CubismPhysicsJson.prototype.getSubRigCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(PhysicsSettingCount)\n            .toInt();\n    };\n    /**\n     * 入力の総合計の取得\n     * @return 入力の総合計\n     */\n    CubismPhysicsJson.prototype.getTotalInputCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalInputCount)\n            .toInt();\n    };\n    /**\n     * 出力の総合計の取得\n     * @return 出力の総合計\n     */\n    CubismPhysicsJson.prototype.getTotalOutputCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(TotalOutputCount)\n            .toInt();\n    };\n    /**\n     * 物理点の個数の取得\n     * @return 物理点の個数\n     */\n    CubismPhysicsJson.prototype.getVertexCount = function () {\n        return this._json\n            .getRoot()\n            .getValueByString(Meta)\n            .getValueByString(VertexCount)\n            .toInt();\n    };\n    /**\n     * 正規化された位置の最小値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置の最小値\n     */\n    CubismPhysicsJson.prototype.getNormalizationPositionMinimumValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Minimum)\n            .toFloat();\n    };\n    /**\n     * 正規化された位置の最大値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置の最大値\n     */\n    CubismPhysicsJson.prototype.getNormalizationPositionMaximumValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Maximum)\n            .toFloat();\n    };\n    /**\n     * 正規化された位置のデフォルト値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された位置のデフォルト値\n     */\n    CubismPhysicsJson.prototype.getNormalizationPositionDefaultValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Position)\n            .getValueByString(Default)\n            .toFloat();\n    };\n    /**\n     * 正規化された角度の最小値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された角度の最小値\n     */\n    CubismPhysicsJson.prototype.getNormalizationAngleMinimumValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Minimum)\n            .toFloat();\n    };\n    /**\n     * 正規化された角度の最大値の取得\n     * @param physicsSettingIndex\n     * @return 正規化された角度の最大値\n     */\n    CubismPhysicsJson.prototype.getNormalizationAngleMaximumValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Maximum)\n            .toFloat();\n    };\n    /**\n     * 正規化された角度のデフォルト値の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 正規化された角度のデフォルト値\n     */\n    CubismPhysicsJson.prototype.getNormalizationAngleDefaultValue = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Normalization)\n            .getValueByString(Angle)\n            .getValueByString(Default)\n            .toFloat();\n    };\n    /**\n     * 入力の個数の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 入力の個数\n     */\n    CubismPhysicsJson.prototype.getInputCount = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getVector()\n            .getSize();\n    };\n    /**\n     * 入力の重みの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の重み\n     */\n    CubismPhysicsJson.prototype.getInputWeight = function (physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Weight)\n            .toFloat();\n    };\n    /**\n     * 入力の反転の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の反転\n     */\n    CubismPhysicsJson.prototype.getInputReflect = function (physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Reflect)\n            .toBoolean();\n    };\n    /**\n     * 入力の種類の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力の種類\n     */\n    CubismPhysicsJson.prototype.getInputType = function (physicsSettingIndex, inputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Type)\n            .getRawString();\n    };\n    /**\n     * 入力元のIDの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param inputIndex 入力のインデックス\n     * @return 入力元のID\n     */\n    CubismPhysicsJson.prototype.getInputSourceId = function (physicsSettingIndex, inputIndex) {\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Input)\n            .getValueByIndex(inputIndex)\n            .getValueByString(Source)\n            .getValueByString(Id)\n            .getRawString());\n    };\n    /**\n     * 出力の個数の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @return 出力の個数\n     */\n    CubismPhysicsJson.prototype.getOutputCount = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getVector()\n            .getSize();\n    };\n    /**\n     * 出力の物理点のインデックスの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の物理点のインデックス\n     */\n    CubismPhysicsJson.prototype.getOutputVertexIndex = function (physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(VertexIndex)\n            .toInt();\n    };\n    /**\n     * 出力の角度のスケールを取得する\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の角度のスケール\n     */\n    CubismPhysicsJson.prototype.getOutputAngleScale = function (physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Scale)\n            .toFloat();\n    };\n    /**\n     * 出力の重みの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の重み\n     */\n    CubismPhysicsJson.prototype.getOutputWeight = function (physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Weight)\n            .toFloat();\n    };\n    /**\n     * 出力先のIDの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力先のID\n     */\n    CubismPhysicsJson.prototype.getOutputDestinationId = function (physicsSettingIndex, outputIndex) {\n        return _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager().getId(this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Destination)\n            .getValueByString(Id)\n            .getRawString());\n    };\n    /**\n     * 出力の種類の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の種類\n     */\n    CubismPhysicsJson.prototype.getOutputType = function (physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Type)\n            .getRawString();\n    };\n    /**\n     * 出力の反転の取得\n     * @param physicsSettingIndex 物理演算のインデックス\n     * @param outputIndex 出力のインデックス\n     * @return 出力の反転\n     */\n    CubismPhysicsJson.prototype.getOutputReflect = function (physicsSettingIndex, outputIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Output)\n            .getValueByIndex(outputIndex)\n            .getValueByString(Reflect)\n            .toBoolean();\n    };\n    /**\n     * 物理点の個数の取得\n     * @param physicsSettingIndex 物理演算男設定のインデックス\n     * @return 物理点の個数\n     */\n    CubismPhysicsJson.prototype.getParticleCount = function (physicsSettingIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getVector()\n            .getSize();\n    };\n    /**\n     * 物理点の動きやすさの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の動きやすさ\n     */\n    CubismPhysicsJson.prototype.getParticleMobility = function (physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Mobility)\n            .toFloat();\n    };\n    /**\n     * 物理点の遅れの取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の遅れ\n     */\n    CubismPhysicsJson.prototype.getParticleDelay = function (physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Delay)\n            .toFloat();\n    };\n    /**\n     * 物理点の加速度の取得\n     * @param physicsSettingIndex 物理演算の設定\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の加速度\n     */\n    CubismPhysicsJson.prototype.getParticleAcceleration = function (physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Acceleration)\n            .toFloat();\n    };\n    /**\n     * 物理点の距離の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexIndex 物理点のインデックス\n     * @return 物理点の距離\n     */\n    CubismPhysicsJson.prototype.getParticleRadius = function (physicsSettingIndex, vertexIndex) {\n        return this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Radius)\n            .toFloat();\n    };\n    /**\n     * 物理点の位置の取得\n     * @param physicsSettingIndex 物理演算の設定のインデックス\n     * @param vertexInde 物理点のインデックス\n     * @return 物理点の位置\n     */\n    CubismPhysicsJson.prototype.getParticlePosition = function (physicsSettingIndex, vertexIndex) {\n        var ret = new _math_cubismvector2__WEBPACK_IMPORTED_MODULE_1__.CubismVector2(0, 0);\n        ret.x = this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Position)\n            .getValueByString(X)\n            .toFloat();\n        ret.y = this._json\n            .getRoot()\n            .getValueByString(PhysicsSettings)\n            .getValueByIndex(physicsSettingIndex)\n            .getValueByString(Vertices)\n            .getValueByIndex(vertexIndex)\n            .getValueByString(Position)\n            .getValueByString(Y)\n            .toFloat();\n        return ret;\n    };\n    return CubismPhysicsJson;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismPhysicsJson = _cubismphysicsjson__WEBPACK_IMPORTED_MODULE_3__.CubismPhysicsJson;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/physics/cubismphysicsjson.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/rendering/cubismrenderer.ts":
/*!**************************************************************!*\
  !*** ./src/lib/live2d/Framework/rendering/cubismrenderer.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismBlendMode\": () => (/* binding */ CubismBlendMode),\n/* harmony export */   \"CubismRenderer\": () => (/* binding */ CubismRenderer),\n/* harmony export */   \"CubismTextureColor\": () => (/* binding */ CubismTextureColor),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/cubismmatrix44 */ \"./src/lib/live2d/Framework/math/cubismmatrix44.ts\");\n/* harmony import */ var _cubismrenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cubismrenderer */ \"./src/lib/live2d/Framework/rendering/cubismrenderer.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * モデル描画を処理するレンダラ\n *\n * サブクラスに環境依存の描画命令を記述する。\n */\nvar CubismRenderer = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismRenderer() {\n        this._isCulling = false;\n        this._isPremultipliedAlpha = false;\n        this._anisotropy = 0.0;\n        this._model = null;\n        this._modelColor = new CubismTextureColor();\n        // 単位行列に初期化\n        this._mvpMatrix4x4 = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_0__.CubismMatrix44();\n        this._mvpMatrix4x4.loadIdentity();\n    }\n    /**\n     * レンダラのインスタンスを生成して取得する\n     *\n     * @return レンダラのインスタンス\n     */\n    CubismRenderer.create = function () {\n        return null;\n    };\n    /**\n     * レンダラのインスタンスを解放する\n     */\n    CubismRenderer.delete = function (renderer) {\n        renderer = null;\n    };\n    /**\n     * レンダラの初期化処理を実行する\n     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n     * @param model モデルのインスタンス\n     */\n    CubismRenderer.prototype.initialize = function (model) {\n        this._model = model;\n    };\n    /**\n     * モデルを描画する\n     */\n    CubismRenderer.prototype.drawModel = function () {\n        if (this.getModel() == null)\n            return;\n        this.doDrawModel();\n    };\n    /**\n     * Model-View-Projection 行列をセットする\n     * 配列は複製されるので、元の配列は外で破棄して良い\n     * @param matrix44 Model-View-Projection 行列\n     */\n    CubismRenderer.prototype.setMvpMatrix = function (matrix44) {\n        this._mvpMatrix4x4.setMatrix(matrix44.getArray());\n    };\n    /**\n     * Model-View-Projection 行列を取得する\n     * @return Model-View-Projection 行列\n     */\n    CubismRenderer.prototype.getMvpMatrix = function () {\n        return this._mvpMatrix4x4;\n    };\n    /**\n     * モデルの色をセットする\n     * 各色0.0~1.0の間で指定する（1.0が標準の状態）\n     * @param red 赤チャンネルの値\n     * @param green 緑チャンネルの値\n     * @param blue 青チャンネルの値\n     * @param alpha αチャンネルの値\n     */\n    CubismRenderer.prototype.setModelColor = function (red, green, blue, alpha) {\n        if (red < 0.0) {\n            red = 0.0;\n        }\n        else if (red > 1.0) {\n            red = 1.0;\n        }\n        if (green < 0.0) {\n            green = 0.0;\n        }\n        else if (green > 1.0) {\n            green = 1.0;\n        }\n        if (blue < 0.0) {\n            blue = 0.0;\n        }\n        else if (blue > 1.0) {\n            blue = 1.0;\n        }\n        if (alpha < 0.0) {\n            alpha = 0.0;\n        }\n        else if (alpha > 1.0) {\n            alpha = 1.0;\n        }\n        this._modelColor.R = red;\n        this._modelColor.G = green;\n        this._modelColor.B = blue;\n        this._modelColor.A = alpha;\n    };\n    /**\n     * モデルの色を取得する\n     * 各色0.0~1.0の間で指定する(1.0が標準の状態)\n     *\n     * @return RGBAのカラー情報\n     */\n    CubismRenderer.prototype.getModelColor = function () {\n        return JSON.parse(JSON.stringify(this._modelColor));\n    };\n    /**\n     * 乗算済みαの有効・無効をセットする\n     * 有効にするならtrue、無効にするならfalseをセットする\n     */\n    CubismRenderer.prototype.setIsPremultipliedAlpha = function (enable) {\n        this._isPremultipliedAlpha = enable;\n    };\n    /**\n     * 乗算済みαの有効・無効を取得する\n     * @return true 乗算済みのα有効\n     * @return false 乗算済みのα無効\n     */\n    CubismRenderer.prototype.isPremultipliedAlpha = function () {\n        return this._isPremultipliedAlpha;\n    };\n    /**\n     * カリング（片面描画）の有効・無効をセットする。\n     * 有効にするならtrue、無効にするならfalseをセットする\n     */\n    CubismRenderer.prototype.setIsCulling = function (culling) {\n        this._isCulling = culling;\n    };\n    /**\n     * カリング（片面描画）の有効・無効を取得する。\n     * @return true カリング有効\n     * @return false カリング無効\n     */\n    CubismRenderer.prototype.isCulling = function () {\n        return this._isCulling;\n    };\n    /**\n     * テクスチャの異方性フィルタリングのパラメータをセットする\n     * パラメータ値の影響度はレンダラの実装に依存する\n     * @param n パラメータの値\n     */\n    CubismRenderer.prototype.setAnisotropy = function (n) {\n        this._anisotropy = n;\n    };\n    /**\n     * テクスチャの異方性フィルタリングのパラメータをセットする\n     * @return 異方性フィルタリングのパラメータ\n     */\n    CubismRenderer.prototype.getAnisotropy = function () {\n        return this._anisotropy;\n    };\n    /**\n     * レンダリングするモデルを取得する\n     * @return レンダリングするモデル\n     */\n    CubismRenderer.prototype.getModel = function () {\n        return this._model;\n    };\n    return CubismRenderer;\n}());\n\nvar CubismBlendMode;\n(function (CubismBlendMode) {\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Normal\"] = 0] = \"CubismBlendMode_Normal\";\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Additive\"] = 1] = \"CubismBlendMode_Additive\";\n    CubismBlendMode[CubismBlendMode[\"CubismBlendMode_Multiplicative\"] = 2] = \"CubismBlendMode_Multiplicative\";\n})(CubismBlendMode || (CubismBlendMode = {}));\n/**\n * テクスチャの色をRGBAで扱うためのクラス\n */\nvar CubismTextureColor = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismTextureColor() {\n        this.R = 1.0;\n        this.G = 1.0;\n        this.B = 1.0;\n        this.A = 1.0;\n    }\n    return CubismTextureColor;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismBlendMode = _cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismBlendMode;\n    Live2DCubismFramework.CubismRenderer = _cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismRenderer;\n    Live2DCubismFramework.CubismTextureColor = _cubismrenderer__WEBPACK_IMPORTED_MODULE_1__.CubismTextureColor;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/rendering/cubismrenderer.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/rendering/cubismrenderer_webgl.ts":
/*!********************************************************************!*\
  !*** ./src/lib/live2d/Framework/rendering/cubismrenderer_webgl.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismClippingContext\": () => (/* binding */ CubismClippingContext),\n/* harmony export */   \"CubismClippingManager_WebGL\": () => (/* binding */ CubismClippingManager_WebGL),\n/* harmony export */   \"CubismRenderTextureResource\": () => (/* binding */ CubismRenderTextureResource),\n/* harmony export */   \"CubismRenderer_WebGL\": () => (/* binding */ CubismRenderer_WebGL),\n/* harmony export */   \"CubismShaderSet\": () => (/* binding */ CubismShaderSet),\n/* harmony export */   \"CubismShader_WebGL\": () => (/* binding */ CubismShader_WebGL),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"ShaderNames\": () => (/* binding */ ShaderNames),\n/* harmony export */   \"fragmentShaderSrcMaskInvertedPremultipliedAlpha\": () => (/* binding */ fragmentShaderSrcMaskInvertedPremultipliedAlpha),\n/* harmony export */   \"fragmentShaderSrcMaskPremultipliedAlpha\": () => (/* binding */ fragmentShaderSrcMaskPremultipliedAlpha),\n/* harmony export */   \"fragmentShaderSrcPremultipliedAlpha\": () => (/* binding */ fragmentShaderSrcPremultipliedAlpha),\n/* harmony export */   \"fragmentShaderSrcsetupMask\": () => (/* binding */ fragmentShaderSrcsetupMask),\n/* harmony export */   \"vertexShaderSrc\": () => (/* binding */ vertexShaderSrc),\n/* harmony export */   \"vertexShaderSrcMasked\": () => (/* binding */ vertexShaderSrcMasked),\n/* harmony export */   \"vertexShaderSrcSetupMask\": () => (/* binding */ vertexShaderSrcSetupMask)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/cubismmatrix44 */ \"./src/lib/live2d/Framework/math/cubismmatrix44.ts\");\n/* harmony import */ var _type_csmmap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmmap */ \"./src/lib/live2d/Framework/type/csmmap.ts\");\n/* harmony import */ var _type_csmrectf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type/csmrectf */ \"./src/lib/live2d/Framework/type/csmrectf.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cubismrenderer */ \"./src/lib/live2d/Framework/rendering/cubismrenderer.ts\");\n/* harmony import */ var _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cubismrenderer_webgl */ \"./src/lib/live2d/Framework/rendering/cubismrenderer_webgl.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\nvar ColorChannelCount = 4; // 実験時に1チャンネルの場合は1、RGBだけの場合は3、アルファも含める場合は4\nvar shaderCount = 10; // シェーダーの数 = マスク生成用 + (通常用 + 加算 + 乗算) * (マスク無の乗算済アルファ対応版 + マスク有の乗算済アルファ対応版 + マスク有反転の乗算済アルファ対応版)\nvar s_instance;\nvar s_viewport;\nvar s_fbo;\n/**\n * クリッピングマスクの処理を実行するクラス\n */\nvar CubismClippingManager_WebGL = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismClippingManager_WebGL() {\n        this._maskRenderTexture = null;\n        this._colorBuffer = null;\n        this._currentFrameNo = 0;\n        this._clippingMaskBufferSize = 256;\n        this._clippingContextListForMask = new _type_csmvector__WEBPACK_IMPORTED_MODULE_4__.csmVector();\n        this._clippingContextListForDraw = new _type_csmvector__WEBPACK_IMPORTED_MODULE_4__.csmVector();\n        this._channelColors = new _type_csmvector__WEBPACK_IMPORTED_MODULE_4__.csmVector();\n        this._tmpBoundsOnModel = new _type_csmrectf__WEBPACK_IMPORTED_MODULE_3__.csmRect();\n        this._tmpMatrix = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__.CubismMatrix44();\n        this._tmpMatrixForMask = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__.CubismMatrix44();\n        this._tmpMatrixForDraw = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__.CubismMatrix44();\n        this._maskTexture = null;\n        var tmp = new _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismTextureColor();\n        tmp.R = 1.0;\n        tmp.G = 0.0;\n        tmp.B = 0.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 1.0;\n        tmp.B = 0.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 0.0;\n        tmp.B = 1.0;\n        tmp.A = 0.0;\n        this._channelColors.pushBack(tmp);\n        tmp = new _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismTextureColor();\n        tmp.R = 0.0;\n        tmp.G = 0.0;\n        tmp.B = 0.0;\n        tmp.A = 1.0;\n        this._channelColors.pushBack(tmp);\n    }\n    /**\n     * カラーチャンネル（RGBA）のフラグを取得する\n     * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）\n     */\n    CubismClippingManager_WebGL.prototype.getChannelFlagAsColor = function (channelNo) {\n        return this._channelColors.at(channelNo);\n    };\n    /**\n     * テンポラリのレンダーテクスチャのアドレスを取得する\n     * FrameBufferObjectが存在しない場合、新しく生成する\n     *\n     * @return レンダーテクスチャのアドレス\n     */\n    CubismClippingManager_WebGL.prototype.getMaskRenderTexture = function () {\n        var ret = 0;\n        // テンポラリのRenderTextureを取得する\n        if (this._maskTexture && this._maskTexture.texture != 0) {\n            // 前回使ったものを返す\n            this._maskTexture.frameNo = this._currentFrameNo;\n            ret = this._maskTexture.texture;\n        }\n        if (ret == 0) {\n            // FrameBufferObjectが存在しない場合、新しく生成する\n            // クリッピングバッファサイズを取得\n            var size = this._clippingMaskBufferSize;\n            this._colorBuffer = this.gl.createTexture();\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this._colorBuffer);\n            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n            ret = this.gl.createFramebuffer();\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, ret);\n            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._colorBuffer, 0);\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n            this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, ret);\n        }\n        return ret;\n    };\n    /**\n     * WebGLレンダリングコンテキストを設定する\n     * @param gl WebGLレンダリングコンテキスト\n     */\n    CubismClippingManager_WebGL.prototype.setGL = function (gl) {\n        this.gl = gl;\n    };\n    /**\n     * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する\n     * @param model モデルのインスタンス\n     * @param clippingContext クリッピングマスクのコンテキスト\n     */\n    CubismClippingManager_WebGL.prototype.calcClippedDrawTotalBounds = function (model, clippingContext) {\n        // 被クリッピングマスク（マスクされる描画オブジェクト）の全体の矩形\n        var clippedDrawTotalMinX = Number.MAX_VALUE;\n        var clippedDrawTotalMinY = Number.MAX_VALUE;\n        var clippedDrawTotalMaxX = Number.MIN_VALUE;\n        var clippedDrawTotalMaxY = Number.MIN_VALUE;\n        // このマスクが実際に必要か判定する\n        // このクリッピングを利用する「描画オブジェクト」がひとつでも使用可能であればマスクを生成する必要がある\n        var clippedDrawCount = clippingContext._clippedDrawableIndexList.length;\n        for (var clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {\n            // マスクを使用する描画オブジェクトの描画される矩形を求める\n            var drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];\n            var drawableVertexCount = model.getDrawableVertexCount(drawableIndex);\n            var drawableVertexes = model.getDrawableVertices(drawableIndex);\n            var minX = Number.MAX_VALUE;\n            var minY = Number.MAX_VALUE;\n            var maxX = Number.MIN_VALUE;\n            var maxY = Number.MIN_VALUE;\n            var loop = drawableVertexCount * _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.Constant.vertexStep;\n            for (var pi = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.Constant.vertexOffset; pi < loop; pi += _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.Constant.vertexStep) {\n                var x = drawableVertexes[pi];\n                var y = drawableVertexes[pi + 1];\n                if (x < minX) {\n                    minX = x;\n                }\n                if (x > maxX) {\n                    maxX = x;\n                }\n                if (y < minY) {\n                    minY = y;\n                }\n                if (y > maxY) {\n                    maxY = y;\n                }\n            }\n            // 有効な点が一つも取れなかったのでスキップ\n            if (minX == Number.MAX_VALUE) {\n                continue;\n            }\n            // 全体の矩形に反映\n            if (minX < clippedDrawTotalMinX) {\n                clippedDrawTotalMinX = minX;\n            }\n            if (minY < clippedDrawTotalMinY) {\n                clippedDrawTotalMinY = minY;\n            }\n            if (maxX > clippedDrawTotalMaxX) {\n                clippedDrawTotalMaxX = maxX;\n            }\n            if (maxY > clippedDrawTotalMaxY) {\n                clippedDrawTotalMaxY = maxY;\n            }\n            if (clippedDrawTotalMinX == Number.MAX_VALUE) {\n                clippingContext._allClippedDrawRect.x = 0.0;\n                clippingContext._allClippedDrawRect.y = 0.0;\n                clippingContext._allClippedDrawRect.width = 0.0;\n                clippingContext._allClippedDrawRect.height = 0.0;\n                clippingContext._isUsing = false;\n            }\n            else {\n                clippingContext._isUsing = true;\n                var w = clippedDrawTotalMaxX - clippedDrawTotalMinX;\n                var h = clippedDrawTotalMaxY - clippedDrawTotalMinY;\n                clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;\n                clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;\n                clippingContext._allClippedDrawRect.width = w;\n                clippingContext._allClippedDrawRect.height = h;\n            }\n        }\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismClippingManager_WebGL.prototype.release = function () {\n        for (var i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n            if (this._clippingContextListForMask.at(i)) {\n                this._clippingContextListForMask.at(i).release();\n                this._clippingContextListForMask.set(i, void 0);\n            }\n            this._clippingContextListForMask.set(i, null);\n        }\n        this._clippingContextListForMask = null;\n        // _clippingContextListForDrawは_clippingContextListForMaskにあるインスタンスを指している。上記の処理により要素ごとのDELETEは不要。\n        for (var i = 0; i < this._clippingContextListForDraw.getSize(); i++) {\n            this._clippingContextListForDraw.set(i, null);\n        }\n        this._clippingContextListForDraw = null;\n        if (this._maskTexture) {\n            this.gl.deleteFramebuffer(this._maskTexture.texture);\n            this._maskTexture = null;\n        }\n        for (var i = 0; i < this._channelColors.getSize(); i++) {\n            this._channelColors.set(i, null);\n        }\n        this._channelColors = null;\n        // テクスチャ解放\n        this.gl.deleteTexture(this._colorBuffer);\n        this._colorBuffer = null;\n    };\n    /**\n     * マネージャの初期化処理\n     * クリッピングマスクを使う描画オブジェクトの登録を行う\n     * @param model モデルのインスタンス\n     * @param drawableCount 描画オブジェクトの数\n     * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト\n     * @param drawableCounts 描画オブジェクトをマスクする描画オブジェクトの数\n     */\n    CubismClippingManager_WebGL.prototype.initialize = function (model, drawableCount, drawableMasks, drawableMaskCounts) {\n        // クリッピングマスクを使う描画オブジェクトをすべて登録する\n        // クリッピングマスクは、通常数個程度に限定して使うものとする\n        for (var i = 0; i < drawableCount; i++) {\n            if (drawableMaskCounts[i] <= 0) {\n                // クリッピングマスクが使用されていないアートメッシュ（多くの場合使用しない）\n                this._clippingContextListForDraw.pushBack(null);\n                continue;\n            }\n            // 既にあるClipContextと同じかチェックする\n            var clippingContext = this.findSameClip(drawableMasks[i], drawableMaskCounts[i]);\n            if (clippingContext == null) {\n                // 同一のマスクが存在していない場合は生成する\n                clippingContext = new CubismClippingContext(this, drawableMasks[i], drawableMaskCounts[i]);\n                this._clippingContextListForMask.pushBack(clippingContext);\n            }\n            clippingContext.addClippedDrawable(i);\n            this._clippingContextListForDraw.pushBack(clippingContext);\n        }\n    };\n    /**\n     * クリッピングコンテキストを作成する。モデル描画時に実行する。\n     * @param model モデルのインスタンス\n     * @param renderer レンダラのインスタンス\n     */\n    CubismClippingManager_WebGL.prototype.setupClippingContext = function (model, renderer) {\n        this._currentFrameNo++;\n        // 全てのクリッピングを用意する\n        // 同じクリップ（複数の場合はまとめて一つのクリップ）を使う場合は1度だけ設定する\n        var usingClipCount = 0;\n        for (var clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n            // 1つのクリッピングマスクに関して\n            var cc = this._clippingContextListForMask.at(clipIndex);\n            // このクリップを利用する描画オブジェクト群全体を囲む矩形を計算\n            this.calcClippedDrawTotalBounds(model, cc);\n            if (cc._isUsing) {\n                usingClipCount++; // 使用中としてカウント\n            }\n        }\n        // マスク作成処理\n        if (usingClipCount > 0) {\n            // 生成したFrameBufferと同じサイズでビューポートを設定\n            this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);\n            // マスクをactiveにする\n            this._maskRenderTexture = this.getMaskRenderTexture();\n            // モデル描画時にDrawMeshNowに渡される変換(モデルtoワールド座標変換)\n            var modelToWorldF = renderer.getMvpMatrix();\n            renderer.preDraw(); // バッファをクリアする\n            // 各マスクのレイアウトを決定していく\n            this.setupLayoutBounds(usingClipCount);\n            // ---------- マスク描画処理 ----------\n            // マスク用RenderTextureをactiveにセット\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTexture);\n            // マスクをクリアする\n            // (仮仕様) 1が無効（描かれない）領域、0が有効（描かれる）領域。（シェーダーCd*Csで0に近い値をかけてマスクを作る。1をかけると何も起こらない）\n            this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n            // 実際にマスクを生成する\n            // 全てのマスクをどのようにレイアウトして描くかを決定し、ClipContext, ClippedDrawContextに記憶する\n            for (var clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {\n                // --- 実際に1つのマスクを描く ---\n                var clipContext = this._clippingContextListForMask.at(clipIndex);\n                var allClipedDrawRect = clipContext._allClippedDrawRect; // このマスクを使う、すべての描画オブジェクトの論理座標上の囲み矩形\n                var layoutBoundsOnTex01 = clipContext._layoutBounds; // この中にマスクを収める\n                // モデル座標上の矩形を、適宜マージンを付けて使う\n                var MARGIN = 0.05;\n                this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n                this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, allClipedDrawRect.height * MARGIN);\n                //########## 本来は割り当てられた領域の全体を使わず必要最低限のサイズがよい\n                // シェーダ用の計算式を求める。回転を考慮しない場合は以下のとおり\n                // movePeriod' = movePeriod * scaleX + offX\t\t  [[ movePeriod' = (movePeriod - tmpBoundsOnModel.movePeriod)*scale + layoutBoundsOnTex01.movePeriod ]]\n                var scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n                var scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n                // マスク生成時に使う行列を求める\n                {\n                    // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n                    this._tmpMatrix.loadIdentity();\n                    {\n                        // layout0..1 を -1..1に変換\n                        this._tmpMatrix.translateRelative(-1.0, -1.0);\n                        this._tmpMatrix.scaleRelative(2.0, 2.0);\n                    }\n                    {\n                        // view to layout0..1\n                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n                        // new = [translate][scale][translate]\n                    }\n                    // tmpMatrixForMaskが計算結果\n                    this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());\n                }\n                //--------- draw時の mask 参照用行列を計算\n                {\n                    // シェーダに渡す行列を求める <<<<<<<<<<<<<<<<<<<<<<<< 要最適化（逆順に計算すればシンプルにできる）\n                    this._tmpMatrix.loadIdentity();\n                    {\n                        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n                        this._tmpMatrix.scaleRelative(scaleX, scaleY); // new = [translate][scale]\n                        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n                        // new = [translate][scale][translate]\n                    }\n                    this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());\n                }\n                clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());\n                clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());\n                var clipDrawCount = clipContext._clippingIdCount;\n                for (var i = 0; i < clipDrawCount; i++) {\n                    var clipDrawIndex = clipContext._clippingIdList[i];\n                    // 頂点情報が更新されておらず、信頼性がない場合は描画をパスする\n                    if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n                        continue;\n                    }\n                    renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);\n                    // 今回専用の変換を適用して描く\n                    // チャンネルも切り替える必要がある(A,R,G,B)\n                    renderer.setClippingContextBufferForMask(clipContext);\n                    renderer.drawMesh(model.getDrawableTextureIndex(clipDrawIndex), model.getDrawableVertexIndexCount(clipDrawIndex), model.getDrawableVertexCount(clipDrawIndex), model.getDrawableVertexIndices(clipDrawIndex), model.getDrawableVertices(clipDrawIndex), model.getDrawableVertexUvs(clipDrawIndex), model.getMultiplyColor(clipDrawIndex), model.getScreenColor(clipDrawIndex), model.getDrawableOpacity(clipDrawIndex), _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismBlendMode.CubismBlendMode_Normal, // クリッピングは通常描画を強制\n                    false // マスク生成時はクリッピングの反転使用は全く関係がない\n                    );\n                }\n            }\n            // --- 後処理 ---\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo); // 描画対象を戻す\n            renderer.setClippingContextBufferForMask(null);\n            this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n        }\n    };\n    /**\n     * 既にマスクを作っているかを確認\n     * 作っている様であれば該当するクリッピングマスクのインスタンスを返す\n     * 作っていなければNULLを返す\n     * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト\n     * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数\n     * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す\n     */\n    CubismClippingManager_WebGL.prototype.findSameClip = function (drawableMasks, drawableMaskCounts) {\n        // 作成済みClippingContextと一致するか確認\n        for (var i = 0; i < this._clippingContextListForMask.getSize(); i++) {\n            var clippingContext = this._clippingContextListForMask.at(i);\n            var count = clippingContext._clippingIdCount;\n            // 個数が違う場合は別物\n            if (count != drawableMaskCounts) {\n                continue;\n            }\n            var sameCount = 0;\n            // 同じIDを持つか確認。配列の数が同じなので、一致した個数が同じなら同じ物を持つとする\n            for (var j = 0; j < count; j++) {\n                var clipId = clippingContext._clippingIdList[j];\n                for (var k = 0; k < count; k++) {\n                    if (drawableMasks[k] == clipId) {\n                        sameCount++;\n                        break;\n                    }\n                }\n            }\n            if (sameCount == count) {\n                return clippingContext;\n            }\n        }\n        return null; // 見つからなかった\n    };\n    /**\n     * クリッピングコンテキストを配置するレイアウト\n     * 一つのレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする\n     * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。\n     *\n     * @param usingClipCount 配置するクリッピングコンテキストの数\n     */\n    CubismClippingManager_WebGL.prototype.setupLayoutBounds = function (usingClipCount) {\n        // ひとつのRenderTextureを極力いっぱいに使ってマスクをレイアウトする\n        // マスクグループの数が4以下ならRGBA各チャンネルに1つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する\n        // RGBAを順番に使っていく\n        var div = usingClipCount / ColorChannelCount; // 1チャンネルに配置する基本のマスク\n        var mod = usingClipCount % ColorChannelCount; // 余り、この番号のチャンネルまでに一つずつ配分する\n        // 小数点は切り捨てる\n        div = ~~div;\n        mod = ~~mod;\n        // RGBAそれぞれのチャンネルを用意していく（0:R, 1:G, 2:B, 3:A）\n        var curClipIndex = 0; // 順番に設定していく\n        for (var channelNo = 0; channelNo < ColorChannelCount; channelNo++) {\n            // このチャンネルにレイアウトする数\n            var layoutCount = div + (channelNo < mod ? 1 : 0);\n            // 分割方法を決定する\n            if (layoutCount == 0) {\n                // 何もしない\n            }\n            else if (layoutCount == 1) {\n                // 全てをそのまま使う\n                var clipContext = this._clippingContextListForMask.at(curClipIndex++);\n                clipContext._layoutChannelNo = channelNo;\n                clipContext._layoutBounds.x = 0.0;\n                clipContext._layoutBounds.y = 0.0;\n                clipContext._layoutBounds.width = 1.0;\n                clipContext._layoutBounds.height = 1.0;\n            }\n            else if (layoutCount == 2) {\n                for (var i = 0; i < layoutCount; i++) {\n                    var xpos = i % 2;\n                    // 小数点は切り捨てる\n                    xpos = ~~xpos;\n                    var cc = this._clippingContextListForMask.at(curClipIndex++);\n                    cc._layoutChannelNo = channelNo;\n                    cc._layoutBounds.x = xpos * 0.5;\n                    cc._layoutBounds.y = 0.0;\n                    cc._layoutBounds.width = 0.5;\n                    cc._layoutBounds.height = 1.0;\n                    // UVを2つに分解して使う\n                }\n            }\n            else if (layoutCount <= 4) {\n                // 4分割して使う\n                for (var i = 0; i < layoutCount; i++) {\n                    var xpos = i % 2;\n                    var ypos = i / 2;\n                    // 小数点は切り捨てる\n                    xpos = ~~xpos;\n                    ypos = ~~ypos;\n                    var cc = this._clippingContextListForMask.at(curClipIndex++);\n                    cc._layoutChannelNo = channelNo;\n                    cc._layoutBounds.x = xpos * 0.5;\n                    cc._layoutBounds.y = ypos * 0.5;\n                    cc._layoutBounds.width = 0.5;\n                    cc._layoutBounds.height = 0.5;\n                }\n            }\n            else if (layoutCount <= 9) {\n                // 9分割して使う\n                for (var i = 0; i < layoutCount; i++) {\n                    var xpos = i % 3;\n                    var ypos = i / 3;\n                    // 小数点は切り捨てる\n                    xpos = ~~xpos;\n                    ypos = ~~ypos;\n                    var cc = this._clippingContextListForMask.at(curClipIndex++);\n                    cc._layoutChannelNo = channelNo;\n                    cc._layoutBounds.x = xpos / 3.0;\n                    cc._layoutBounds.y = ypos / 3.0;\n                    cc._layoutBounds.width = 1.0 / 3.0;\n                    cc._layoutBounds.height = 1.0 / 3.0;\n                }\n            }\n            else {\n                // マスクの制限枚数を超えた場合の処理\n                (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('not supported mask count : {0}', layoutCount);\n                // SetupShaderProgramでオーバーアクセスが発生するので仮で数値を入れる\n                // もちろん描画結果は正しいものではなくなる\n                for (var index = 0; index < layoutCount; index++) {\n                    var cc = this._clippingContextListForMask.at(curClipIndex++);\n                    cc._layoutChannelNo = 0;\n                    cc._layoutBounds.x = 0.0;\n                    cc._layoutBounds.y = 0.0;\n                    cc._layoutBounds.width = 1.0;\n                    cc._layoutBounds.height = 1.0;\n                }\n            }\n        }\n    };\n    /**\n     * カラーバッファを取得する\n     * @return カラーバッファ\n     */\n    CubismClippingManager_WebGL.prototype.getColorBuffer = function () {\n        return this._colorBuffer;\n    };\n    /**\n     * 画面描画に使用するクリッピングマスクのリストを取得する\n     * @return 画面描画に使用するクリッピングマスクのリスト\n     */\n    CubismClippingManager_WebGL.prototype.getClippingContextListForDraw = function () {\n        return this._clippingContextListForDraw;\n    };\n    /**\n     * クリッピングマスクバッファのサイズを設定する\n     * @param size クリッピングマスクバッファのサイズ\n     */\n    CubismClippingManager_WebGL.prototype.setClippingMaskBufferSize = function (size) {\n        this._clippingMaskBufferSize = size;\n    };\n    /**\n     * クリッピングマスクバッファのサイズを取得する\n     * @return クリッピングマスクバッファのサイズ\n     */\n    CubismClippingManager_WebGL.prototype.getClippingMaskBufferSize = function () {\n        return this._clippingMaskBufferSize;\n    };\n    return CubismClippingManager_WebGL;\n}());\n\n/**\n * レンダーテクスチャのリソースを定義する構造体\n * クリッピングマスクで使用する\n */\nvar CubismRenderTextureResource = /** @class */ (function () {\n    /**\n     * 引数付きコンストラクタ\n     * @param frameNo レンダラーのフレーム番号\n     * @param texture テクスチャのアドレス\n     */\n    function CubismRenderTextureResource(frameNo, texture) {\n        this.frameNo = frameNo;\n        this.texture = texture;\n    }\n    return CubismRenderTextureResource;\n}());\n\n/**\n * クリッピングマスクのコンテキスト\n */\nvar CubismClippingContext = /** @class */ (function () {\n    /**\n     * 引数付きコンストラクタ\n     */\n    function CubismClippingContext(manager, clippingDrawableIndices, clipCount) {\n        this._owner = manager;\n        // クリップしている（＝マスク用の）Drawableのインデックスリスト\n        this._clippingIdList = clippingDrawableIndices;\n        // マスクの数\n        this._clippingIdCount = clipCount;\n        this._allClippedDrawRect = new _type_csmrectf__WEBPACK_IMPORTED_MODULE_3__.csmRect();\n        this._layoutBounds = new _type_csmrectf__WEBPACK_IMPORTED_MODULE_3__.csmRect();\n        this._clippedDrawableIndexList = [];\n        this._matrixForMask = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__.CubismMatrix44();\n        this._matrixForDraw = new _math_cubismmatrix44__WEBPACK_IMPORTED_MODULE_1__.CubismMatrix44();\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismClippingContext.prototype.release = function () {\n        if (this._layoutBounds != null) {\n            this._layoutBounds = null;\n        }\n        if (this._allClippedDrawRect != null) {\n            this._allClippedDrawRect = null;\n        }\n        if (this._clippedDrawableIndexList != null) {\n            this._clippedDrawableIndexList = null;\n        }\n    };\n    /**\n     * このマスクにクリップされる描画オブジェクトを追加する\n     *\n     * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス\n     */\n    CubismClippingContext.prototype.addClippedDrawable = function (drawableIndex) {\n        this._clippedDrawableIndexList.push(drawableIndex);\n    };\n    /**\n     * このマスクを管理するマネージャのインスタンスを取得する\n     * @return クリッピングマネージャのインスタンス\n     */\n    CubismClippingContext.prototype.getClippingManager = function () {\n        return this._owner;\n    };\n    CubismClippingContext.prototype.setGl = function (gl) {\n        this._owner.setGL(gl);\n    };\n    return CubismClippingContext;\n}());\n\n/**\n * WebGL用のシェーダープログラムを生成・破棄するクラス\n * シングルトンなクラスであり、CubismShader_WebGL.getInstanceからアクセスする。\n */\nvar CubismShader_WebGL = /** @class */ (function () {\n    /**\n     * privateなコンストラクタ\n     */\n    function CubismShader_WebGL() {\n        this._shaderSets = new _type_csmvector__WEBPACK_IMPORTED_MODULE_4__.csmVector();\n    }\n    /**\n     * インスタンスを取得する（シングルトン）\n     * @return インスタンス\n     */\n    CubismShader_WebGL.getInstance = function () {\n        if (s_instance == null) {\n            s_instance = new CubismShader_WebGL();\n            return s_instance;\n        }\n        return s_instance;\n    };\n    /**\n     * インスタンスを開放する（シングルトン）\n     */\n    CubismShader_WebGL.deleteInstance = function () {\n        if (s_instance) {\n            s_instance.release();\n            s_instance = null;\n        }\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismShader_WebGL.prototype.release = function () {\n        this.releaseShaderProgram();\n    };\n    /**\n     * シェーダープログラムの一連のセットアップを実行する\n     * @param renderer レンダラのインスタンス\n     * @param textureId GPUのテクスチャID\n     * @param vertexCount ポリゴンメッシュの頂点数\n     * @param vertexArray ポリゴンメッシュの頂点配列\n     * @param indexArray インデックスバッファの頂点配列\n     * @param uvArray uv配列\n     * @param opacity 不透明度\n     * @param colorBlendMode カラーブレンディングのタイプ\n     * @param baseColor ベースカラー\n     * @param isPremultipliedAlpha 乗算済みアルファかどうか\n     * @param matrix4x4 Model-View-Projection行列\n     * @param invertedMask マスクを反転して使用するフラグ\n     */\n    CubismShader_WebGL.prototype.setupShaderProgram = function (renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, multiplyColor, screenColor, isPremultipliedAlpha, matrix4x4, invertedMask) {\n        if (!isPremultipliedAlpha) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('NoPremultipliedAlpha is not allowed');\n        }\n        if (this._shaderSets.getSize() == 0) {\n            this.generateShaders();\n        }\n        // Blending\n        var SRC_COLOR;\n        var DST_COLOR;\n        var SRC_ALPHA;\n        var DST_ALPHA;\n        if (renderer.getClippingContextBufferForMask() != null) {\n            // マスク生成時\n            var shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_SetupMask);\n            this.gl.useProgram(shaderSet.shaderProgram);\n            // テクスチャ設定\n            this.gl.activeTexture(this.gl.TEXTURE0);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n            // 頂点配列の設定(VBO)\n            if (bufferData.vertex == null) {\n                bufferData.vertex = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // テクスチャ頂点の設定\n            if (bufferData.uv == null) {\n                bufferData.uv = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // チャンネル\n            var channelNo = renderer.getClippingContextBufferForMask()._layoutChannelNo;\n            var colorChannel = renderer\n                .getClippingContextBufferForMask()\n                .getClippingManager()\n                .getChannelFlagAsColor(channelNo);\n            this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n            this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForMask()._matrixForMask.getArray());\n            var rect = renderer.getClippingContextBufferForMask()._layoutBounds;\n            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2.0 - 1.0, rect.y * 2.0 - 1.0, rect.getRight() * 2.0 - 1.0, rect.getBottom() * 2.0 - 1.0);\n            this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n            this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n            SRC_COLOR = this.gl.ZERO;\n            DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;\n            SRC_ALPHA = this.gl.ZERO;\n            DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n        } // マスク生成以外の場合\n        else {\n            var masked = renderer.getClippingContextBufferForDraw() != null; // この描画オブジェクトはマスク対象か\n            var offset = masked ? (invertedMask ? 2 : 1) : 0;\n            var shaderSet = new CubismShaderSet();\n            switch (colorBlendMode) {\n                case _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismBlendMode.CubismBlendMode_Normal:\n                default:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.ONE;\n                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n                    SRC_ALPHA = this.gl.ONE;\n                    DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n                    break;\n                case _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismBlendMode.CubismBlendMode_Additive:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_AddPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.ONE;\n                    DST_COLOR = this.gl.ONE;\n                    SRC_ALPHA = this.gl.ZERO;\n                    DST_ALPHA = this.gl.ONE;\n                    break;\n                case _cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismBlendMode.CubismBlendMode_Multiplicative:\n                    shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_MultPremultipliedAlpha + offset);\n                    SRC_COLOR = this.gl.DST_COLOR;\n                    DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n                    SRC_ALPHA = this.gl.ZERO;\n                    DST_ALPHA = this.gl.ONE;\n                    break;\n            }\n            this.gl.useProgram(shaderSet.shaderProgram);\n            // 頂点配列の設定\n            if (bufferData.vertex == null) {\n                bufferData.vertex = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n            // テクスチャ頂点の設定\n            if (bufferData.uv == null) {\n                bufferData.uv = this.gl.createBuffer();\n            }\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n            this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n            this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n            this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n            if (masked) {\n                this.gl.activeTexture(this.gl.TEXTURE1);\n                var tex = renderer\n                    .getClippingContextBufferForDraw()\n                    .getClippingManager()\n                    .getColorBuffer();\n                this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n                this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);\n                // view座標をClippingContextの座標に変換するための行列を設定\n                this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray());\n                // 使用するカラーチャンネルを設定\n                var channelNo = renderer.getClippingContextBufferForDraw()._layoutChannelNo;\n                var colorChannel = renderer\n                    .getClippingContextBufferForDraw()\n                    .getClippingManager()\n                    .getChannelFlagAsColor(channelNo);\n                this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n            }\n            // テクスチャ設定\n            this.gl.activeTexture(this.gl.TEXTURE0);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n            this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n            // 座標変換\n            this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());\n            this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.R, baseColor.G, baseColor.B, baseColor.A);\n            this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.R, multiplyColor.G, multiplyColor.B, multiplyColor.A);\n            this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.R, screenColor.G, screenColor.B, screenColor.A);\n        }\n        // IBOを作成し、データを転送\n        if (bufferData.index == null) {\n            bufferData.index = this.gl.createBuffer();\n        }\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);\n        this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);\n    };\n    /**\n     * シェーダープログラムを解放する\n     */\n    CubismShader_WebGL.prototype.releaseShaderProgram = function () {\n        for (var i = 0; i < this._shaderSets.getSize(); i++) {\n            this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);\n            this._shaderSets.at(i).shaderProgram = 0;\n            this._shaderSets.set(i, void 0);\n            this._shaderSets.set(i, null);\n        }\n    };\n    /**\n     * シェーダープログラムを初期化する\n     * @param vertShaderSrc 頂点シェーダのソース\n     * @param fragShaderSrc フラグメントシェーダのソース\n     */\n    CubismShader_WebGL.prototype.generateShaders = function () {\n        for (var i = 0; i < shaderCount; i++) {\n            this._shaderSets.pushBack(new CubismShaderSet());\n        }\n        this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);\n        this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);\n        this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);\n        this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);\n        // 加算も通常と同じシェーダーを利用する\n        this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;\n        this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;\n        this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;\n        // 乗算も通常と同じシェーダーを利用する\n        this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;\n        this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;\n        this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;\n        // SetupMask\n        this._shaderSets.at(0).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_position');\n        this._shaderSets.at(0).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 's_texture0');\n        this._shaderSets.at(0).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(0).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(0).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(0).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(0).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, 'u_screenColor');\n        // 通常（PremultipliedAlpha）\n        this._shaderSets.at(1).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_position');\n        this._shaderSets.at(1).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 's_texture0');\n        this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_matrix');\n        this._shaderSets.at(1).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(1).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(1).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, 'u_screenColor');\n        // 通常（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(2).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_position');\n        this._shaderSets.at(2).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture0');\n        this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 's_texture1');\n        this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_matrix');\n        this._shaderSets.at(2).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(2).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(2).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(2).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(2).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, 'u_screenColor');\n        // 通常（クリッピング・反転, PremultipliedAlpha）\n        this._shaderSets.at(3).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_position');\n        this._shaderSets.at(3).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture0');\n        this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 's_texture1');\n        this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_matrix');\n        this._shaderSets.at(3).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(3).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(3).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(3).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(3).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, 'u_screenColor');\n        // 加算（PremultipliedAlpha）\n        this._shaderSets.at(4).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_position');\n        this._shaderSets.at(4).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 's_texture0');\n        this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_matrix');\n        this._shaderSets.at(4).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(4).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(4).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, 'u_screenColor');\n        // 加算（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(5).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_position');\n        this._shaderSets.at(5).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture0');\n        this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 's_texture1');\n        this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_matrix');\n        this._shaderSets.at(5).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(5).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(5).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(5).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(5).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, 'u_screenColor');\n        // 加算（クリッピング・反転、PremultipliedAlpha）\n        this._shaderSets.at(6).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_position');\n        this._shaderSets.at(6).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture0');\n        this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 's_texture1');\n        this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_matrix');\n        this._shaderSets.at(6).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(6).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(6).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(6).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(6).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, 'u_screenColor');\n        // 乗算（PremultipliedAlpha）\n        this._shaderSets.at(7).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_position');\n        this._shaderSets.at(7).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 's_texture0');\n        this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_matrix');\n        this._shaderSets.at(7).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(7).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(7).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, 'u_screenColor');\n        // 乗算（クリッピング、PremultipliedAlpha）\n        this._shaderSets.at(8).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_position');\n        this._shaderSets.at(8).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture0');\n        this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 's_texture1');\n        this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_matrix');\n        this._shaderSets.at(8).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(8).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(8).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(8).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(8).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, 'u_screenColor');\n        // 乗算（クリッピング・反転、PremultipliedAlpha）\n        this._shaderSets.at(9).attributePositionLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_position');\n        this._shaderSets.at(9).attributeTexCoordLocation =\n            this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, 'a_texCoord');\n        this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture0');\n        this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 's_texture1');\n        this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_matrix');\n        this._shaderSets.at(9).uniformClipMatrixLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_clipMatrix');\n        this._shaderSets.at(9).uniformChannelFlagLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_channelFlag');\n        this._shaderSets.at(9).uniformBaseColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_baseColor');\n        this._shaderSets.at(9).uniformMultiplyColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_multiplyColor');\n        this._shaderSets.at(9).uniformScreenColorLocation =\n            this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, 'u_screenColor');\n    };\n    /**\n     * シェーダプログラムをロードしてアドレスを返す\n     * @param vertexShaderSource    頂点シェーダのソース\n     * @param fragmentShaderSource  フラグメントシェーダのソース\n     * @return シェーダプログラムのアドレス\n     */\n    CubismShader_WebGL.prototype.loadShaderProgram = function (vertexShaderSource, fragmentShaderSource) {\n        // Create Shader Program\n        var shaderProgram = this.gl.createProgram();\n        var vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);\n        if (!vertShader) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('Vertex shader compile error!');\n            return 0;\n        }\n        var fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n        if (!fragShader) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('Vertex shader compile error!');\n            return 0;\n        }\n        // Attach vertex shader to program\n        this.gl.attachShader(shaderProgram, vertShader);\n        // Attach fragment shader to program\n        this.gl.attachShader(shaderProgram, fragShader);\n        // link program\n        this.gl.linkProgram(shaderProgram);\n        var linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);\n        // リンクに失敗したらシェーダーを削除\n        if (!linkStatus) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('Failed to link program: {0}', shaderProgram);\n            this.gl.deleteShader(vertShader);\n            vertShader = 0;\n            this.gl.deleteShader(fragShader);\n            fragShader = 0;\n            if (shaderProgram) {\n                this.gl.deleteProgram(shaderProgram);\n                shaderProgram = 0;\n            }\n            return 0;\n        }\n        // Release vertex and fragment shaders.\n        this.gl.deleteShader(vertShader);\n        this.gl.deleteShader(fragShader);\n        return shaderProgram;\n    };\n    /**\n     * シェーダープログラムをコンパイルする\n     * @param shaderType シェーダタイプ(Vertex/Fragment)\n     * @param shaderSource シェーダソースコード\n     *\n     * @return コンパイルされたシェーダープログラム\n     */\n    CubismShader_WebGL.prototype.compileShaderSource = function (shaderType, shaderSource) {\n        var source = shaderSource;\n        var shader = this.gl.createShader(shaderType);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!shader) {\n            var log = this.gl.getShaderInfoLog(shader);\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_5__.CubismLogError)('Shader compile log: {0} ', log);\n        }\n        var status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\n        if (!status) {\n            this.gl.deleteShader(shader);\n            return null;\n        }\n        return shader;\n    };\n    CubismShader_WebGL.prototype.setGl = function (gl) {\n        this.gl = gl;\n    };\n    return CubismShader_WebGL;\n}());\n\n/**\n * CubismShader_WebGLのインナークラス\n */\nvar CubismShaderSet = /** @class */ (function () {\n    function CubismShaderSet() {\n    }\n    return CubismShaderSet;\n}());\n\nvar ShaderNames;\n(function (ShaderNames) {\n    // SetupMask\n    ShaderNames[ShaderNames[\"ShaderNames_SetupMask\"] = 0] = \"ShaderNames_SetupMask\";\n    // Normal\n    ShaderNames[ShaderNames[\"ShaderNames_NormalPremultipliedAlpha\"] = 1] = \"ShaderNames_NormalPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_NormalMaskedPremultipliedAlpha\"] = 2] = \"ShaderNames_NormalMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\"] = 3] = \"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\";\n    // Add\n    ShaderNames[ShaderNames[\"ShaderNames_AddPremultipliedAlpha\"] = 4] = \"ShaderNames_AddPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlpha\"] = 5] = \"ShaderNames_AddMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_AddMaskedPremultipliedAlphaInverted\"] = 6] = \"ShaderNames_AddMaskedPremultipliedAlphaInverted\";\n    // Mult\n    ShaderNames[ShaderNames[\"ShaderNames_MultPremultipliedAlpha\"] = 7] = \"ShaderNames_MultPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlpha\"] = 8] = \"ShaderNames_MultMaskedPremultipliedAlpha\";\n    ShaderNames[ShaderNames[\"ShaderNames_MultMaskedPremultipliedAlphaInverted\"] = 9] = \"ShaderNames_MultMaskedPremultipliedAlphaInverted\";\n})(ShaderNames || (ShaderNames = {}));\nvar vertexShaderSrcSetupMask = 'attribute vec4     a_position;' +\n    'attribute vec2     a_texCoord;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_myPos;' +\n    'uniform mat4       u_clipMatrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_clipMatrix * a_position;' +\n    '   v_myPos = u_clipMatrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\nvar fragmentShaderSrcsetupMask = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_myPos;' +\n    'uniform vec4       u_baseColor;' +\n    'uniform vec4       u_channelFlag;' +\n    'uniform sampler2D  s_texture0;' +\n    'void main()' +\n    '{' +\n    '   float isInside = ' +\n    '       step(u_baseColor.x, v_myPos.x/v_myPos.w)' +\n    '       * step(u_baseColor.y, v_myPos.y/v_myPos.w)' +\n    '       * step(v_myPos.x/v_myPos.w, u_baseColor.z)' +\n    '       * step(v_myPos.y/v_myPos.w, u_baseColor.w);' +\n    '   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;' +\n    '}';\n//----- バーテックスシェーダプログラム -----\n// Normal & Add & Mult 共通\nvar vertexShaderSrc = 'attribute vec4     a_position;' + //v.vertex\n    'attribute vec2     a_texCoord;' + //v.texcoord\n    'varying vec2       v_texCoord;' + //v2f.texcoord\n    'uniform mat4       u_matrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_matrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\n// Normal & Add & Mult 共通（クリッピングされたものの描画用）\nvar vertexShaderSrcMasked = 'attribute vec4     a_position;' +\n    'attribute vec2     a_texCoord;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_clipPos;' +\n    'uniform mat4       u_matrix;' +\n    'uniform mat4       u_clipMatrix;' +\n    'void main()' +\n    '{' +\n    '   gl_Position = u_matrix * a_position;' +\n    '   v_clipPos = u_clipMatrix * a_position;' +\n    '   v_texCoord = a_texCoord;' +\n    '   v_texCoord.y = 1.0 - v_texCoord.y;' +\n    '}';\n//----- フラグメントシェーダプログラム -----\n// Normal & Add & Mult 共通 （PremultipliedAlpha）\nvar fragmentShaderSrcPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' + //v2f.texcoord\n    'uniform vec4       u_baseColor;' +\n    'uniform sampler2D  s_texture0;' + //_MainTex\n    'uniform vec4       u_multiplyColor;' +\n    'uniform vec4       u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 color = texColor * u_baseColor;' +\n    '   gl_FragColor = vec4(color.rgb, color.a);' +\n    '}';\n// Normal （クリッピングされたものの描画用、PremultipliedAlpha兼用）\nvar fragmentShaderSrcMaskPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2       v_texCoord;' +\n    'varying vec4       v_clipPos;' +\n    'uniform vec4       u_baseColor;' +\n    'uniform vec4       u_channelFlag;' +\n    'uniform sampler2D  s_texture0;' +\n    'uniform sampler2D  s_texture1;' +\n    'uniform vec4       u_multiplyColor;' +\n    'uniform vec4       u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 col_formask = texColor * u_baseColor;' +\n    '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n    '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n    '   col_formask = col_formask * maskVal;' +\n    '   gl_FragColor = col_formask;' +\n    '}';\n// Normal & Add & Mult 共通（クリッピングされて反転使用の描画用、PremultipliedAlphaの場合）\nvar fragmentShaderSrcMaskInvertedPremultipliedAlpha = 'precision mediump float;' +\n    'varying vec2      v_texCoord;' +\n    'varying vec4      v_clipPos;' +\n    'uniform sampler2D s_texture0;' +\n    'uniform sampler2D s_texture1;' +\n    'uniform vec4      u_channelFlag;' +\n    'uniform vec4      u_baseColor;' +\n    'uniform vec4      u_multiplyColor;' +\n    'uniform vec4      u_screenColor;' +\n    'void main()' +\n    '{' +\n    '   vec4 texColor = texture2D(s_texture0, v_texCoord);' +\n    '   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;' +\n    '   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);' +\n    '   vec4 col_formask = texColor * u_baseColor;' +\n    '   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;' +\n    '   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;' +\n    '   col_formask = col_formask * (1.0 - maskVal);' +\n    '   gl_FragColor = col_formask;' +\n    '}';\n/**\n * WebGL用の描画命令を実装したクラス\n */\nvar CubismRenderer_WebGL = /** @class */ (function (_super) {\n    __extends(CubismRenderer_WebGL, _super);\n    /**\n     * コンストラクタ\n     */\n    function CubismRenderer_WebGL() {\n        var _this = _super.call(this) || this;\n        _this._clippingContextBufferForMask = null;\n        _this._clippingContextBufferForDraw = null;\n        _this._clippingManager = new CubismClippingManager_WebGL();\n        _this.firstDraw = true;\n        _this._textures = new _type_csmmap__WEBPACK_IMPORTED_MODULE_2__.csmMap();\n        _this._sortedDrawableIndexList = new _type_csmvector__WEBPACK_IMPORTED_MODULE_4__.csmVector();\n        _this._bufferData = {\n            vertex: (WebGLBuffer = null),\n            uv: (WebGLBuffer = null),\n            index: (WebGLBuffer = null),\n        };\n        // テクスチャ対応マップの容量を確保しておく\n        _this._textures.prepareCapacity(32, true);\n        return _this;\n    }\n    /**\n     * レンダラの初期化処理を実行する\n     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる\n     *\n     * @param model モデルのインスタンス\n     */\n    CubismRenderer_WebGL.prototype.initialize = function (model) {\n        if (model.isUsingMasking()) {\n            this._clippingManager = new CubismClippingManager_WebGL(); // クリッピングマスク・バッファ前処理方式を初期化\n            this._clippingManager.initialize(model, model.getDrawableCount(), model.getDrawableMasks(), model.getDrawableMaskCounts());\n        }\n        this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);\n        _super.prototype.initialize.call(this, model); // 親クラスの処理を呼ぶ\n    };\n    /**\n     * WebGLテクスチャのバインド処理\n     * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする\n     * @param modelTextureNo セットするモデルテクスチャの番号\n     * @param glTextureNo WebGLテクスチャの番号\n     */\n    CubismRenderer_WebGL.prototype.bindTexture = function (modelTextureNo, glTexture) {\n        this._textures.setValue(modelTextureNo, glTexture);\n    };\n    /**\n     * WebGLにバインドされたテクスチャのリストを取得する\n     * @return テクスチャのリスト\n     */\n    CubismRenderer_WebGL.prototype.getBindedTextures = function () {\n        return this._textures;\n    };\n    /**\n     * クリッピングマスクバッファのサイズを設定する\n     * マスク用のFrameBufferを破棄、再作成する為処理コストは高い\n     * @param size クリッピングマスクバッファのサイズ\n     */\n    CubismRenderer_WebGL.prototype.setClippingMaskBufferSize = function (size) {\n        // FrameBufferのサイズを変更するためにインスタンスを破棄・再作成する\n        this._clippingManager.release();\n        this._clippingManager = void 0;\n        this._clippingManager = null;\n        this._clippingManager = new CubismClippingManager_WebGL();\n        this._clippingManager.setClippingMaskBufferSize(size);\n        this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts());\n    };\n    /**\n     * クリッピングマスクバッファのサイズを取得する\n     * @return クリッピングマスクバッファのサイズ\n     */\n    CubismRenderer_WebGL.prototype.getClippingMaskBufferSize = function () {\n        return this._clippingManager.getClippingMaskBufferSize();\n    };\n    /**\n     * デストラクタ相当の処理\n     */\n    CubismRenderer_WebGL.prototype.release = function () {\n        this._clippingManager.release();\n        this._clippingManager = void 0;\n        this._clippingManager = null;\n        this.gl.deleteBuffer(this._bufferData.vertex);\n        this._bufferData.vertex = null;\n        this.gl.deleteBuffer(this._bufferData.uv);\n        this._bufferData.uv = null;\n        this.gl.deleteBuffer(this._bufferData.index);\n        this._bufferData.index = null;\n        this._bufferData = null;\n        this._textures = null;\n    };\n    /**\n     * モデルを描画する実際の処理\n     */\n    CubismRenderer_WebGL.prototype.doDrawModel = function () {\n        //------------ クリッピングマスク・バッファ前処理方式の場合 ------------\n        if (this._clippingManager != null) {\n            this.preDraw();\n            this._clippingManager.setupClippingContext(this.getModel(), this);\n        }\n        // 上記クリッピング処理内でも一度PreDrawを呼ぶので注意!!\n        this.preDraw();\n        var drawableCount = this.getModel().getDrawableCount();\n        var renderOrder = this.getModel().getDrawableRenderOrders();\n        // インデックスを描画順でソート\n        for (var i = 0; i < drawableCount; ++i) {\n            var order = renderOrder[i];\n            this._sortedDrawableIndexList.set(order, i);\n        }\n        // 描画\n        for (var i = 0; i < drawableCount; ++i) {\n            var drawableIndex = this._sortedDrawableIndexList.at(i);\n            // Drawableが表示状態でなければ処理をパスする\n            if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {\n                continue;\n            }\n            // クリッピングマスクをセットする\n            this.setClippingContextBufferForDraw(this._clippingManager != null\n                ? this._clippingManager\n                    .getClippingContextListForDraw()\n                    .at(drawableIndex)\n                : null);\n            this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));\n            this.drawMesh(this.getModel().getDrawableTextureIndex(drawableIndex), this.getModel().getDrawableVertexIndexCount(drawableIndex), this.getModel().getDrawableVertexCount(drawableIndex), this.getModel().getDrawableVertexIndices(drawableIndex), this.getModel().getDrawableVertices(drawableIndex), this.getModel().getDrawableVertexUvs(drawableIndex), this.getModel().getMultiplyColor(drawableIndex), this.getModel().getScreenColor(drawableIndex), this.getModel().getDrawableOpacity(drawableIndex), this.getModel().getDrawableBlendMode(drawableIndex), this.getModel().getDrawableInvertedMaskBit(drawableIndex));\n        }\n    };\n    /**\n     * [オーバーライド]\n     * 描画オブジェクト（アートメッシュ）を描画する。\n     * ポリゴンメッシュとテクスチャ番号をセットで渡す。\n     * @param textureNo 描画するテクスチャ番号\n     * @param indexCount 描画オブジェクトのインデックス値\n     * @param vertexCount ポリゴンメッシュの頂点数\n     * @param indexArray ポリゴンメッシュのインデックス配列\n     * @param vertexArray ポリゴンメッシュの頂点配列\n     * @param uvArray uv配列\n     * @param opacity 不透明度\n     * @param colorBlendMode カラー合成タイプ\n     * @param invertedMask マスク使用時のマスクの反転使用\n     */\n    CubismRenderer_WebGL.prototype.drawMesh = function (textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, multiplyColor, screenColor, opacity, colorBlendMode, invertedMask) {\n        // 裏面描画の有効・無効\n        if (this.isCulling()) {\n            this.gl.enable(this.gl.CULL_FACE);\n        }\n        else {\n            this.gl.disable(this.gl.CULL_FACE);\n        }\n        this.gl.frontFace(this.gl.CCW); // Cubism SDK OpenGLはマスク・アートメッシュ共にCCWが表面\n        var modelColorRGBA = this.getModelColor();\n        if (this.getClippingContextBufferForMask() == null) {\n            // マスク生成時以外\n            modelColorRGBA.A *= opacity;\n            if (this.isPremultipliedAlpha()) {\n                modelColorRGBA.R *= modelColorRGBA.A;\n                modelColorRGBA.G *= modelColorRGBA.A;\n                modelColorRGBA.B *= modelColorRGBA.A;\n            }\n        }\n        var drawtexture; // シェーダに渡すテクスチャ\n        // テクスチャマップからバインド済みテクスチャＩＤを取得\n        // バインドされていなければダミーのテクスチャIDをセットする\n        if (this._textures.getValue(textureNo) != null) {\n            drawtexture = this._textures.getValue(textureNo);\n        }\n        else {\n            drawtexture = null;\n        }\n        CubismShader_WebGL.getInstance().setupShaderProgram(this, drawtexture, vertexCount, vertexArray, indexArray, uvArray, this._bufferData, opacity, colorBlendMode, modelColorRGBA, multiplyColor, screenColor, this.isPremultipliedAlpha(), this.getMvpMatrix(), invertedMask);\n        // ポリゴンメッシュを描画する\n        this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);\n        // 後処理\n        this.gl.useProgram(null);\n        this.setClippingContextBufferForDraw(null);\n        this.setClippingContextBufferForMask(null);\n    };\n    /**\n     * レンダラが保持する静的なリソースを解放する\n     * WebGLの静的なシェーダープログラムを解放する\n     */\n    CubismRenderer_WebGL.doStaticRelease = function () {\n        CubismShader_WebGL.deleteInstance();\n    };\n    /**\n     * レンダーステートを設定する\n     * @param fbo アプリケーション側で指定しているフレームバッファ\n     * @param viewport ビューポート\n     */\n    CubismRenderer_WebGL.prototype.setRenderState = function (fbo, viewport) {\n        s_fbo = fbo;\n        s_viewport = viewport;\n    };\n    /**\n     * 描画開始時の追加処理\n     * モデルを描画する前にクリッピングマスクに必要な処理を実装している\n     */\n    CubismRenderer_WebGL.prototype.preDraw = function () {\n        if (this.firstDraw) {\n            this.firstDraw = false;\n        }\n        this.gl.disable(this.gl.SCISSOR_TEST);\n        this.gl.disable(this.gl.STENCIL_TEST);\n        this.gl.disable(this.gl.DEPTH_TEST);\n        // カリング（1.0beta3）\n        this.gl.frontFace(this.gl.CW);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.colorMask(true, true, true, true);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // 前にバッファがバインドされていたら破棄する必要がある\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n        // 異方性フィルタリングを適用する\n        if (this.getAnisotropy() > 0.0 && this._extension) {\n            for (var i = 0; i < this._textures.getSize(); ++i) {\n                this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));\n                this.gl.texParameterf(this.gl.TEXTURE_2D, this._extension.TEXTURE_MAX_ANISOTROPY_EXT, this.getAnisotropy());\n            }\n        }\n    };\n    /**\n     * マスクテクスチャに描画するクリッピングコンテキストをセットする\n     */\n    CubismRenderer_WebGL.prototype.setClippingContextBufferForMask = function (clip) {\n        this._clippingContextBufferForMask = clip;\n    };\n    /**\n     * マスクテクスチャに描画するクリッピングコンテキストを取得する\n     * @return マスクテクスチャに描画するクリッピングコンテキスト\n     */\n    CubismRenderer_WebGL.prototype.getClippingContextBufferForMask = function () {\n        return this._clippingContextBufferForMask;\n    };\n    /**\n     * 画面上に描画するクリッピングコンテキストをセットする\n     */\n    CubismRenderer_WebGL.prototype.setClippingContextBufferForDraw = function (clip) {\n        this._clippingContextBufferForDraw = clip;\n    };\n    /**\n     * 画面上に描画するクリッピングコンテキストを取得する\n     * @return 画面上に描画するクリッピングコンテキスト\n     */\n    CubismRenderer_WebGL.prototype.getClippingContextBufferForDraw = function () {\n        return this._clippingContextBufferForDraw;\n    };\n    /**\n     * glの設定\n     */\n    CubismRenderer_WebGL.prototype.startUp = function (gl) {\n        this.gl = gl;\n        this._clippingManager.setGL(gl);\n        CubismShader_WebGL.getInstance().setGl(gl);\n        // 異方性フィルタリングが使用できるかチェック\n        this._extension =\n            this.gl.getExtension('EXT_texture_filter_anisotropic') ||\n                this.gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||\n                this.gl.getExtension('MOZ_EXT_texture_filter_anisotropic');\n    };\n    return CubismRenderer_WebGL;\n}(_cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismRenderer));\n\n/**\n * レンダラが保持する静的なリソースを開放する\n */\n_cubismrenderer__WEBPACK_IMPORTED_MODULE_6__.CubismRenderer.staticRelease = function () {\n    CubismRenderer_WebGL.doStaticRelease();\n};\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismClippingContext = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismClippingContext;\n    Live2DCubismFramework.CubismClippingManager_WebGL = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismClippingManager_WebGL;\n    Live2DCubismFramework.CubismRenderTextureResource = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismRenderTextureResource;\n    Live2DCubismFramework.CubismRenderer_WebGL = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismRenderer_WebGL;\n    Live2DCubismFramework.CubismShaderSet = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismShaderSet;\n    Live2DCubismFramework.CubismShader_WebGL = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.CubismShader_WebGL;\n    Live2DCubismFramework.ShaderNames = _cubismrenderer_webgl__WEBPACK_IMPORTED_MODULE_7__.ShaderNames;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/rendering/cubismrenderer_webgl.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/type/csmmap.ts":
/*!*************************************************!*\
  !*** ./src/lib/live2d/Framework/type/csmmap.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"csmMap\": () => (/* binding */ csmMap),\n/* harmony export */   \"csmPair\": () => (/* binding */ csmPair),\n/* harmony export */   \"iterator\": () => (/* binding */ iterator)\n/* harmony export */ });\n/* harmony import */ var _utils_cubismdebug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _csmmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csmmap */ \"./src/lib/live2d/Framework/type/csmmap.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * Key-Valueのペアを定義するクラス\n * csmMapクラスの内部データで使用する。\n */\nvar csmPair = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param key Keyとしてセットする値\n     * @param value Valueとしてセットする値\n     */\n    function csmPair(key, value) {\n        this.first = key == undefined ? null : key;\n        this.second = value == undefined ? null : value;\n    }\n    return csmPair;\n}());\n\n/**\n * マップ型\n */\nvar csmMap = /** @class */ (function () {\n    /**\n     * 引数付きコンストラクタ\n     * @param size 初期化時点で確保するサイズ\n     */\n    function csmMap(size) {\n        if (size != undefined) {\n            if (size < 1) {\n                this._keyValues = [];\n                this._dummyValue = null;\n                this._size = 0;\n            }\n            else {\n                this._keyValues = new Array(size);\n                this._size = size;\n            }\n        }\n        else {\n            this._keyValues = [];\n            this._dummyValue = null;\n            this._size = 0;\n        }\n    }\n    /**\n     * デストラクタ\n     */\n    csmMap.prototype.release = function () {\n        this.clear();\n    };\n    /**\n     * キーを追加する\n     * @param key 新たに追加するキー\n     */\n    csmMap.prototype.appendKey = function (key) {\n        // 新しくKey/Valueのペアを作る\n        this.prepareCapacity(this._size + 1, false); // 1つ以上入る隙間を作る\n        // 新しいkey/valueのインデックスは_size\n        this._keyValues[this._size] = new csmPair(key);\n        this._size += 1;\n    };\n    /**\n     * 添字演算子[key]のオーバーロード(get)\n     * @param key 添字から特定されるValue値\n     */\n    csmMap.prototype.getValue = function (key) {\n        var found = -1;\n        for (var i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                found = i;\n                break;\n            }\n        }\n        if (found >= 0) {\n            return this._keyValues[found].second;\n        }\n        else {\n            this.appendKey(key); // 新規キーを追加\n            return this._keyValues[this._size - 1].second;\n        }\n    };\n    /**\n     * 添字演算子[key]のオーバーロード(set)\n     * @param key 添字から特定されるValue値\n     * @param value 代入するValue値\n     */\n    csmMap.prototype.setValue = function (key, value) {\n        var found = -1;\n        for (var i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                found = i;\n                break;\n            }\n        }\n        if (found >= 0) {\n            this._keyValues[found].second = value;\n        }\n        else {\n            this.appendKey(key); // 新規キーを追加\n            this._keyValues[this._size - 1].second = value;\n        }\n    };\n    /**\n     * 引数で渡したKeyを持つ要素が存在するか\n     * @param key 存在を確認するkey\n     * @return true 引数で渡したkeyを持つ要素が存在する\n     * @return false 引数で渡したkeyを持つ要素が存在しない\n     */\n    csmMap.prototype.isExist = function (key) {\n        for (var i = 0; i < this._size; i++) {\n            if (this._keyValues[i].first == key) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * keyValueのポインタを全て解放する\n     */\n    csmMap.prototype.clear = function () {\n        this._keyValues = void 0;\n        this._keyValues = null;\n        this._keyValues = [];\n        this._size = 0;\n    };\n    /**\n     * コンテナのサイズを取得する\n     *\n     * @return コンテナのサイズ\n     */\n    csmMap.prototype.getSize = function () {\n        return this._size;\n    };\n    /**\n     * コンテナのキャパシティを確保する\n     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない。\n     * @param fitToSize trueなら指定したサイズに合わせる。falseならサイズを2倍確保しておく。\n     */\n    csmMap.prototype.prepareCapacity = function (newSize, fitToSize) {\n        if (newSize > this._keyValues.length) {\n            if (this._keyValues.length == 0) {\n                if (!fitToSize && newSize < csmMap.DefaultSize)\n                    newSize = csmMap.DefaultSize;\n                this._keyValues.length = newSize;\n            }\n            else {\n                if (!fitToSize && newSize < this._keyValues.length * 2)\n                    newSize = this._keyValues.length * 2;\n                this._keyValues.length = newSize;\n            }\n        }\n    };\n    /**\n     * コンテナの先頭要素を返す\n     */\n    csmMap.prototype.begin = function () {\n        var ite = new iterator(this, 0);\n        return ite;\n    };\n    /**\n     * コンテナの終端要素を返す\n     */\n    csmMap.prototype.end = function () {\n        var ite = new iterator(this, this._size); // 終了\n        return ite;\n    };\n    /**\n     * コンテナから要素を削除する\n     *\n     * @param ite 削除する要素\n     */\n    csmMap.prototype.erase = function (ite) {\n        var index = ite._index;\n        if (index < 0 || this._size <= index) {\n            return ite; // 削除範囲外\n        }\n        // 削除\n        this._keyValues.splice(index, 1);\n        --this._size;\n        var ite2 = new iterator(this, index); // 終了\n        return ite2;\n    };\n    /**\n     * コンテナの値を32ビット符号付き整数型でダンプする\n     */\n    csmMap.prototype.dumpAsInt = function () {\n        for (var i = 0; i < this._size; i++) {\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_0__.CubismLogDebug)('{0} ,', this._keyValues[i]);\n            (0,_utils_cubismdebug__WEBPACK_IMPORTED_MODULE_0__.CubismLogDebug)('\\n');\n        }\n    };\n    csmMap.DefaultSize = 10; // コンテナの初期化のデフォルトサイズ\n    return csmMap;\n}());\n\n/**\n * csmMap<T>のイテレータ\n */\nvar iterator = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function iterator(v, idx) {\n        this._map = v != undefined ? v : new csmMap();\n        this._index = idx != undefined ? idx : 0;\n    }\n    /**\n     * =演算子のオーバーロード\n     */\n    iterator.prototype.set = function (ite) {\n        this._index = ite._index;\n        this._map = ite._map;\n        return this;\n    };\n    /**\n     * 前置き++演算子のオーバーロード\n     */\n    iterator.prototype.preIncrement = function () {\n        ++this._index;\n        return this;\n    };\n    /**\n     * 前置き--演算子のオーバーロード\n     */\n    iterator.prototype.preDecrement = function () {\n        --this._index;\n        return this;\n    };\n    /**\n     * 後置き++演算子のオーバーロード\n     */\n    iterator.prototype.increment = function () {\n        var iteold = new iterator(this._map, this._index++); // 古い値を保存\n        return iteold;\n    };\n    /**\n     * 後置き--演算子のオーバーロード\n     */\n    iterator.prototype.decrement = function () {\n        var iteold = new iterator(this._map, this._index); // 古い値を保存\n        this._map = iteold._map;\n        this._index = iteold._index;\n        return this;\n    };\n    /**\n     * *演算子のオーバーロード\n     */\n    iterator.prototype.ptr = function () {\n        return this._map._keyValues[this._index];\n    };\n    /**\n     * !=演算\n     */\n    iterator.prototype.notEqual = function (ite) {\n        return this._index != ite._index || this._map != ite._map;\n    };\n    return iterator;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmMap = _csmmap__WEBPACK_IMPORTED_MODULE_1__.csmMap;\n    Live2DCubismFramework.csmPair = _csmmap__WEBPACK_IMPORTED_MODULE_1__.csmPair;\n    Live2DCubismFramework.iterator = _csmmap__WEBPACK_IMPORTED_MODULE_1__.iterator;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/type/csmmap.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/type/csmrectf.ts":
/*!***************************************************!*\
  !*** ./src/lib/live2d/Framework/type/csmrectf.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"csmRect\": () => (/* binding */ csmRect)\n/* harmony export */ });\n/* harmony import */ var _csmrectf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./csmrectf */ \"./src/lib/live2d/Framework/type/csmrectf.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 矩形形状（座標・長さはfloat値）を定義するクラス\n */\nvar csmRect = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     * @param x 左端X座標\n     * @param y 上端Y座標\n     * @param w 幅\n     * @param h 高さ\n     */\n    function csmRect(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n    }\n    /**\n     * 矩形中央のX座標を取得する\n     */\n    csmRect.prototype.getCenterX = function () {\n        return this.x + 0.5 * this.width;\n    };\n    /**\n     * 矩形中央のY座標を取得する\n     */\n    csmRect.prototype.getCenterY = function () {\n        return this.y + 0.5 * this.height;\n    };\n    /**\n     * 右側のX座標を取得する\n     */\n    csmRect.prototype.getRight = function () {\n        return this.x + this.width;\n    };\n    /**\n     * 下端のY座標を取得する\n     */\n    csmRect.prototype.getBottom = function () {\n        return this.y + this.height;\n    };\n    /**\n     * 矩形に値をセットする\n     * @param r 矩形のインスタンス\n     */\n    csmRect.prototype.setRect = function (r) {\n        this.x = r.x;\n        this.y = r.y;\n        this.width = r.width;\n        this.height = r.height;\n    };\n    /**\n     * 矩形中央を軸にして縦横を拡縮する\n     * @param w 幅方向に拡縮する量\n     * @param h 高さ方向に拡縮する量\n     */\n    csmRect.prototype.expand = function (w, h) {\n        this.x -= w;\n        this.y -= h;\n        this.width += w * 2.0;\n        this.height += h * 2.0;\n    };\n    return csmRect;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmRect = _csmrectf__WEBPACK_IMPORTED_MODULE_0__.csmRect;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/type/csmrectf.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/type/csmstring.ts":
/*!****************************************************!*\
  !*** ./src/lib/live2d/Framework/type/csmstring.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"csmString\": () => (/* binding */ csmString)\n/* harmony export */ });\n/* harmony import */ var _csmstring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * 文字列クラス。\n */\nvar csmString = /** @class */ (function () {\n    /**\n     * 引数付きコンストラクタ\n     */\n    function csmString(s) {\n        this.s = s;\n    }\n    /**\n     * 文字列を後方に追加する\n     *\n     * @param c 追加する文字列\n     * @return 更新された文字列\n     */\n    csmString.prototype.append = function (c, length) {\n        this.s += length !== undefined ? c.substr(0, length) : c;\n        return this;\n    };\n    /**\n     * 文字サイズを拡張して文字を埋める\n     * @param length    拡張する文字数\n     * @param v         埋める文字\n     * @return 更新された文字列\n     */\n    csmString.prototype.expansion = function (length, v) {\n        for (var i = 0; i < length; i++) {\n            this.append(v);\n        }\n        return this;\n    };\n    /**\n     * 文字列の長さをバイト数で取得する\n     */\n    csmString.prototype.getBytes = function () {\n        return encodeURIComponent(this.s).replace(/%../g, 'x').length;\n    };\n    /**\n     * 文字列の長さを返す\n     */\n    csmString.prototype.getLength = function () {\n        return this.s.length;\n    };\n    /**\n     * 文字列比較 <\n     * @param s 比較する文字列\n     * @return true:    比較する文字列より小さい\n     * @return false:   比較する文字列より大きい\n     */\n    csmString.prototype.isLess = function (s) {\n        return this.s < s.s;\n    };\n    /**\n     * 文字列比較 >\n     * @param s 比較する文字列\n     * @return true:    比較する文字列より大きい\n     * @return false:   比較する文字列より小さい\n     */\n    csmString.prototype.isGreat = function (s) {\n        return this.s > s.s;\n    };\n    /**\n     * 文字列比較 ==\n     * @param s 比較する文字列\n     * @return true:    比較する文字列と等しい\n     * @return false:   比較する文字列と異なる\n     */\n    csmString.prototype.isEqual = function (s) {\n        return this.s == s;\n    };\n    /**\n     * 文字列が空かどうか\n     * @return true: 空の文字列\n     * @return false: 値が設定されている\n     */\n    csmString.prototype.isEmpty = function () {\n        return this.s.length == 0;\n    };\n    return csmString;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmString = _csmstring__WEBPACK_IMPORTED_MODULE_0__.csmString;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/type/csmstring.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/type/csmvector.ts":
/*!****************************************************!*\
  !*** ./src/lib/live2d/Framework/type/csmvector.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"csmVector\": () => (/* binding */ csmVector),\n/* harmony export */   \"iterator\": () => (/* binding */ iterator)\n/* harmony export */ });\n/* harmony import */ var _csmvector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n/**\n * ベクター型（可変配列型）\n */\nvar csmVector = /** @class */ (function () {\n    /**\n     * 引数付きコンストラクタ\n     * @param iniitalCapacity 初期化後のキャパシティ。データサイズは_capacity * sizeof(T)\n     * @param zeroClear trueなら初期化時に確保した領域を0で埋める\n     */\n    function csmVector(initialCapacity) {\n        if (initialCapacity === void 0) { initialCapacity = 0; }\n        if (initialCapacity < 1) {\n            this._ptr = [];\n            this._capacity = 0;\n            this._size = 0;\n        }\n        else {\n            this._ptr = new Array(initialCapacity);\n            this._capacity = initialCapacity;\n            this._size = 0;\n        }\n    }\n    /**\n     * インデックスで指定した要素を返す\n     */\n    csmVector.prototype.at = function (index) {\n        return this._ptr[index];\n    };\n    /**\n     * 要素をセット\n     * @param index 要素をセットするインデックス\n     * @param value セットする要素\n     */\n    csmVector.prototype.set = function (index, value) {\n        this._ptr[index] = value;\n    };\n    /**\n     * コンテナを取得する\n     */\n    csmVector.prototype.get = function (offset) {\n        if (offset === void 0) { offset = 0; }\n        var ret = new Array();\n        for (var i = offset; i < this._size; i++) {\n            ret.push(this._ptr[i]);\n        }\n        return ret;\n    };\n    /**\n     * pushBack処理、コンテナに新たな要素を追加する\n     * @param value PushBack処理で追加する値\n     */\n    csmVector.prototype.pushBack = function (value) {\n        if (this._size >= this._capacity) {\n            this.prepareCapacity(this._capacity == 0 ? csmVector.s_defaultSize : this._capacity * 2);\n        }\n        this._ptr[this._size++] = value;\n    };\n    /**\n     * コンテナの全要素を解放する\n     */\n    csmVector.prototype.clear = function () {\n        this._ptr.length = 0;\n        this._size = 0;\n    };\n    /**\n     * コンテナの要素数を返す\n     * @return コンテナの要素数\n     */\n    csmVector.prototype.getSize = function () {\n        return this._size;\n    };\n    /**\n     * コンテナの全要素に対して代入処理を行う\n     * @param newSize 代入処理後のサイズ\n     * @param value 要素に代入する値\n     */\n    csmVector.prototype.assign = function (newSize, value) {\n        var curSize = this._size;\n        if (curSize < newSize) {\n            this.prepareCapacity(newSize); // capacity更新\n        }\n        for (var i = 0; i < newSize; i++) {\n            this._ptr[i] = value;\n        }\n        this._size = newSize;\n    };\n    /**\n     * サイズ変更\n     */\n    csmVector.prototype.resize = function (newSize, value) {\n        if (value === void 0) { value = null; }\n        this.updateSize(newSize, value, true);\n    };\n    /**\n     * サイズ変更\n     */\n    csmVector.prototype.updateSize = function (newSize, value, callPlacementNew) {\n        if (value === void 0) { value = null; }\n        if (callPlacementNew === void 0) { callPlacementNew = true; }\n        var curSize = this._size;\n        if (curSize < newSize) {\n            this.prepareCapacity(newSize); // capacity更新\n            if (callPlacementNew) {\n                for (var i = this._size; i < newSize; i++) {\n                    if (typeof value == 'function') {\n                        // new\n                        this._ptr[i] = JSON.parse(JSON.stringify(new value()));\n                    } // プリミティブ型なので値渡し\n                    else {\n                        this._ptr[i] = value;\n                    }\n                }\n            }\n            else {\n                for (var i = this._size; i < newSize; i++) {\n                    this._ptr[i] = value;\n                }\n            }\n        }\n        else {\n            // newSize <= this._size\n            //---\n            var sub = this._size - newSize;\n            this._ptr.splice(this._size - sub, sub); // 不要なので破棄する\n        }\n        this._size = newSize;\n    };\n    /**\n     * コンテナにコンテナ要素を挿入する\n     * @param position 挿入する位置\n     * @param begin 挿入するコンテナの開始位置\n     * @param end 挿入するコンテナの終端位置\n     */\n    csmVector.prototype.insert = function (position, begin, end) {\n        var dstSi = position._index;\n        var srcSi = begin._index;\n        var srcEi = end._index;\n        var addCount = srcEi - srcSi;\n        this.prepareCapacity(this._size + addCount);\n        // 挿入用の既存データをシフトして隙間を作る\n        var addSize = this._size - dstSi;\n        if (addSize > 0) {\n            for (var i = 0; i < addSize; i++) {\n                this._ptr.splice(dstSi + i, 0, null);\n            }\n        }\n        for (var i = srcSi; i < srcEi; i++, dstSi++) {\n            this._ptr[dstSi] = begin._vector._ptr[i];\n        }\n        this._size = this._size + addCount;\n    };\n    /**\n     * コンテナからインデックスで指定した要素を削除する\n     * @param index インデックス値\n     * @return true 削除実行\n     * @return false 削除範囲外\n     */\n    csmVector.prototype.remove = function (index) {\n        if (index < 0 || this._size <= index) {\n            return false; // 削除範囲外\n        }\n        this._ptr.splice(index, 1);\n        --this._size;\n        return true;\n    };\n    /**\n     * コンテナから要素を削除して他の要素をシフトする\n     * @param ite 削除する要素\n     */\n    csmVector.prototype.erase = function (ite) {\n        var index = ite._index;\n        if (index < 0 || this._size <= index) {\n            return ite; // 削除範囲外\n        }\n        // 削除\n        this._ptr.splice(index, 1);\n        --this._size;\n        var ite2 = new iterator(this, index); // 終了\n        return ite2;\n    };\n    /**\n     * コンテナのキャパシティを確保する\n     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない.\n     */\n    csmVector.prototype.prepareCapacity = function (newSize) {\n        if (newSize > this._capacity) {\n            if (this._capacity == 0) {\n                this._ptr = new Array(newSize);\n                this._capacity = newSize;\n            }\n            else {\n                this._ptr.length = newSize;\n                this._capacity = newSize;\n            }\n        }\n    };\n    /**\n     * コンテナの先頭要素を返す\n     */\n    csmVector.prototype.begin = function () {\n        var ite = this._size == 0 ? this.end() : new iterator(this, 0);\n        return ite;\n    };\n    /**\n     * コンテナの終端要素を返す\n     */\n    csmVector.prototype.end = function () {\n        var ite = new iterator(this, this._size);\n        return ite;\n    };\n    csmVector.prototype.getOffset = function (offset) {\n        var newVector = new csmVector();\n        newVector._ptr = this.get(offset);\n        newVector._size = this.get(offset).length;\n        newVector._capacity = this.get(offset).length;\n        return newVector;\n    };\n    csmVector.s_defaultSize = 10; // コンテナ初期化のデフォルトサイズ\n    return csmVector;\n}());\n\nvar iterator = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function iterator(v, index) {\n        this._vector = v != undefined ? v : null;\n        this._index = index != undefined ? index : 0;\n    }\n    /**\n     * 代入\n     */\n    iterator.prototype.set = function (ite) {\n        this._index = ite._index;\n        this._vector = ite._vector;\n        return this;\n    };\n    /**\n     * 前置き++演算\n     */\n    iterator.prototype.preIncrement = function () {\n        ++this._index;\n        return this;\n    };\n    /**\n     * 前置き--演算\n     */\n    iterator.prototype.preDecrement = function () {\n        --this._index;\n        return this;\n    };\n    /**\n     * 後置き++演算子\n     */\n    iterator.prototype.increment = function () {\n        var iteold = new iterator(this._vector, this._index++); // 古い値を保存\n        return iteold;\n    };\n    /**\n     * 後置き--演算子\n     */\n    iterator.prototype.decrement = function () {\n        var iteold = new iterator(this._vector, this._index--); // 古い値を保存\n        return iteold;\n    };\n    /**\n     * ptr\n     */\n    iterator.prototype.ptr = function () {\n        return this._vector._ptr[this._index];\n    };\n    /**\n     * =演算子のオーバーロード\n     */\n    iterator.prototype.substitution = function (ite) {\n        this._index = ite._index;\n        this._vector = ite._vector;\n        return this;\n    };\n    /**\n     * !=演算子のオーバーロード\n     */\n    iterator.prototype.notEqual = function (ite) {\n        return this._index != ite._index || this._vector != ite._vector;\n    };\n    return iterator;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.csmVector = _csmvector__WEBPACK_IMPORTED_MODULE_0__.csmVector;\n    Live2DCubismFramework.iterator = _csmvector__WEBPACK_IMPORTED_MODULE_0__.iterator;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/type/csmvector.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/utils/cubismdebug.ts":
/*!*******************************************************!*\
  !*** ./src/lib/live2d/Framework/utils/cubismdebug.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CSM_ASSERT\": () => (/* binding */ CSM_ASSERT),\n/* harmony export */   \"CubismDebug\": () => (/* binding */ CubismDebug),\n/* harmony export */   \"CubismLogDebug\": () => (/* binding */ CubismLogDebug),\n/* harmony export */   \"CubismLogError\": () => (/* binding */ CubismLogError),\n/* harmony export */   \"CubismLogInfo\": () => (/* binding */ CubismLogInfo),\n/* harmony export */   \"CubismLogPrint\": () => (/* binding */ CubismLogPrint),\n/* harmony export */   \"CubismLogPrintIn\": () => (/* binding */ CubismLogPrintIn),\n/* harmony export */   \"CubismLogVerbose\": () => (/* binding */ CubismLogVerbose),\n/* harmony export */   \"CubismLogWarning\": () => (/* binding */ CubismLogWarning),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework)\n/* harmony export */ });\n/* harmony import */ var _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cubismframeworkconfig */ \"./src/lib/live2d/Framework/cubismframeworkconfig.ts\");\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _cubismdebug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n\nvar CubismLogPrint = function (level, fmt, args) {\n    CubismDebug.print(level, '[CSM]' + fmt, args);\n};\nvar CubismLogPrintIn = function (level, fmt, args) {\n    CubismLogPrint(level, fmt + '\\n', args);\n};\nvar CSM_ASSERT = function (expr) {\n    console.assert(expr);\n};\nvar CubismLogVerbose;\nvar CubismLogDebug;\nvar CubismLogInfo;\nvar CubismLogWarning;\nvar CubismLogError;\nif (_cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL <= _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL_VERBOSE) {\n    CubismLogVerbose = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Verbose, '[V]' + fmt, args);\n    };\n    CubismLogDebug = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Debug, '[D]' + fmt, args);\n    };\n    CubismLogInfo = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    CubismLogWarning = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    CubismLogError = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (_cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL == _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL_DEBUG) {\n    CubismLogDebug = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Debug, '[D]' + fmt, args);\n    };\n    CubismLogInfo = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    CubismLogWarning = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    CubismLogError = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (_cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL == _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL_INFO) {\n    CubismLogInfo = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Info, '[I]' + fmt, args);\n    };\n    CubismLogWarning = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    CubismLogError = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (_cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL == _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL_WARNING) {\n    CubismLogWarning = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Warning, '[W]' + fmt, args);\n    };\n    CubismLogError = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\nelse if (_cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL == _cubismframeworkconfig__WEBPACK_IMPORTED_MODULE_0__.CSM_LOG_LEVEL_ERROR) {\n    CubismLogError = function (fmt) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        CubismLogPrintIn(_live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.LogLevel.LogLevel_Error, '[E]' + fmt, args);\n    };\n}\n/**\n * デバッグ用のユーティリティクラス。\n * ログの出力、バイトのダンプなど\n */\nvar CubismDebug = /** @class */ (function () {\n    /**\n     * private コンストラクタ\n     */\n    function CubismDebug() {\n    }\n    /**\n     * ログを出力する。第一引数にログレベルを設定する。\n     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。\n     *\n     * @param logLevel ログレベルの設定\n     * @param format 書式付き文字列\n     * @param args 可変長引数\n     */\n    CubismDebug.print = function (logLevel, format, args) {\n        // オプションで設定されたログ出力レベルを下回る場合はログに出さない\n        if (logLevel < _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.CubismFramework.getLoggingLevel()) {\n            return;\n        }\n        var logPrint = _live2dcubismframework__WEBPACK_IMPORTED_MODULE_1__.CubismFramework.coreLogFunction;\n        if (!logPrint)\n            return;\n        var buffer = format.replace(/\\{(\\d+)\\}/g, function (m, k) {\n            return args[k];\n        });\n        logPrint(buffer);\n    };\n    /**\n     * データから指定した長さだけダンプ出力する。\n     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。\n     *\n     * @param logLevel ログレベルの設定\n     * @param data ダンプするデータ\n     * @param length ダンプする長さ\n     */\n    CubismDebug.dumpBytes = function (logLevel, data, length) {\n        for (var i = 0; i < length; i++) {\n            if (i % 16 == 0 && i > 0)\n                this.print(logLevel, '\\n');\n            else if (i % 8 == 0 && i > 0)\n                this.print(logLevel, '  ');\n            this.print(logLevel, '{0} ', [data[i] & 0xff]);\n        }\n        this.print(logLevel, '\\n');\n    };\n    return CubismDebug;\n}());\n\n// Namespace definition for compatibility.\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismDebug = _cubismdebug__WEBPACK_IMPORTED_MODULE_2__.CubismDebug;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/utils/cubismdebug.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/utils/cubismjson.ts":
/*!******************************************************!*\
  !*** ./src/lib/live2d/Framework/utils/cubismjson.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismJson\": () => (/* binding */ CubismJson),\n/* harmony export */   \"JsonArray\": () => (/* binding */ JsonArray),\n/* harmony export */   \"JsonBoolean\": () => (/* binding */ JsonBoolean),\n/* harmony export */   \"JsonError\": () => (/* binding */ JsonError),\n/* harmony export */   \"JsonFloat\": () => (/* binding */ JsonFloat),\n/* harmony export */   \"JsonMap\": () => (/* binding */ JsonMap),\n/* harmony export */   \"JsonNullvalue\": () => (/* binding */ JsonNullvalue),\n/* harmony export */   \"JsonString\": () => (/* binding */ JsonString),\n/* harmony export */   \"Live2DCubismFramework\": () => (/* binding */ Live2DCubismFramework),\n/* harmony export */   \"Value\": () => (/* binding */ Value)\n/* harmony export */ });\n/* harmony import */ var _live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _type_csmmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../type/csmmap */ \"./src/lib/live2d/Framework/type/csmmap.ts\");\n/* harmony import */ var _type_csmstring__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../type/csmstring */ \"./src/lib/live2d/Framework/type/csmstring.ts\");\n/* harmony import */ var _type_csmvector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\n/* harmony import */ var _cubismdebug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cubismdebug */ \"./src/lib/live2d/Framework/utils/cubismdebug.ts\");\n/* harmony import */ var _cubismjson__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/* harmony import */ var _cubismjsonextension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cubismjsonextension */ \"./src/lib/live2d/Framework/utils/cubismjsonextension.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n// StaticInitializeNotForClientCall()で初期化する\nvar CSM_JSON_ERROR_TYPE_MISMATCH = 'Error: type mismatch';\nvar CSM_JSON_ERROR_INDEX_OF_BOUNDS = 'Error: index out of bounds';\n/**\n * パースしたJSONエレメントの要素の基底クラス。\n */\nvar Value = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function Value() {\n    }\n    /**\n     * 要素を文字列型で返す(string)\n     */\n    Value.prototype.getRawString = function (defaultValue, indent) {\n        return this.getString(defaultValue, indent);\n    };\n    /**\n     * 要素を数値型で返す(number)\n     */\n    Value.prototype.toInt = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = 0; }\n        return defaultValue;\n    };\n    /**\n     * 要素を数値型で返す(number)\n     */\n    Value.prototype.toFloat = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = 0; }\n        return defaultValue;\n    };\n    /**\n     * 要素を真偽値で返す(boolean)\n     */\n    Value.prototype.toBoolean = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = false; }\n        return defaultValue;\n    };\n    /**\n     * サイズを返す\n     */\n    Value.prototype.getSize = function () {\n        return 0;\n    };\n    /**\n     * 要素を配列で返す(Value[])\n     */\n    Value.prototype.getArray = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return defaultValue;\n    };\n    /**\n     * 要素をコンテナで返す(array)\n     */\n    Value.prototype.getVector = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector(); }\n        return defaultValue;\n    };\n    /**\n     * 要素をマップで返す(csmMap<csmString, Value>)\n     */\n    Value.prototype.getMap = function (defaultValue) {\n        return defaultValue;\n    };\n    /**\n     * 添字演算子[index]\n     */\n    Value.prototype.getValueByIndex = function (index) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    };\n    /**\n     * 添字演算子[string | csmString]\n     */\n    Value.prototype.getValueByString = function (s) {\n        return Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    };\n    /**\n     * マップのキー一覧をコンテナで返す\n     *\n     * @return マップのキーの一覧\n     */\n    Value.prototype.getKeys = function () {\n        return Value.s_dummyKeys;\n    };\n    /**\n     * Valueの種類がエラー値ならtrue\n     */\n    Value.prototype.isError = function () {\n        return false;\n    };\n    /**\n     * Valueの種類がnullならtrue\n     */\n    Value.prototype.isNull = function () {\n        return false;\n    };\n    /**\n     * Valueの種類が真偽値ならtrue\n     */\n    Value.prototype.isBool = function () {\n        return false;\n    };\n    /**\n     * Valueの種類が数値型ならtrue\n     */\n    Value.prototype.isFloat = function () {\n        return false;\n    };\n    /**\n     * Valueの種類が文字列ならtrue\n     */\n    Value.prototype.isString = function () {\n        return false;\n    };\n    /**\n     * Valueの種類が配列ならtrue\n     */\n    Value.prototype.isArray = function () {\n        return false;\n    };\n    /**\n     * Valueの種類がマップ型ならtrue\n     */\n    Value.prototype.isMap = function () {\n        return false;\n    };\n    Value.prototype.equals = function (value) {\n        return false;\n    };\n    /**\n     * Valueの値が静的ならtrue、静的なら解放しない\n     */\n    Value.prototype.isStatic = function () {\n        return false;\n    };\n    /**\n     * Valueにエラー値をセットする\n     */\n    Value.prototype.setErrorNotForClientCall = function (errorStr) {\n        return JsonError.errorValue;\n    };\n    /**\n     * 初期化用メソッド\n     */\n    Value.staticInitializeNotForClientCall = function () {\n        JsonBoolean.trueValue = new JsonBoolean(true);\n        JsonBoolean.falseValue = new JsonBoolean(false);\n        Value.errorValue = new JsonError('ERROR', true);\n        Value.nullValue = new JsonNullvalue();\n        Value.s_dummyKeys = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n    };\n    /**\n     * リリース用メソッド\n     */\n    Value.staticReleaseNotForClientCall = function () {\n        JsonBoolean.trueValue = null;\n        JsonBoolean.falseValue = null;\n        Value.errorValue = null;\n        Value.nullValue = null;\n        Value.s_dummyKeys = null;\n    };\n    return Value;\n}());\n\n/**\n * Ascii文字のみ対応した最小限の軽量JSONパーサ。\n * 仕様はJSONのサブセットとなる。\n * 設定ファイル(model3.json)などのロード用\n *\n * [未対応項目]\n * ・日本語などの非ASCII文字\n * ・eによる指数表現\n */\nvar CubismJson = /** @class */ (function () {\n    /**\n     * コンストラクタ\n     */\n    function CubismJson(buffer, length) {\n        this._parseCallback = _cubismjsonextension__WEBPACK_IMPORTED_MODULE_5__.CubismJsonExtension.parseJsonObject; // パース時に使う処理のコールバック関数\n        this._error = null;\n        this._lineCount = 0;\n        this._root = null;\n        if (buffer != undefined) {\n            this.parseBytes(buffer, length, this._parseCallback);\n        }\n    }\n    /**\n     * バイトデータから直接ロードしてパースする\n     *\n     * @param buffer バッファ\n     * @param size バッファサイズ\n     * @return CubismJsonクラスのインスタンス。失敗したらNULL\n     */\n    CubismJson.create = function (buffer, size) {\n        var json = new CubismJson();\n        var succeeded = json.parseBytes(buffer, size, json._parseCallback);\n        if (!succeeded) {\n            CubismJson.delete(json);\n            return null;\n        }\n        else {\n            return json;\n        }\n    };\n    /**\n     * パースしたJSONオブジェクトの解放処理\n     *\n     * @param instance CubismJsonクラスのインスタンス\n     */\n    CubismJson.delete = function (instance) {\n        instance = null;\n    };\n    /**\n     * パースしたJSONのルート要素を返す\n     */\n    CubismJson.prototype.getRoot = function () {\n        return this._root;\n    };\n    /**\n     *  UnicodeのバイナリをStringに変換\n     *\n     * @param buffer 変換するバイナリデータ\n     * @return 変換後の文字列\n     */\n    CubismJson.arrayBufferToString = function (buffer) {\n        var uint8Array = new Uint8Array(buffer);\n        var str = '';\n        for (var i = 0, len = uint8Array.length; i < len; ++i) {\n            str += '%' + this.pad(uint8Array[i].toString(16));\n        }\n        str = decodeURIComponent(str);\n        return str;\n    };\n    /**\n     * エンコード、パディング\n     */\n    CubismJson.pad = function (n) {\n        return n.length < 2 ? '0' + n : n;\n    };\n    /**\n     * JSONのパースを実行する\n     * @param buffer    パース対象のデータバイト\n     * @param size      データバイトのサイズ\n     * return true : 成功\n     * return false: 失敗\n     */\n    CubismJson.prototype.parseBytes = function (buffer, size, parseCallback) {\n        var endPos = new Array(1); // 参照渡しにするため配列\n        var decodeBuffer = CubismJson.arrayBufferToString(buffer);\n        if (parseCallback == undefined) {\n            this._root = this.parseValue(decodeBuffer, size, 0, endPos);\n        }\n        else {\n            // TypeScript標準のJSONパーサを使う\n            this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());\n        }\n        if (this._error) {\n            var strbuf = '\\0';\n            strbuf = 'Json parse error : @line ' + (this._lineCount + 1) + '\\n';\n            this._root = new JsonString(strbuf);\n            (0,_cubismdebug__WEBPACK_IMPORTED_MODULE_4__.CubismLogInfo)('{0}', this._root.getRawString());\n            return false;\n        }\n        else if (this._root == null) {\n            this._root = new JsonError(new _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString(this._error), false); // rootは解放されるのでエラーオブジェクトを別途作成する\n            return false;\n        }\n        return true;\n    };\n    /**\n     * パース時のエラー値を返す\n     */\n    CubismJson.prototype.getParseError = function () {\n        return this._error;\n    };\n    /**\n     * ルート要素の次の要素がファイルの終端だったらtrueを返す\n     */\n    CubismJson.prototype.checkEndOfFile = function () {\n        return this._root.getArray()[1].equals('EOF');\n    };\n    /**\n     * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする\n     * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ\n     *\n     * @param   buffer      JSONエレメントのバッファ\n     * @param   length      パースする長さ\n     * @param   begin       パースを開始する位置\n     * @param   outEndPos   パース終了時の位置\n     * @return      パースから取得したValueオブジェクト\n     */\n    CubismJson.prototype.parseValue = function (buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        var o = null;\n        var i = begin;\n        var f;\n        for (; i < length; i++) {\n            var c = buffer[i];\n            switch (c) {\n                case '-':\n                case '.':\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9': {\n                    var afterString = new Array(1); // 参照渡しにするため\n                    f = (0,_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.strtod)(buffer.slice(i), afterString);\n                    outEndPos[0] = buffer.indexOf(afterString[0]);\n                    return new JsonFloat(f);\n                }\n                case '\"':\n                    return new JsonString(this.parseString(buffer, length, i + 1, outEndPos)); // \\\"の次の文字から\n                case '[':\n                    o = this.parseArray(buffer, length, i + 1, outEndPos);\n                    return o;\n                case '{':\n                    o = this.parseObject(buffer, length, i + 1, outEndPos);\n                    return o;\n                case 'n': // null以外にない\n                    if (i + 3 < length) {\n                        o = new JsonNullvalue(); // 解放できるようにする\n                        outEndPos[0] = i + 4;\n                    }\n                    else {\n                        this._error = 'parse null';\n                    }\n                    return o;\n                case 't': // true以外にない\n                    if (i + 3 < length) {\n                        o = JsonBoolean.trueValue;\n                        outEndPos[0] = i + 4;\n                    }\n                    else {\n                        this._error = 'parse true';\n                    }\n                    return o;\n                case 'f': // false以外にない\n                    if (i + 4 < length) {\n                        o = JsonBoolean.falseValue;\n                        outEndPos[0] = i + 5;\n                    }\n                    else {\n                        this._error = \"illegal ',' position\";\n                    }\n                    return o;\n                case ',': // Array separator\n                    this._error = \"illegal ',' position\";\n                    return null;\n                case ']': // 不正な｝だがスキップする。配列の最後に不要な , があると思われる\n                    outEndPos[0] = i; // 同じ文字を再処理\n                    return null;\n                case '\\n':\n                    this._lineCount++;\n                case ' ':\n                case '\\t':\n                case '\\r':\n                default:\n                    // スキップ\n                    break;\n            }\n        }\n        this._error = 'illegal end of value';\n        return null;\n    };\n    /**\n     * 次の「\"」までの文字列をパースする。\n     *\n     * @param   string  ->  パース対象の文字列\n     * @param   length  ->  パースする長さ\n     * @param   begin   ->  パースを開始する位置\n     * @param  outEndPos   ->  パース終了時の位置\n     * @return      パースした文F字列要素\n     */\n    CubismJson.prototype.parseString = function (string, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        var i = begin;\n        var c, c2;\n        var ret = new _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString('');\n        var bufStart = begin; // sbufに登録されていない文字の開始位置\n        for (; i < length; i++) {\n            c = string[i];\n            switch (c) {\n                case '\"': {\n                    // 終端の”、エスケープ文字は別に処理されるのでここに来ない\n                    outEndPos[0] = i + 1; // ”の次の文字\n                    ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n                    return ret.s;\n                }\n                case '//': {\n                    // エスケープの場合\n                    i++; // ２文字をセットで扱う\n                    if (i - 1 > bufStart) {\n                        ret.append(string.slice(bufStart), i - bufStart); // 前の文字までを登録する\n                    }\n                    bufStart = i + 1; // エスケープ（２文字)の次の文字から\n                    if (i < length) {\n                        c2 = string[i];\n                        switch (c2) {\n                            case '\\\\':\n                                ret.expansion(1, '\\\\');\n                                break;\n                            case '\"':\n                                ret.expansion(1, '\"');\n                                break;\n                            case '/':\n                                ret.expansion(1, '/');\n                                break;\n                            case 'b':\n                                ret.expansion(1, '\\b');\n                                break;\n                            case 'f':\n                                ret.expansion(1, '\\f');\n                                break;\n                            case 'n':\n                                ret.expansion(1, '\\n');\n                                break;\n                            case 'r':\n                                ret.expansion(1, '\\r');\n                                break;\n                            case 't':\n                                ret.expansion(1, '\\t');\n                                break;\n                            case 'u':\n                                this._error = 'parse string/unicord escape not supported';\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                    else {\n                        this._error = 'parse string/escape error';\n                    }\n                }\n                default: {\n                    break;\n                }\n            }\n        }\n        this._error = 'parse string/illegal end';\n        return null;\n    };\n    /**\n     * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す\n     *\n     * @param buffer    JSONエレメントのバッファ\n     * @param length    パースする長さ\n     * @param begin     パースを開始する位置\n     * @param outEndPos パース終了時の位置\n     * @return パースから取得したValueオブジェクト\n     */\n    CubismJson.prototype.parseObject = function (buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        var ret = new JsonMap();\n        // Key: Value\n        var key = '';\n        var i = begin;\n        var c = '';\n        var localRetEndPos2 = Array(1);\n        var ok = false;\n        // , が続く限りループ\n        for (; i < length; i++) {\n            FOR_LOOP: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case '\"':\n                        key = this.parseString(buffer, length, i + 1, localRetEndPos2);\n                        if (this._error) {\n                            return null;\n                        }\n                        i = localRetEndPos2[0];\n                        ok = true;\n                        break FOR_LOOP; //-- loopから出る\n                    case '}': // 閉じカッコ\n                        outEndPos[0] = i + 1;\n                        return ret; // 空\n                    case ':':\n                        this._error = \"illegal ':' position\";\n                        break;\n                    case '\\n':\n                        this._lineCount++;\n                    default:\n                        break; // スキップする文字\n                }\n            }\n            if (!ok) {\n                this._error = 'key not found';\n                return null;\n            }\n            ok = false;\n            // : をチェック\n            FOR_LOOP2: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ':':\n                        ok = true;\n                        i++;\n                        break FOR_LOOP2;\n                    case '}':\n                        this._error = \"illegal '}' position\";\n                        break;\n                    case '\\n':\n                        this._lineCount++;\n                    // case ' ': case '\\t' : case '\\r':\n                    default:\n                        break; // スキップする文字\n                }\n            }\n            if (!ok) {\n                this._error = \"':' not found\";\n                return null;\n            }\n            // 値をチェック\n            var value = this.parseValue(buffer, length, i, localRetEndPos2);\n            if (this._error) {\n                return null;\n            }\n            i = localRetEndPos2[0];\n            // ret.put(key, value);\n            ret.put(key, value);\n            FOR_LOOP3: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ',':\n                        break FOR_LOOP3;\n                    case '}':\n                        outEndPos[0] = i + 1;\n                        return ret; // 正常終了\n                    case '\\n':\n                        this._lineCount++;\n                    default:\n                        break; // スキップ\n                }\n            }\n        }\n        this._error = 'illegal end of perseObject';\n        return null;\n    };\n    /**\n     * 次の「\"」までの文字列をパースする。\n     * @param buffer    JSONエレメントのバッファ\n     * @param length    パースする長さ\n     * @param begin     パースを開始する位置\n     * @param outEndPos パース終了時の位置\n     * @return パースから取得したValueオブジェクト\n     */\n    CubismJson.prototype.parseArray = function (buffer, length, begin, outEndPos) {\n        if (this._error)\n            return null;\n        var ret = new JsonArray();\n        // key : value\n        var i = begin;\n        var c;\n        var localRetEndpos2 = new Array(1);\n        // , が続く限りループ\n        for (; i < length; i++) {\n            // : をチェック\n            var value = this.parseValue(buffer, length, i, localRetEndpos2);\n            if (this._error) {\n                return null;\n            }\n            i = localRetEndpos2[0];\n            if (value) {\n                ret.add(value);\n            }\n            // FOR_LOOP3:\n            // boolean breakflag = false;\n            FOR_LOOP: for (; i < length; i++) {\n                c = buffer[i];\n                switch (c) {\n                    case ',':\n                        // breakflag = true;\n                        // break; // 次のKEY, VAlUEへ\n                        break FOR_LOOP;\n                    case ']':\n                        outEndPos[0] = i + 1;\n                        return ret; // 終了\n                    case '\\n':\n                        ++this._lineCount;\n                    //case ' ': case '\\t': case '\\r':\n                    default:\n                        break; // スキップ\n                }\n            }\n        }\n        ret = void 0;\n        this._error = 'illegal end of parseObject';\n        return null;\n    };\n    return CubismJson;\n}());\n\n/**\n * パースしたJSONの要素をfloat値として扱う\n */\nvar JsonFloat = /** @class */ (function (_super) {\n    __extends(JsonFloat, _super);\n    /**\n     * コンストラクタ\n     */\n    function JsonFloat(v) {\n        var _this = _super.call(this) || this;\n        _this._value = v;\n        return _this;\n    }\n    /**\n     * Valueの種類が数値型ならtrue\n     */\n    JsonFloat.prototype.isFloat = function () {\n        return true;\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonFloat.prototype.getString = function (defaultValue, indent) {\n        var strbuf = '\\0';\n        this._value = parseFloat(strbuf);\n        this._stringBuffer = strbuf;\n        return this._stringBuffer;\n    };\n    /**\n     * 要素を数値型で返す(number)\n     */\n    JsonFloat.prototype.toInt = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = 0; }\n        return parseInt(this._value.toString());\n    };\n    /**\n     * 要素を数値型で返す(number)\n     */\n    JsonFloat.prototype.toFloat = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = 0.0; }\n        return this._value;\n    };\n    JsonFloat.prototype.equals = function (value) {\n        if ('number' === typeof value) {\n            // int\n            if (Math.round(value)) {\n                return false;\n            }\n            // float\n            else {\n                return value == this._value;\n            }\n        }\n        return false;\n    };\n    return JsonFloat;\n}(Value));\n\n/**\n * パースしたJSONの要素を真偽値として扱う\n */\nvar JsonBoolean = /** @class */ (function (_super) {\n    __extends(JsonBoolean, _super);\n    /**\n     * 引数付きコンストラクタ\n     */\n    function JsonBoolean(v) {\n        var _this = _super.call(this) || this;\n        _this._boolValue = v;\n        return _this;\n    }\n    /**\n     * Valueの種類が真偽値ならtrue\n     */\n    JsonBoolean.prototype.isBool = function () {\n        return true;\n    };\n    /**\n     * 要素を真偽値で返す(boolean)\n     */\n    JsonBoolean.prototype.toBoolean = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = false; }\n        return this._boolValue;\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonBoolean.prototype.getString = function (defaultValue, indent) {\n        this._stringBuffer = this._boolValue ? 'true' : 'false';\n        return this._stringBuffer;\n    };\n    JsonBoolean.prototype.equals = function (value) {\n        if ('boolean' === typeof value) {\n            return value == this._boolValue;\n        }\n        return false;\n    };\n    /**\n     * Valueの値が静的ならtrue, 静的なら解放しない\n     */\n    JsonBoolean.prototype.isStatic = function () {\n        return true;\n    };\n    return JsonBoolean;\n}(Value));\n\n/**\n * パースしたJSONの要素を文字列として扱う\n */\nvar JsonString = /** @class */ (function (_super) {\n    __extends(JsonString, _super);\n    function JsonString(s) {\n        var _this = _super.call(this) || this;\n        if ('string' === typeof s) {\n            _this._stringBuffer = s;\n        }\n        if (s instanceof _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString) {\n            _this._stringBuffer = s.s;\n        }\n        return _this;\n    }\n    /**\n     * Valueの種類が文字列ならtrue\n     */\n    JsonString.prototype.isString = function () {\n        return true;\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonString.prototype.getString = function (defaultValue, indent) {\n        return this._stringBuffer;\n    };\n    JsonString.prototype.equals = function (value) {\n        if ('string' === typeof value) {\n            return this._stringBuffer == value;\n        }\n        if (value instanceof _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString) {\n            return this._stringBuffer == value.s;\n        }\n        return false;\n    };\n    return JsonString;\n}(Value));\n\n/**\n * JSONパース時のエラー結果。文字列型のようにふるまう\n */\nvar JsonError = /** @class */ (function (_super) {\n    __extends(JsonError, _super);\n    /**\n     * 引数付きコンストラクタ\n     */\n    function JsonError(s, isStatic) {\n        var _this = this;\n        if ('string' === typeof s) {\n            _this = _super.call(this, s) || this;\n        }\n        else {\n            _this = _super.call(this, s) || this;\n        }\n        _this._isStatic = isStatic;\n        return _this;\n    }\n    /**\n     * Valueの値が静的ならtrue、静的なら解放しない\n     */\n    JsonError.prototype.isStatic = function () {\n        return this._isStatic;\n    };\n    /**\n     * エラー情報をセットする\n     */\n    JsonError.prototype.setErrorNotForClientCall = function (s) {\n        this._stringBuffer = s;\n        return this;\n    };\n    /**\n     * Valueの種類がエラー値ならtrue\n     */\n    JsonError.prototype.isError = function () {\n        return true;\n    };\n    return JsonError;\n}(JsonString));\n\n/**\n * パースしたJSONの要素をNULL値として持つ\n */\nvar JsonNullvalue = /** @class */ (function (_super) {\n    __extends(JsonNullvalue, _super);\n    /**\n     * コンストラクタ\n     */\n    function JsonNullvalue() {\n        var _this = _super.call(this) || this;\n        _this._stringBuffer = 'NullValue';\n        return _this;\n    }\n    /**\n     * Valueの種類がNULL値ならtrue\n     */\n    JsonNullvalue.prototype.isNull = function () {\n        return true;\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonNullvalue.prototype.getString = function (defaultValue, indent) {\n        return this._stringBuffer;\n    };\n    /**\n     * Valueの値が静的ならtrue, 静的なら解放しない\n     */\n    JsonNullvalue.prototype.isStatic = function () {\n        return true;\n    };\n    /**\n     * Valueにエラー値をセットする\n     */\n    JsonNullvalue.prototype.setErrorNotForClientCall = function (s) {\n        this._stringBuffer = s;\n        return JsonError.nullValue;\n    };\n    return JsonNullvalue;\n}(Value));\n\n/**\n * パースしたJSONの要素を配列として持つ\n */\nvar JsonArray = /** @class */ (function (_super) {\n    __extends(JsonArray, _super);\n    /**\n     * コンストラクタ\n     */\n    function JsonArray() {\n        var _this = _super.call(this) || this;\n        _this._array = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n        return _this;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    JsonArray.prototype.release = function () {\n        for (var ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {\n            var v = ite.ptr();\n            if (v && !v.isStatic()) {\n                v = void 0;\n                v = null;\n            }\n        }\n    };\n    /**\n     * Valueの種類が配列ならtrue\n     */\n    JsonArray.prototype.isArray = function () {\n        return true;\n    };\n    /**\n     * 添字演算子[index]\n     */\n    JsonArray.prototype.getValueByIndex = function (index) {\n        if (index < 0 || this._array.getSize() <= index) {\n            return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);\n        }\n        var v = this._array.at(index);\n        if (v == null) {\n            return Value.nullValue;\n        }\n        return v;\n    };\n    /**\n     * 添字演算子[string | csmString]\n     */\n    JsonArray.prototype.getValueByString = function (s) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonArray.prototype.getString = function (defaultValue, indent) {\n        var stringBuffer = indent + '[\\n';\n        for (var ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {\n            var v = ite.ptr();\n            this._stringBuffer += indent + '' + v.getString(indent + ' ') + '\\n';\n        }\n        this._stringBuffer = stringBuffer + indent + ']\\n';\n        return this._stringBuffer;\n    };\n    /**\n     * 配列要素を追加する\n     * @param v 追加する要素\n     */\n    JsonArray.prototype.add = function (v) {\n        this._array.pushBack(v);\n    };\n    /**\n     * 要素をコンテナで返す(csmVector<Value>)\n     */\n    JsonArray.prototype.getVector = function (defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return this._array;\n    };\n    /**\n     * 要素の数を返す\n     */\n    JsonArray.prototype.getSize = function () {\n        return this._array.getSize();\n    };\n    return JsonArray;\n}(Value));\n\n/**\n * パースしたJSONの要素をマップとして持つ\n */\nvar JsonMap = /** @class */ (function (_super) {\n    __extends(JsonMap, _super);\n    /**\n     * コンストラクタ\n     */\n    function JsonMap() {\n        var _this = _super.call(this) || this;\n        _this._map = new _type_csmmap__WEBPACK_IMPORTED_MODULE_1__.csmMap();\n        return _this;\n    }\n    /**\n     * デストラクタ相当の処理\n     */\n    JsonMap.prototype.release = function () {\n        var ite = this._map.begin();\n        while (ite.notEqual(this._map.end())) {\n            var v = ite.ptr().second;\n            if (v && !v.isStatic()) {\n                v = void 0;\n                v = null;\n            }\n            ite.preIncrement();\n        }\n    };\n    /**\n     * Valueの値がMap型ならtrue\n     */\n    JsonMap.prototype.isMap = function () {\n        return true;\n    };\n    /**\n     * 添字演算子[string | csmString]\n     */\n    JsonMap.prototype.getValueByString = function (s) {\n        if (s instanceof _type_csmstring__WEBPACK_IMPORTED_MODULE_2__.csmString) {\n            var ret = this._map.getValue(s.s);\n            if (ret == null) {\n                return Value.nullValue;\n            }\n            return ret;\n        }\n        for (var iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {\n            if (iter.ptr().first == s) {\n                if (iter.ptr().second == null) {\n                    return Value.nullValue;\n                }\n                return iter.ptr().second;\n            }\n        }\n        return Value.nullValue;\n    };\n    /**\n     * 添字演算子[index]\n     */\n    JsonMap.prototype.getValueByIndex = function (index) {\n        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);\n    };\n    /**\n     * 要素を文字列で返す(csmString型)\n     */\n    JsonMap.prototype.getString = function (defaultValue, indent) {\n        this._stringBuffer = indent + '{\\n';\n        var ite = this._map.begin();\n        while (ite.notEqual(this._map.end())) {\n            var key = ite.ptr().first;\n            var v = ite.ptr().second;\n            this._stringBuffer +=\n                indent + ' ' + key + ' : ' + v.getString(indent + '   ') + ' \\n';\n            ite.preIncrement();\n        }\n        this._stringBuffer += indent + '}\\n';\n        return this._stringBuffer;\n    };\n    /**\n     * 要素をMap型で返す\n     */\n    JsonMap.prototype.getMap = function (defaultValue) {\n        return this._map;\n    };\n    /**\n     * Mapに要素を追加する\n     */\n    JsonMap.prototype.put = function (key, v) {\n        this._map.setValue(key, v);\n    };\n    /**\n     * Mapからキーのリストを取得する\n     */\n    JsonMap.prototype.getKeys = function () {\n        if (!this._keys) {\n            this._keys = new _type_csmvector__WEBPACK_IMPORTED_MODULE_3__.csmVector();\n            var ite = this._map.begin();\n            while (ite.notEqual(this._map.end())) {\n                var key = ite.ptr().first;\n                this._keys.pushBack(key);\n                ite.preIncrement();\n            }\n        }\n        return this._keys;\n    };\n    /**\n     * Mapの要素数を取得する\n     */\n    JsonMap.prototype.getSize = function () {\n        return this._keys.getSize();\n    };\n    return JsonMap;\n}(Value));\n\n// Namespace definition for compatibility.\n\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Live2DCubismFramework;\n(function (Live2DCubismFramework) {\n    Live2DCubismFramework.CubismJson = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.CubismJson;\n    Live2DCubismFramework.JsonArray = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonArray;\n    Live2DCubismFramework.JsonBoolean = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonBoolean;\n    Live2DCubismFramework.JsonError = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonError;\n    Live2DCubismFramework.JsonFloat = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonFloat;\n    Live2DCubismFramework.JsonMap = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonMap;\n    Live2DCubismFramework.JsonNullvalue = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonNullvalue;\n    Live2DCubismFramework.JsonString = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.JsonString;\n    Live2DCubismFramework.Value = _cubismjson__WEBPACK_IMPORTED_MODULE_6__.Value;\n})(Live2DCubismFramework || (Live2DCubismFramework = {}));\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/utils/cubismjson.ts?");

/***/ }),

/***/ "./src/lib/live2d/Framework/utils/cubismjsonextension.ts":
/*!***************************************************************!*\
  !*** ./src/lib/live2d/Framework/utils/cubismjsonextension.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubismJsonExtension\": () => (/* binding */ CubismJsonExtension)\n/* harmony export */ });\n/* harmony import */ var _cubismjson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubismjson */ \"./src/lib/live2d/Framework/utils/cubismjson.ts\");\n/**\n * Copyright(c) Live2D Inc. All rights reserved.\n *\n * Use of this source code is governed by the Live2D Open Software license\n * that can be found at https://www.live2d.com/eula/live2d-open-software-license-agreement_en.html.\n */\n\n/**\n * CubismJsonで実装されているJsonパーサを使用せず、\n * TypeScript標準のJsonパーサなどを使用し出力された結果を\n * Cubism SDKで定義されているJSONエレメントの要素に\n * 置き換える処理をするクラス。\n */\nvar CubismJsonExtension = /** @class */ (function () {\n    function CubismJsonExtension() {\n    }\n    CubismJsonExtension.parseJsonObject = function (obj, map) {\n        Object.keys(obj).forEach(function (key) {\n            if (typeof obj[key] == 'boolean') {\n                map.put(key, new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonBoolean(obj[key]));\n            }\n            else if (typeof obj[key] == 'string') {\n                map.put(key, new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonString(obj[key]));\n            }\n            else if (typeof obj[key] == 'number') {\n                map.put(key, new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonFloat(obj[key]));\n            }\n            else if (obj[key] instanceof Array) {\n                map.put(key, CubismJsonExtension.parseJsonArray(obj[key]));\n            }\n            else if (obj[key] instanceof Object) {\n                map.put(key, CubismJsonExtension.parseJsonObject(obj[key], new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonMap()));\n            }\n            else if (obj[key] == null) {\n                map.put(key, new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonNullvalue());\n            }\n            else {\n                // どれにも当てはまらない場合でも処理する\n                map.put(key, obj[key]);\n            }\n        });\n        return map;\n    };\n    CubismJsonExtension.parseJsonArray = function (obj) {\n        var _this = this;\n        var arr = new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonArray();\n        Object.keys(obj).forEach(function (key) {\n            var convKey = Number(key);\n            if (typeof convKey == 'number') {\n                if (typeof obj[convKey] == 'boolean') {\n                    arr.add(new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonBoolean(obj[convKey]));\n                }\n                else if (typeof obj[convKey] == 'string') {\n                    arr.add(new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonString(obj[convKey]));\n                }\n                else if (typeof obj[convKey] == 'number') {\n                    arr.add(new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonFloat(obj[convKey]));\n                }\n                else if (obj[key] instanceof Array) {\n                    arr.add(_this.parseJsonArray(obj[key]));\n                }\n                else if (obj[key] instanceof Object) {\n                    arr.add(_this.parseJsonObject(obj[key], new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonMap()));\n                }\n                else if (obj[key] == null) {\n                    arr.add(new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonNullvalue());\n                }\n                else {\n                    // どれにも当てはまらない場合でも処理する\n                    arr.add(obj[key]);\n                }\n            }\n            else if (obj[key] instanceof Array) {\n                arr.add(_this.parseJsonArray(obj[key]));\n            }\n            else if (obj[key] instanceof Object) {\n                arr.add(_this.parseJsonObject(obj[key], new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonMap()));\n            }\n            else if (obj[key] == null) {\n                arr.add(new _cubismjson__WEBPACK_IMPORTED_MODULE_0__.JsonNullvalue());\n            }\n            else {\n                // 配列ともObjectとも判定できなかった場合でも処理する\n                for (var i = 0; i < obj[key].length; i++) {\n                    arr.add(obj[key][i]);\n                }\n            }\n        });\n        return arr;\n    };\n    return CubismJsonExtension;\n}());\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Framework/utils/cubismjsonextension.ts?");

/***/ }),

/***/ "./src/lib/live2d/Live2dSDK.ts":
/*!*************************************!*\
  !*** ./src/lib/live2d/Live2dSDK.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACubismMotion\": () => (/* binding */ ACubismMotion),\n/* harmony export */   \"CubismEyeBlink\": () => (/* binding */ CubismEyeBlink),\n/* harmony export */   \"CubismFramework\": () => (/* binding */ CubismFramework),\n/* harmony export */   \"CubismMatrix44\": () => (/* binding */ CubismMatrix44),\n/* harmony export */   \"CubismModelSettingJson\": () => (/* binding */ CubismModelSettingJson),\n/* harmony export */   \"CubismPhysics\": () => (/* binding */ CubismPhysics),\n/* harmony export */   \"CubismUserModel\": () => (/* binding */ CubismUserModel),\n/* harmony export */   \"ICubismModelSetting\": () => (/* binding */ ICubismModelSetting),\n/* harmony export */   \"csmVector\": () => (/* binding */ csmVector)\n/* harmony export */ });\n/* harmony import */ var _Framework_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Framework/live2dcubismframework */ \"./src/lib/live2d/Framework/live2dcubismframework.ts\");\n/* harmony import */ var _Framework_icubismmodelsetting__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Framework/icubismmodelsetting */ \"./src/lib/live2d/Framework/icubismmodelsetting.ts\");\n/* harmony import */ var _Framework_cubismmodelsettingjson__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Framework/cubismmodelsettingjson */ \"./src/lib/live2d/Framework/cubismmodelsettingjson.ts\");\n/* harmony import */ var _Framework_math_CubismMatrix44__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Framework/math/CubismMatrix44 */ \"./src/lib/live2d/Framework/math/CubismMatrix44.ts\");\n/* harmony import */ var _Framework_model_cubismusermodel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Framework/model/cubismusermodel */ \"./src/lib/live2d/Framework/model/cubismusermodel.ts\");\n/* harmony import */ var _Framework_motion_acubismmotion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Framework/motion/acubismmotion */ \"./src/lib/live2d/Framework/motion/acubismmotion.ts\");\n/* harmony import */ var _Framework_physics_cubismphysics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Framework/physics/cubismphysics */ \"./src/lib/live2d/Framework/physics/cubismphysics.ts\");\n/* harmony import */ var _Framework_effect_cubismeyeblink__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Framework/effect/cubismeyeblink */ \"./src/lib/live2d/Framework/effect/cubismeyeblink.ts\");\n/* harmony import */ var _Framework_type_csmvector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Framework/type/csmvector */ \"./src/lib/live2d/Framework/type/csmvector.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar CubismFramework = _Framework_live2dcubismframework__WEBPACK_IMPORTED_MODULE_0__.Live2DCubismFramework.CubismFramework;\n\nvar ICubismModelSetting = /** @class */ (function (_super) {\n    __extends(ICubismModelSetting, _super);\n    function ICubismModelSetting() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ICubismModelSetting;\n}(_Framework_icubismmodelsetting__WEBPACK_IMPORTED_MODULE_1__.Live2DCubismFramework.ICubismModelSetting));\n\nvar CubismModelSettingJson = /** @class */ (function (_super) {\n    __extends(CubismModelSettingJson, _super);\n    function CubismModelSettingJson() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CubismModelSettingJson;\n}(_Framework_cubismmodelsettingjson__WEBPACK_IMPORTED_MODULE_2__.Live2DCubismFramework.CubismModelSettingJson));\n// math\n\nvar CubismMatrix44 = /** @class */ (function (_super) {\n    __extends(CubismMatrix44, _super);\n    function CubismMatrix44() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CubismMatrix44;\n}(_Framework_math_CubismMatrix44__WEBPACK_IMPORTED_MODULE_3__.Live2DCubismFramework.CubismMatrix44));\n\nvar CubismUserModel = /** @class */ (function (_super) {\n    __extends(CubismUserModel, _super);\n    function CubismUserModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CubismUserModel;\n}(_Framework_model_cubismusermodel__WEBPACK_IMPORTED_MODULE_4__.Live2DCubismFramework.CubismUserModel));\n// motion\n\nvar ACubismMotion = /** @class */ (function (_super) {\n    __extends(ACubismMotion, _super);\n    function ACubismMotion() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ACubismMotion;\n}(_Framework_motion_acubismmotion__WEBPACK_IMPORTED_MODULE_5__.Live2DCubismFramework.ACubismMotion));\n// import { Live2DCubismFramework as cubismmotion } from './Framework/motion/cubismmotion'\n// class CubismMotion extends cubismmotion.CubismMotion {}\n// import { Live2DCubismFramework as cubismmotionmanager } from './Framework/motion/cubismmotionmanager'\n// class CubismMotionManager extends cubismmotionmanager.CubismMotionManager {}\n// physics\n\nvar CubismPhysics = /** @class */ (function (_super) {\n    __extends(CubismPhysics, _super);\n    function CubismPhysics() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CubismPhysics;\n}(_Framework_physics_cubismphysics__WEBPACK_IMPORTED_MODULE_6__.Live2DCubismFramework.CubismPhysics));\n// effect\n\nvar CubismEyeBlink = /** @class */ (function (_super) {\n    __extends(CubismEyeBlink, _super);\n    function CubismEyeBlink() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CubismEyeBlink;\n}(_Framework_effect_cubismeyeblink__WEBPACK_IMPORTED_MODULE_7__.Live2DCubismFramework.CubismEyeBlink));\n// type\n\nvar csmVector = /** @class */ (function (_super) {\n    __extends(csmVector, _super);\n    function csmVector() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return csmVector;\n}(_Framework_type_csmvector__WEBPACK_IMPORTED_MODULE_8__.Live2DCubismFramework.csmVector));\n\n\n\n//# sourceURL=webpack://my-webpack-project/./src/lib/live2d/Live2dSDK.ts?");

/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"live2dRender\": () => (/* binding */ live2dRender)\n/* harmony export */ });\n/* harmony import */ var _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/live2d/Live2dSDK */ \"./src/lib/live2d/Live2dSDK.ts\");\n/* harmony import */ var _lib_CubismModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/CubismModel */ \"./src/lib/CubismModel.ts\");\n/* harmony import */ var _lib_FacePoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/FacePoint */ \"./src/lib/FacePoint.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nvar DEFAULT_OPTION = {\n    autoBlink: true,\n    x: 0,\n    y: 0,\n    scale: 1,\n};\nfunction live2dRender(canvas, _model, buffers, options) {\n    if (options === void 0) { options = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var gl, option, frameBuffer, modelSetting, moc3ArrayBuffer, textures, physics3ArrayBuffer, model, i, _i, textures_1, buffer, texture, i_1, len, i_2, len, defaultPosition, projectionMatrix, resizeModel, viewport, lastUpdateTime, point, loop;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    gl = canvas.getContext('webgl');\n                    if (gl === null)\n                        throw new Error('WebGL未対応のブラウザです。');\n                    gl.enable(gl.BLEND);\n                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n                    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n                    gl.enable(gl.DEPTH_TEST);\n                    gl.depthFunc(gl.LEQUAL);\n                    option = Object.assign({}, DEFAULT_OPTION, options);\n                    frameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n                    /**\n                     * Frameworkの初期化\n                     */\n                    _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.startUp();\n                    _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.initialize();\n                    modelSetting = new _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismModelSettingJson(_model, _model.byteLength);\n                    moc3ArrayBuffer = buffers.moc3, textures = buffers.textures, physics3ArrayBuffer = buffers.physics;\n                    model = new _lib_CubismModel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n                    // モデルデータをロード\n                    model.loadModel(moc3ArrayBuffer);\n                    // レンダラの作成（bindTextureより先にやっておく）\n                    model.createRenderer();\n                    i = 0;\n                    _i = 0, textures_1 = textures;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < textures_1.length)) return [3 /*break*/, 4];\n                    buffer = textures_1[_i];\n                    return [4 /*yield*/, createTexture(buffer, gl)];\n                case 2:\n                    texture = _a.sent();\n                    model.getRenderer()\n                        .bindTexture(i, texture);\n                    i++;\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4:\n                    // そのほかレンダラの設定\n                    model.getRenderer().setIsPremultipliedAlpha(true);\n                    model.getRenderer().startUp(gl);\n                    // 自動目ぱち設定\n                    if (option.autoBlink) {\n                        model.setEyeBlink(_lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismEyeBlink.create(modelSetting));\n                    }\n                    // モーションに適用する目ぱち用IDを設定\n                    for (i_1 = 0, len = modelSetting.getEyeBlinkParameterCount(); i_1 < len; i_1++) {\n                        model.addEyeBlinkParameterId(modelSetting.getEyeBlinkParameterId(i_1));\n                    }\n                    // モーションに適用する口パク用IDを設定\n                    for (i_2 = 0, len = modelSetting.getLipSyncParameterCount(); i_2 < len; i_2++) {\n                        model.addLipSyncParameterId(modelSetting.getLipSyncParameterId(i_2));\n                    }\n                    // 物理演算設定\n                    model.loadPhysics(physics3ArrayBuffer, physics3ArrayBuffer.byteLength);\n                    defaultPosition = Object.assign({\n                        x: 0,\n                        y: 0,\n                        z: 1\n                    }, {\n                        x: option.x,\n                        y: option.y,\n                        z: option.scale\n                    });\n                    projectionMatrix = new _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismMatrix44();\n                    resizeModel = function () {\n                        canvas.width = canvas.clientWidth * devicePixelRatio;\n                        canvas.height = canvas.clientHeight * devicePixelRatio;\n                        // NOTE: modelMatrixは、モデルのユニット単位での幅と高さが1×1に収まるように縮めようとしている？\n                        var modelMatrix = model.getModelMatrix();\n                        modelMatrix.bottom(0);\n                        modelMatrix.centerY(-1);\n                        modelMatrix.translateY(-1);\n                        projectionMatrix.loadIdentity();\n                        var canvasRatio = canvas.height / canvas.width;\n                        if (1 < canvasRatio) {\n                            // モデルが横にはみ出る時は、HTMLキャンバスの幅で合わせる\n                            modelMatrix.scale(1, canvas.width / canvas.height);\n                        }\n                        else {\n                            // モデルが上にはみ出る時は、HTMLキャンバスの高さで合わせる（スマホのランドスケープモードとか）\n                            modelMatrix.scale(canvas.height / canvas.width, 1);\n                        }\n                        modelMatrix.translateRelative(defaultPosition.x, defaultPosition.y);\n                        // モデルが良い感じの大きさになるように拡大・縮小\n                        projectionMatrix.multiplyByMatrix(modelMatrix);\n                        var scale = defaultPosition.z;\n                        projectionMatrix.scaleRelative(scale, scale);\n                        model.getRenderer().setMvpMatrix(projectionMatrix);\n                    };\n                    resizeModel();\n                    viewport = [\n                        0,\n                        0,\n                        canvas.width,\n                        canvas.height\n                    ];\n                    lastUpdateTime = Date.now();\n                    point = new _lib_FacePoint__WEBPACK_IMPORTED_MODULE_2__.FacePoint();\n                    loop = function () {\n                        var time = Date.now();\n                        // 最後の更新からの経過時間を秒で求める\n                        var deltaTimeSecond = (time - lastUpdateTime) / 1000;\n                        // モデルの位置調整\n                        var _model = model.getModel();\n                        var idManager = _lib_live2d_Live2dSDK__WEBPACK_IMPORTED_MODULE_0__.CubismFramework.getIdManager();\n                        _model.setParameterValueById(idManager.getId('ParamAngleX'), point.angleX, .5);\n                        _model.setParameterValueById(idManager.getId('ParamAngleY'), point.angleY, .5);\n                        _model.setParameterValueById(idManager.getId('ParamAngleZ'), point.angleZ, .5);\n                        _model.setParameterValueById(idManager.getId('ParamEyeBallX'), point.angleEyeX, .5);\n                        _model.setParameterValueById(idManager.getId('ParamEyeBallY'), point.angleEyeY, .5);\n                        _model.setParameterValueById(idManager.getId('ParamMouthOpenY'), point.mouseDistance * 0.1, .5);\n                        _model.setParameterValueById(idManager.getId('ParamBodyAngleZ'), point.angleZ / 2, .05);\n                        _model.saveParameters();\n                        // 頂点の更新\n                        model.update(deltaTimeSecond);\n                        if (model.isMotionFinished) {\n                            var idx = Math.floor(Math.random() * model.motionNames.length);\n                            var name_1 = model.motionNames[idx];\n                            model.startMotionByName(name_1);\n                        }\n                        viewport[2] = canvas.width;\n                        viewport[3] = canvas.height;\n                        model.getRenderer().setRenderState(frameBuffer, viewport);\n                        // モデルの描画\n                        model.getRenderer().drawModel();\n                        lastUpdateTime = time;\n                        requestAnimationFrame(loop);\n                    };\n                    window.onresize = function () {\n                        resizeModel();\n                        loop();\n                    };\n                    loop();\n                    return [2 /*return*/, {\n                            updatePoint: function (newPoint) {\n                                Object.assign(point, newPoint);\n                            }\n                        }];\n            }\n        });\n    });\n}\n/**\n * テクスチャを生成する\n * @param path テクスチャのパス\n * @param gl WebGLコンテキスト\n */\nfunction createTexture(blob, gl) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve) {\n                    var url = URL.createObjectURL(blob);\n                    var img = new Image();\n                    img.onload = function () {\n                        var tex = gl.createTexture();\n                        // テクスチャを選択\n                        gl.bindTexture(gl.TEXTURE_2D, tex);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                        // 乗算済みアルファ方式を使用する\n                        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n                        // テクスチャにピクセルを書き込む\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n                        // ミップマップを生成\n                        gl.generateMipmap(gl.TEXTURE_2D);\n                        URL.revokeObjectURL(url);\n                        return resolve(tex);\n                    };\n                    img.addEventListener('error', function () {\n                        console.error(\"image load error\");\n                    });\n                    img.src = url;\n                })];\n        });\n    });\n}\n\n\n//# sourceURL=webpack://my-webpack-project/./src/renderer.ts?");

/***/ }),

/***/ "./src/util/MathUtil.ts":
/*!******************************!*\
  !*** ./src/util/MathUtil.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAngle\": () => (/* binding */ getAngle),\n/* harmony export */   \"getDistance\": () => (/* binding */ getDistance)\n/* harmony export */ });\nfunction getDistance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(x2 - x1, 2) +\n        Math.pow(y2 - y1, 2));\n}\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1); // * 180 / Math.PI\n}\n\n\n//# sourceURL=webpack://my-webpack-project/./src/util/MathUtil.ts?");

/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"axios\",\"version\":\"0.21.4\",\"description\":\"Promise based HTTP client for the browser and node.js\",\"main\":\"index.js\",\"scripts\":{\"test\":\"grunt test\",\"start\":\"node ./sandbox/server.js\",\"build\":\"NODE_ENV=production grunt build\",\"preversion\":\"npm test\",\"version\":\"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\",\"postversion\":\"git push && git push --tags\",\"examples\":\"node ./examples/server.js\",\"coveralls\":\"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\",\"fix\":\"eslint --fix lib/**/*.js\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/axios/axios.git\"},\"keywords\":[\"xhr\",\"http\",\"ajax\",\"promise\",\"node\"],\"author\":\"Matt Zabriskie\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/axios/axios/issues\"},\"homepage\":\"https://axios-http.com\",\"devDependencies\":{\"coveralls\":\"^3.0.0\",\"es6-promise\":\"^4.2.4\",\"grunt\":\"^1.3.0\",\"grunt-banner\":\"^0.6.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-clean\":\"^1.1.0\",\"grunt-contrib-watch\":\"^1.0.0\",\"grunt-eslint\":\"^23.0.0\",\"grunt-karma\":\"^4.0.0\",\"grunt-mocha-test\":\"^0.13.3\",\"grunt-ts\":\"^6.0.0-beta.19\",\"grunt-webpack\":\"^4.0.2\",\"istanbul-instrumenter-loader\":\"^1.0.0\",\"jasmine-core\":\"^2.4.1\",\"karma\":\"^6.3.2\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^2.1.0\",\"karma-jasmine\":\"^1.1.1\",\"karma-jasmine-ajax\":\"^0.1.13\",\"karma-safari-launcher\":\"^1.0.0\",\"karma-sauce-launcher\":\"^4.3.6\",\"karma-sinon\":\"^1.0.5\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-webpack\":\"^4.0.2\",\"load-grunt-tasks\":\"^3.5.2\",\"minimist\":\"^1.2.0\",\"mocha\":\"^8.2.1\",\"sinon\":\"^4.5.0\",\"terser-webpack-plugin\":\"^4.2.3\",\"typescript\":\"^4.0.5\",\"url-search-params\":\"^0.10.0\",\"webpack\":\"^4.44.2\",\"webpack-dev-server\":\"^3.11.0\"},\"browser\":{\"./lib/adapters/http.js\":\"./lib/adapters/xhr.js\"},\"jsdelivr\":\"dist/axios.min.js\",\"unpkg\":\"dist/axios.min.js\",\"typings\":\"./index.d.ts\",\"dependencies\":{\"follow-redirects\":\"^1.14.0\"},\"bundlesize\":[{\"path\":\"./dist/axios.min.js\",\"threshold\":\"5kB\"}]}');\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/axios/package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;